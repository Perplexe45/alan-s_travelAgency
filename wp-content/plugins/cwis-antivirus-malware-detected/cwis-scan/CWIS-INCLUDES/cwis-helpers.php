<?php

// ezscan7objrldgpfvmqkdthyuwi4x2x5
if (!defined('CWIS_SIGNATURE')) {
	header('HTTP/1.0 403 Forbidden');
	die('-1');
}

class CwisBenchmark
{

	// CPU bench, load and throttle
	var $cpu_load_averages = array();
	var $last_cpu_benchmark = 0;
	var $time_cpu_throttled = 0;
	var $time_taken_last = 0;
	//
	// Memory limit
	var $cached_memory_limit = 0;

	function calculateRushHourFactor($hour = 0)
	{
		// Return percent of day's traffic
		switch ((int) $hour) {
			default:
			case 0:
				return 2.6;

			case 1:
			case 2:
			case 3:
				return 2.3;

			case 4:
				return 2.4;

			case 5:
				return 2.7;

			case 6:
				return 3.3;

			case 7:
				return 4;

			case 8:
				return 5;

			case 9:
				return 5.6;

			case 10:
			case 11:
			case 12:
			case 13:
			case 14:
			case 15:
				return 6;

			case 16:
				return 5.3;

			case 17:
				return 4.7;

			case 18:
				return 4.3;

			case 19:
			case 20:
			case 21:
				return 3.6;

			case 22:
				return 3.3;

			case 23:
				return 2.7;
		}
	}

	function calculateTimeTaken($precision = 3, $calculate_from_start = true)
	{
		// Calculate from start or from the last call
		if ($calculate_from_start) {
			$time_taken_last = CWIS_START_TIME;
		} else {
			$time_taken_last = $this->time_taken_last ? $this->time_taken_last : CWIS_START_TIME;
			$this->time_taken_last = microtime_float();
		}

		return round(microtime_float() - $time_taken_last, $precision);
	}

	function cpuLoadAverage()
	{
		$cpu_load_average = 1;
		$cpu_load_count = 1;
		foreach ($this->cpu_load_averages as $cpu_load_change) {
			$cpu_load_average += pow($cpu_load_change, 2);
			$cpu_load_count++;
		}

		$root_mean_square = sqrt($cpu_load_average / $cpu_load_count);
		return round($root_mean_square - 1, 3);
	}

	function cpuSpeedTest($accuracy = 10, $recalc = false)
	{
		// Recalculate or use cached data?
		if ($recalc || !$this->last_cpu_benchmark) {
			$start_time = microtime_float();

			// Default test accuracy is 10 (takes ~0.7ms on i5-6200U with score 680)
			$test_accuracy = ($accuracy < 1) ? 1 : (int) $accuracy;
			for ($k = 1; $k <= $test_accuracy; $k++) {
				for ($i = 1; $i <= 42; $i++) {
					serialize(log($i / ($i + $k)));
				}
			}

			// Calculate CPU benchmark as a number of microseconds elapsed (2*3*5*7*11*13*17*19=9699690)
			$cpu_benchmark = round((9699690 / $test_accuracy) * (microtime_float() - $start_time));
			$this->last_cpu_benchmark = $cpu_benchmark > 1 ? $cpu_benchmark : 1;
		}

		return $this->last_cpu_benchmark;
	}

	function cpuThrottle($sleep_time = 0)
	{
		if (($sleep_time = (int) $sleep_time) <= 0) {
			return null;
		}

		// Go to sleep (time in microseconds)
		if (!defined('CWIS_DEBUG') || CWIS_DEBUG < 1) {
			usleep($sleep_time);

			// Count total CPU throttling in seconds
			$this->time_cpu_throttled = round($this->time_cpu_throttled + $sleep_time / 1000000, 3);
		}
	}

	function getMemoryAvailable()
	{
		if (!$this->cached_memory_limit) {
			$this->cached_memory_limit = $this->getMemoryLimit();
		}

		return $this->cached_memory_limit - $this->getMemoryUsage();
	}

	function getMemoryLimit()
	{
		// Determine current PHP memory limit and convert to bytes
		$memory_limit = functions_exists('ini_get') ? ini_get('memory_limit') : '128M';
		return shorthand_to_bytes($memory_limit > 0 ? $memory_limit : '1536M');
	}

	function getMemoryUsage()
	{
		$memory_usage = 0;
		if (PHP_VERSION_ID >= 50200) {
			$memory_usage = memory_get_peak_usage();
		} elseif (PHP_VERSION_ID >= 40302) {
			$memory_usage = memory_get_usage();
		}

		// Return the real usage or an estimate basing on the size of serialized object
		return $memory_usage > 0 ? $memory_usage : 24 * strlen(serialize($GLOBALS));
	}

	function virtualLoadBalancing($max_sleep_time = 500000)
	{
		// Check if sample CPU benchmark is defined
		if (!defined('CPU_BENCHMARK') || CPU_BENCHMARK <= 0) {
			return null;
		}

		/* // Reducing load in CLI mode (~0.01 sec)
		  if (CWIS_IS_CLI && !CWIS_IS_CGI) {
		  $this->cpuThrottle($max_sleep_time >> 6);
		  } */

		// Get current CPU benchmark (more means higher CPU load)
		$cpu_benchmark = $this->cpuSpeedTest($accuracy = 10, true);

		// Calculate CPU load change
		$cpu_load_change = $cpu_benchmark / CPU_BENCHMARK;
		$this->cpu_load_averages[] = $cpu_load_change;

		// For throttling, CPU load should be > 1
		if ($cpu_benchmark <= CPU_BENCHMARK) {
			$this->cpuThrottle(5000); # sleep for a while
			return null;
		}

		// Take in account server traffic by hour of day
		if (!defined('CWIS_LOCAL_HOUR')) {
			$sleep_time_mcs = 10000; # default sleep time in microseconds
		} else {
			$sleep_time_mcs = 5000 * $this->calculateRushHourFactor(CWIS_LOCAL_HOUR); # from 0.012 to 0.03 sec
		}

		// Go to sleep for 0.03 sec on 2x load, 0.08 sec on 3x load and 0.24 sec on 5x load.
		$sleep_time = round($sleep_time_mcs * ($cpu_load_change * $cpu_load_change - 1));

		// Sleep and count total CPU throttling in seconds
		$this->cpuThrottle($sleep_time < $max_sleep_time ? $sleep_time : $max_sleep_time);
	}

}

class CwisDifference
{

	/**
	 * Converts string into the array suitable for comparison using array_diff.
	 * @param string $string
	 * @return array
	 */
	function convert($string = '')
	{
		$string_wrapped = wordwrap((string) $string, 300);
		return preg_split('#>\s*<|\s*[\n\r{}]+\s*#sm', $string_wrapped, null, PREG_SPLIT_NO_EMPTY);
	}

	/**
	 * Calculates the difference between two or more strings.
	 * @param string $string
	 * @return null|float
	 */
	function compare()
	{
		$difference = 0;

		// Minimum arguments count check
		$num_args = func_num_args();
		$arg_list = func_get_args();
		if ($num_args <= 1) {
			return null;
		}

		// Prepare the first argument
		$primary_arg_converted = $this->convert($arg_list[0]);
		$primary_arg_sizeof = count($primary_arg_converted);

		// Process function arguments
		for ($i = 1; $i < $num_args; $i++) {
			$current_arg_converted = $this->convert($arg_list[$i]);
			$current_arg_sizeof = count($current_arg_converted);

			// Calculate difference of the first array from an another (faster the intersect)
			$current_arg_difference_sizeof = count(array_diff($primary_arg_converted, $current_arg_converted));
			if ($current_arg_sizeof > 0) {
				$difference += $current_arg_difference_sizeof * 2 / ($primary_arg_sizeof + $current_arg_sizeof);
			}
		}

		// Return the average difference value
		return $difference / ($num_args - 1);
	}

}

class CwisDirsCreator
{

	// Last error message.
	var $error_message = '';
	//
	// File path hash (results subdirectory name).
	var $file_path_hash = '';
	//
	// Default contents of index files.
	var $index_files_contents = array(
		'.htaccess'	 => "Order Deny,Allow\nDeny from all",
		'index.html' => "<!DOCTYPE html><title></title>",
		'index.php'	 => "<?php\n// Silence is golden"
	);

	/**
	 * Creates an empty directory index file.
	 * @param string $directory
	 * @param string $filename
	 * @param null|string $contents
	 */
	function createBlankDirIndex($directory = '', $filename = 'index.html', $contents = null)
	{
		if (!is_file($directory . DIRECTORY_SEPARATOR . $filename) && is_dir($directory)) {
			if (null === $contents && isset($this->index_files_contents[$filename])) {
				$contents = $this->index_files_contents[$filename];
			}

			// Put directory index file's content
			file_put_contents_safe($directory . DIRECTORY_SEPARATOR . $filename, $contents);
		}
	}

	/**
	 * Creates temporary files and/or scan results directory.
	 * @return bool
	 */
	function createResultsDir()
	{
		// Create temporary files directory
		if (!is_dir(CWIS_TEMP_PATH) && !@mkdir(CWIS_TEMP_PATH)) {
			$this->error_message = 'Cannot create temporary files directory.';
			return false;
		}

		// Create scan results directory
		if (!is_dir(CWIS_RESULTS_PATH) && !@mkdir(CWIS_RESULTS_PATH)) {
			$this->error_message = 'Cannot create scan results directory.';
			return false;
		}

		// If work and temp dirs is not identical...
		if (CWIS_WORK_PATH !== CWIS_TEMP_PATH) {

			// Create quarantine directory
			if (!is_dir(CWIS_QUARANTINE_PATH) && @mkdir(CWIS_QUARANTINE_PATH)) {
				$this->createBlankDirIndex(CWIS_QUARANTINE_PATH);
			}

			// Create scheduler tasks directory
			if (!is_dir(CWIS_TASKS_PATH) && @mkdir(CWIS_TASKS_PATH)) {
				$this->createBlankDirIndex(CWIS_TASKS_PATH);
			}

			// Create all types of known index files
			foreach ($this->index_files_contents as $filename => $contents) {
				$this->createBlankDirIndex(CWIS_TEMP_PATH, $filename, $contents);
			}
		} else {
			// Create only blank index.html
			$this->createBlankDirIndex(CWIS_TEMP_PATH);
		}

		// Create an empty index file in results directory
		$this->createBlankDirIndex(CWIS_RESULTS_PATH);

		// Create whitelisted directory
		if (defined('CWIS_DEBUG') && CWIS_DEBUG > 0) {
			if (!is_dir(CWIS_WHITEFILE_PATH) && @mkdir(CWIS_WHITEFILE_PATH)) {
				$this->createBlankDirIndex(CWIS_WHITEFILE_PATH);
			}
		}

		return true;
	}

	/**
	 * Creates scan results subdirectory (using path's MD5 hash).
	 * @string $subdirectory
	 * @return bool
	 */
	function createResultsSubdir()
	{
		// Create scan results directory (if not exists)
		if (!is_dir(CWIS_RESULTS_PATH) && !$this->createResultsDir()) {
			return false;
		}

		// Create a subdirectory (by path hash)
		if ($this->file_path_hash) {
			$path_to_subdirectory = $this->getPathToResultsSubdir();
			if (!is_dir($path_to_subdirectory) && !@mkdir($path_to_subdirectory)) {
				$this->error_message = 'Cannot create scan results subdirectory.';
				return false;
			}

			// Protect results subdirectory with an empty index file
			$this->createBlankDirIndex($path_to_subdirectory);
		}

		return true;
	}

	/**
	 * Generates scan path's hash (MD5-based)
	 * @param string $scan_path
	 * @return string
	 */
	function generateFilePathHash($scan_path = '')
	{
		return md5('PREFIX|' . $scan_path . '|SUFFIX');
	}

	/**
	 * Returns last error message.
	 * @return string
	 */
	function getLastError()
	{
		return $this->error_message;
	}

	/**
	 * Returns path to scan results subdirectory (using path's MD5 hash).
	 * @return string
	 */
	function getPathToResultsSubdir()
	{
		return $this->file_path_hash ?
				CWIS_RESULTS_PATH . DIRECTORY_SEPARATOR . $this->file_path_hash : CWIS_RESULTS_PATH;
	}

	/**
	 * Builds absolute path to results file (used for DEBUG, PRESCAN, PROGRESS, QUEUE...).
	 * @param string $basename
	 * @param string $extension
	 * @return string
	 */
	function getResultsFilePath($basename = '', $extension = '.dat')
	{
		// Filter file basename parameter
		$basename_filtered = strtoupper(preg_replace("#\W+#s", '', $basename));

		// Filter file extension parameter
		$extension_filtered = preg_replace("#[^\.\w\_\-]+#s", '', $extension);

		// Concate a filtered filename
		$filename_filtered = 'CWIS-' . $basename_filtered . $extension_filtered;

		// Return an absolute path to the file
		return $this->getPathToResultsSubdir() . DIRECTORY_SEPARATOR . $filename_filtered;
	}

	/**
	 * Sets scan path's hash (MD5-based) used as name of results subdirectory.
	 * @param string $scan_path
	 */
	function setFilePathHash($scan_path = '')
	{
		$this->file_path_hash = $scan_path ? $this->generateFilePathHash($scan_path) : '';
	}

}

class CwisLogger
{

	// Valid debug filenames
	var $debug_filepath, $scanlog_filepath, $scanspeed_filepath;
	var $scan_path = '';

	/**
	 * Outputs memory usage in separated line and debug message with (optional) datetime prepended.
	 * @param string $message
	 * @param bool $datetime
	 */
	function debugMemoryUsage($message = '', $datetime = true)
	{
		$utilities = new CwisUtilities();
		$memory_usage = 'Memory usage: ' . $utilities->formatBytes(memory_get_usage(), 2);
		if (function_exists('memory_get_peak_usage')) {
			$memory_usage .= ' (peak is ' . $utilities->formatBytes(memory_get_peak_usage(), 2) . ')';
		}

		// Insert carriage return twice
		$this->debugMessage($message . "\n" . $memory_usage, $datetime);
	}

	/**
	 * Writes a standard DEBUG message with (optional) datetime prepended.
	 * @param string $message
	 * @param bool $datetime
	 * @param bool $newline
	 */
	function debugMessage($message = '', $datetime = true, $newline = false)
	{
		if (!defined('CWIS_DEBUG') || CWIS_DEBUG < 1) {
			return null;
		}

		return $this->writeIntoLogFile('debug', $message, $datetime, $newline);
	}

	/**
	 * Writes a SCANLOG debug message with (optional) datetime prepended.
	 * @param string $message
	 * @param bool $datetime
	 * @param bool $newline
	 */
	function scanlogMessage($message = '', $datetime = true, $newline = false)
	{
		if (!defined('CWIS_DEBUG') || CWIS_DEBUG < 2) {
			return null;
		}

		return $this->writeIntoLogFile('scanlog', $message, $datetime, $newline);
	}

	/**
	 * Writes a SCANSPEED debug message with file name, size and the time elapsed for scan.
	 * @param string $file_name
	 * @param integer $file_size
	 * @param float $time_elapsed
	 */
	function scanspeedMessage($file_name = '', $file_size = 0, $time_elapsed = 0)
	{
		$firstline = '"Filename","File size (bytes)","Time elapsed (secs)"'; //CSV's header row
		$message = '"' . $file_name . '",' . $file_size . ',' . $time_elapsed;
		return $this->writeIntoLogFile('scanspeed', $message, false, false, $firstline);
	}

	/**
	 * Writes debug message into the selected log file.
	 * @param string $logname
	 * @param string $message
	 * @param bool $datetime
	 * @param bool $newline
	 * @param string $firstline
	 * @return mixed
	 */
	function writeIntoLogFile($logname = 'debug', $message = '', $datetime = true, $newline = false, $firstline = '')
	{
		if (!defined('CWIS_DEBUG') || ($logname !== 'debug' && $logname !== 'scanlog' && $logname !== 'scanspeed')) {
			return null;
		}

		// Check a debug file name
		if (!$this->{$logname . '_filepath'}) {
			$utilities = new CwisUtilities();
			$utilities->setScanPath($this->scan_path);
			$this->{$logname . '_filepath'} = $utilities->defineFilePath($logname);
		}

		// Get absolute path to debug file
		if (!$this->{$logname . '_filepath'}) {
			$path_to_logfile = CWIS_RESULTS_PATH . DIRECTORY_SEPARATOR . 'CWIS-' . strtoupper($logname) . '.dat';
		} else {
			$path_to_logfile = $this->{$logname . '_filepath'};
		}

		// Prepend a timestamp
		if ($datetime) {
			$message = '[' . date('Y-m-d H:i:s') . '] ' . $message;
		}

		// Prepend a new line
		if ($newline) {
			$message = "\n" . $message;
		}

		// Prefend the "firstline" (ie header row), if defined
		if (strlen($firstline) && !is_file($path_to_logfile)) {
			$message = $firstline . "\r\n" . $message;
		}

		// Write debug message into file
		return @file_put_contents_safe($path_to_logfile, $message . "\r\n", FILE_APPEND | LOCK_EX);
	}

	/**
	 * Sets scan path.
	 * @param string $scan_path
	 * @return string
	 */
	function setScanPath($scan_path = '')
	{
		$this->scan_path = $scan_path;
	}

}

class CwisPreg
{

	/**
	 * Delimiters used in regex patterns (character).
	 * @var string 
	 */
	var $delimiters = '~';

	/**
	 * Modifiers used in regex patterns.
	 * @param string $patterns
	 */
	var $modifiers = 'smiS';

	/**
	 * Filled with the results matched.
	 * @var array $matches
	 */
	var $matches = array();

	/**
	 * Returns the last matches.
	 * @param array $matches
	 */
	function getMatches()
	{
		return $this->matches;
	}

	/**
	 * Wrapper for preg_match, except the method supports arrays of patterns.
	 * @param type $patterns
	 * @param type $subject
	 * @return bool
	 */
	function match($patterns = array(), $subject = '')
	{
		if (!is_array($patterns)) {
			$patterns = array($patterns);
		}

		$this->matches = array();
		foreach ($patterns as $pattern) {
			if (preg_match($this->delimiters . $pattern . $this->delimiters .
							$this->modifiers, $subject, $this->matches, PREG_OFFSET_CAPTURE)) {
				return true;
			}
		}

		return false;
	}

}

class CwisProgress
{

	// Paths to progress and results files
	var $progress_filepath, $results_filepath;
	//
	// Configuration options
	var $config;
	//
	// Reference to scan queue
	var $queue;
	//
	// Classes instances
	var $benchmark, $utilities;
	//
	// SCAN RESULTS (since v1.8.1.6)
	// -------------------------------------------------------
	// Every var is an array that MUST contain a "file" and 
	// MAY contain the "fragment" and/or "sig" properties.
	var $results = array(
		'Vulnerable'		 => array(),
		'VulnerCMS'			 => array(),
		// --- CRITICAL (5 types) ---
		'CriticalJS'		 => array(),
		'CriticalPHP'		 => array(),
		'Htaccess'			 => array(),
		'Phishing'			 => array(),
		'WebShells'			 => array(),
		// --- INFO (8 types) ---
		'BigFiles'			 => array(),
		'GitFiles'			 => array(),
		'HiddenFiles'		 => array(),
		'NotRead'			 => array(),
		'PrivateIP'			 => array(),
		'SkippedDirs'		 => array(),
		'SymLinks'			 => array(),
		'Whitelisted'		 => array(),
		// --- WARNINGS (4 types) ---
		'AdwareList'		 => array(),
		'Doorways'			 => array(),
		'EmptyLinks'		 => array(),
		// --- SUSP (5 types) ---
		'Heuristic'			 => array(),
		'Iframer'			 => array(),
		'MaliciousCode'		 => array(),
		'PHPCodeInside'		 => array(),
		'UnixExec'			 => array(),
		'VulnerCode'		 => array(),
		// --- DETAILS (DEPRECATED) ---
		'EntryCRC'			 => array(),
		'EntryDetails'		 => array(),
		// --- CMS/PLUGINS DETECTED ---
		'DetectedCMS'		 => array(),
		'DetectedPlugins'	 => array(),
		// --- IGNORE LISTS ---
		'DirIgnoreList'		 => array(),
		'FileIgnoreList'	 => array(),
		'IgnoredExt'		 => array(),
		'UrlIgnoreList'		 => array(),
	);

	/**
	 * Use this method as a class constructor.
	 * @param mixed $config
	 * @param mixed $queue
	 * @param mixed $benchmark
	 */
	function construct($config, &$queue, &$benchmark)
	{

		// Pass configuration options
		if (gettype($config) === 'object') {
			$this->config = $config;
		}

		// Instantiate the core classes
		$this->utilities = new CwisUtilities();
		$this->utilities->setScanPath($this->config->getScanPath());

		// Build a progress and results file names
		$this->progress_filepath = $this->utilities->defineFilePath('progress');
		$this->results_filepath = $this->utilities->defineFilePath('results');

		// Pointer to scan queue object
		$this->queue = & $queue;

		// Pointer to benchmark object
		$this->benchmark = & $benchmark;
	}

	/**
	 * Adds a scan result to results array.
	 * @param string|null $var
	 * @param string $name
	 * @param string $type
	 * @param bool $skip_empty
	 * @return bool
	 */
	function pushScanResult($var = null, $name = '', $type = 'info', $skip_empty = false)
	{
		if (null === $var) {
			$scan_result = array();
		} else {
			if (!$var || ($skip_empty && empty($this->results[$var]))) {
				return false;
			}

			// Get scan result
			$scan_result = $this->results[$var];
		}

		// Validate result type
		if ($type !== 'vuln' && $type !== 'crit' && $type !== 'warn' && $type !== 'susp') {
			$type = 'info';
		}

		// Make sure that results property is exists
		if (!isset($this->queue->results)) {
			$this->queue->results = array();
		}

		if (($count = count($scan_result)) >= 0) {
			$this->queue->results[] = array(
				'count'	 => $count,
				'name'	 => $name,
				'type'	 => $type
			);
		}

		return true;
	}

	function createData($update_time_taken = true)
	{
		// Update progress benchmarks and memory usage
		$this->queue->updateBenchmarks($this->benchmark);

		// Update config data, scan progress, timers...
		$time_taken = $update_time_taken ? $this->benchmark->calculateTimeTaken(3, false) : 0;
		$this->queue->updateProgress($this->config, $time_taken);

		// Update versions (if not defined)
		if (!$this->queue->versions['current']) {
			$this->queue->updateVersions();
		}

		/////////////////////////////////////////////////////////////////////
		// Clear previous scan results
		$this->queue->results = array();
		foreach ($this->config->report_vars as $threat_type => $report_vars) {
			foreach ($report_vars as $var => $name) {
				$this->pushScanResult($var, $name, $threat_type);
			}
		}

		// PHP info (added after prescan finished)
		if ($this->queue->prescan['percent'] > 0) {
			$this->pushScanResult(null, _CWIS_RESULT_PHP_INFO, 'info');
		}

		// Create the progress data object
		$progress_data = array(
			'queue'		 => $this->queue, // pointer to progress queue object (since v1.9.1.9)
			'results'	 => $this->results, // pass raw scan results (since v1.8.1.6)
		);

		return $progress_data;
	}

	/**
	 * Creates and initializes a merged progress queue.
	 * @return \CwisQueue
	 */
	function createMergedQueue()
	{
		$merged_queue = new CwisQueue();

		// Must reset initial offsets
		$merged_queue->prescan['discovered'] = 0;
		$merged_queue->rescan['discovered'] = 0;
		$merged_queue->rescan['offset'] = 0;
		$merged_queue->scan['offset'] = 0;

		// Set initial statuses to "completed"
		$merged_queue->prescan['depth'] = -1;
		$merged_queue->prescan['completed'] = 1;
		$merged_queue->prescan['cmsplgs'] = 1;
		$merged_queue->prescan['cmsvers'] = 1;
		$merged_queue->rescan['completed'] = 1;
		$merged_queue->scan['completed'] = 1;
		$merged_queue->tables['completed'] = 1;

		// Set initial timestamps to "now"
		$merged_queue->time['timelast'] = time();
		$merged_queue->time['timestamp'] = time();

		return $merged_queue;
	}

	/**
	 * Merges progress data from different scan paths.
	 * @param string $scan_path_original
	 * @param bool $queue_only Merge only queue data.
	 * @return bool
	 */
	function mergeProgressData($scan_path_original = '', $queue_only = false)
	{
		$scan_paths = $this->utilities->splitScanPath($scan_path_original);
		$config = $this->config;
		$queue = new CwisQueue();

		// Progress data
		$merged_queue = $this->createMergedQueue();
		$merged_results = array();

		// Copy user data
		$merged_queue->userinfo = $this->queue->userinfo;

		// Create empty results
		$cwisResults = new CwisResults();
		$cwisResults->emptyResults();

		// Merge progress data
		if (is_array($scan_paths)) {
			foreach ($scan_paths as $scan_path) {

				// Load the progress data
				$config->setScanPath($scan_path, $realpath = true);
				$this->construct($config, $queue, $this->benchmark);
				if (!$queue_only) {
					$progress_data = $this->load($measure_time_taken = false);
				} else {
					$progress_data = array();
					$progress_data['queue'] = $this->loadQueue();
				}

				// Merge scan progress (queue data)
				$merged_queue->mergeScanProgress($progress_data['queue']);
				unset($progress_data['queue']);

				// Merge scan results (raw report data)
				if (!$queue_only) {
					$merged_results = $cwisResults->mergeScanResults($progress_data['results']);
				}

				// Free up memory
				unset($progress_data);
			}
		}

		// Restore original scan_path in queue
		$config->setScanPath($scan_path_original);
		$merged_queue->updateProgress($config);

		// Progress data
		return array(
			'queue'		 => $merged_queue,
			'results'	 => $merged_results
		);
	}

	/**
	 * Synchronizes the content of the first object with the second one.
	 * @param mixed $obj1
	 * @param mixed $obj2
	 * @return null
	 */
	function synchronizeProgressData($obj1, $obj2, $strict = true)
	{
		if (
				(!$strict && is_empty($obj1)) || // strict sync
				(!is_object($obj1) && !is_array($obj1))
		) {
			return $obj2;
		}

		// Get obj1 type
		$is_object = is_object($obj1);
		$is_array = is_array($obj1);

		// Loop recursively 
		foreach ($obj1 as $prop => $val1) {
			if ($is_object && isset($obj1->$prop) && isset($obj2->$prop)) {
				$obj1->$prop = $this->synchronizeProgressData($val1, $obj2->$prop, $strict);
			} elseif ($is_array && isset($obj1[$prop]) && isset($obj2[$prop])) {
				$obj1[$prop] = $this->synchronizeProgressData($val1, $obj2[$prop], $strict);
			}
		}

		return $obj1;
	}

	function restoreData(& $progress_data, $measure_time_taken = false)
	{
		// Set progress data
		if (!isset($progress_data['queue']) && $this->queue) {
			$progress_data['queue'] = $this->queue;
		}

		// Restore the last state of the queue
		if (isset($progress_data['queue']) && $this->queue) {
			$progress_data_queue = $progress_data['queue'];

			// Restore CPU benchmark data
			if (isset($progress_data_queue->system) && !defined('CPU_BENCHMARK')) {
				define('CPU_BENCHMARK', $progress_data_queue->system['cpumark']);
			}

			// Restore scan path
			if (!$progress_data_queue->scan['path']) {
				$progress_data_queue->scan['path'] = $this->config->getScanPath($relative = true);
			}

			// Synchronize user info
			$progress_data_queue->userinfo = $this->queue->userinfo;

			// Store the actual app version
			$progress_data_queue->version = CWIS_VERSION;

			// Override license type and userinfo (since v2.3.0)
			if (($is_license_updated = ($progress_data_queue->scan['license'] !== $this->config->license))) {
				$progress_data_queue->scan['license'] = $this->config->license;

				/*
				  // Reset scan progress status if switched from a FREE version
				  if ($this->config->isPremium() && $progress_data_queue->scan['percent'] < 100) {
				  $progress_data_queue->scan['completed'] = 0;
				  $progress_data_queue->tables['completed'] = 0;
				  }
				 */

				// Save data on license type change
				$this->saveSerializedData($this->progress_filepath, $progress_data_queue);
			}

			// Synchronize with the default queue
			$queue = $this->synchronizeProgressData(new CwisQueue(), $this->queue);
			$this->queue = $this->synchronizeProgressData($queue, $progress_data_queue);

			// Pass previous system errors to next JSON
			/* if (!empty($progress_data_queue->errors)) {
			  foreach ($progress_data_queue->errors as $message) {
			  $this->queue->errors[] = $message;
			  }
			  } */

			// Pass previous system messages to next JSON
			if (!empty($progress_data_queue->messages)) {
				foreach ($progress_data_queue->messages as $message) {
					if (false !== strpos($message, 'SQLSTATE')) {
						$this->queue->messages[] = $message;
					}
				}
			}

			// Update benchmark's timer
			if ($measure_time_taken || (isset($this->queue->scan['offset']) && $this->queue->scan['offset'] < 0)) {
				$this->queue->time['taken'] = $this->benchmark->calculateTimeTaken();
			}

			// Instantiate the benchmark class
			if (isset($this->queue->time['throttled'])) {
				$this->benchmark->time_cpu_throttled = $this->queue->time['throttled'];
			}
		}

		// Restore scan results (since v1.8.1.6)
		// -------------------------------------------------------
		// Every var is an array that MUST contain a "file" and 
		// MAY contain the "fragment" and/or "sig" properties.
		$results = isset($progress_data['results']) ?
				$progress_data['results'] : array();
		foreach ($this->results as $var => $array) {
			if (isset($results[$var])) {
				$this->results[$var] = $array = $results[$var];
			}

			if (!is_array($array)) {
				$this->results[$var] = array();
			}
		}
	}

	function delete()
	{
		return $this->isExists() ? unlink($this->progress_filepath) && unlink($this->results_filepath) : null;
	}

	/**
	 * Checks if the PROGRESS_FILEPATH is exists.
	 * @return bool
	 */
	function isExists()
	{
		return is_file($this->progress_filepath) && is_file($this->results_filepath);
	}

	function save($update_time_taken = true)
	{
		// Prepare progress data
		$progress_data = $this->createData($update_time_taken);

		// Save queue and results data separately
		if (!$this->saveQueue($progress_data['queue']) || !$this->saveResults($progress_data['results'])) {
			return false;
		}

		return $progress_data;
	}

	function saveQueue($queue = null)
	{
		return $this->saveSerializedData($this->progress_filepath, $queue);
	}

	function saveResults($results = null)
	{
		return $this->saveSerializedData($this->results_filepath, array(CWIS_SIGNATURE) + $results);
	}

	/**
	 * Loads progress data.
	 * @param bool $measure_time_taken
	 * @param bool $queue_only Merge only queue data.
	 * @return type
	 */
	function load($measure_time_taken = false, $queue_only = false)
	{
		// Prepare progress data
		$progress_data = array(
			'queue'		 => $this->queue,
			'results'	 => $this->results
		);

		// Load queue and (optionally) results
		$progress_data['queue'] = $this->loadQueue();
		if (!$queue_only) {
			$progress_data['results'] = $this->loadResults();
		}
		$this->restoreData($progress_data, $measure_time_taken);

		return $progress_data;
	}

	function loadQueue()
	{
		return is_file($this->progress_filepath) ?
				$this->loadSerializedData($this->progress_filepath) : null;
	}

	function loadResults()
	{
		return is_file($this->results_filepath) ?
				$this->loadSerializedData($this->results_filepath) : null;
	}

	// --- PRIVATE METHODS ---

	function loadSerializedData($filepath = '')
	{
		$serialized_data = file_get_contents_safe($filepath);
		return $serialized_data ? @unserialize($serialized_data) : null;
	}

	function saveSerializedData($filepath = '', $data = '')
	{
		$serialized_data = serialize($data);
		return (false !== file_put_contents_safe($filepath, $serialized_data));
	}

}

class CwisQueue
{

	// System errors
	var $errors = array();
	//
	// System messages
	var $messages = array();
	//
	// Prescan progress
	var $prescan = array(
		'completed'	 => -1, // prescan status
		'cmsplgs'	 => -1, // plugins detector status
		'cmsvers'	 => -1, // cms detector status
		'depth'		 => 0, // initial scan depth
		'discovered' => -1, // files discovered
		'processed'	 => 0, // files processed
		'percent'	 => 0, // prescan progress
	);
	//
	// Progress, current path
	var $progress = '';
	//
	// Rescan progress
	var $rescan = array(
		'completed'	 => 1, // rescan status (should be +1)
		'counter'	 => 0, // queued totally
		'discovered' => -1, // files discovered
		'modified'	 => 0, // modified scan status
		'offset'	 => -1, // an offset in queue
		'processed'	 => 0, // files processed
		'percent'	 => 0, // rescan progress   
		'speed'		 => 0, // rescan speed
	);
	//
	// Scan results report
	var $results = array();
	//
	// Scan progress
	var $scan = array(
		'completed'		 => 0, // scan status
		'counter'		 => 0, // queued totally
		'database'		 => 0, // database scan
		// Files stats
		'files'			 => array(
			'found'		 => 0,
			'scanned'	 => 0,
			'skipped'	 => 0,
		),
		// Directories stats
		'directories'	 => array(
			'found'		 => 0,
			'scanned'	 => 0,
			'skipped'	 => 0,
		),
		'extskip'		 => '', // skip file extensions
		'level'			 => 0, // current scan level
		'license'		 => '', // license type (empty)
		'load'			 => 0, // server load in percents
		'merged'		 => 0, // count of merged paths
		'offset'		 => -1, // an offset in queue
		'path'			 => '', // scan path (actual)
		'percent'		 => 0, // progress percent
		'promode'		 => 0, // promode status
		'size'			 => 0, // total file size
		'speed'			 => 0, // files/sec scanned
		'timeout'		 => 0, // scan period timeout
		'type'			 => 0, // last scan type
	);
	//
	// Scanner statistics (private)
	var $statistics = array(
		'fileignore' => 0,
		'dirignore'	 => 0,
		'urlignore'	 => 0,
		'whitelist'	 => 0,
	);
	//
	// System info and stats
	var $system = array(
		'cpumark'	 => 0, // CPU benchmark
		'memory'	 => array(
			'limit'	 => 0, // memory limit
			'usage'	 => 0, // memory usage
		),
		'signatures' => 0, // malicious signatures known
	);
	//
	// Database tables scan
	var $tables = array(
		'completed'	 => -1, // scan status
		'discovered' => -1, // tables discovered
		'offset'	 => 0, // table row offset
		'processed'	 => 0, // tables processed
		'percent'	 => 0, // scan progress
		'rows'		 => 0, // rows scanned totally
		'size'		 => 0, // total rows size
		'skipped'	 => 0
	);
	//
	// Scan timings
	var $time = array(
		'elapsed'	 => 0,
		'left'		 => 0,
		'overall'	 => 0,
		'taken'		 => 0,
		'throttled'	 => 0,
		'timelast'	 => 0,
		'timestamp'	 => 0,
	);
	//
	// User info
	var $userinfo = array(
		'company'	 => '',
		'datebeg'	 => '',
		'datenext'	 => '',
		'dateend'	 => '',
		'daysleft'	 => -1,
		'domain'	 => '',
		'email'		 => '',
		'error'		 => '',
		'name'		 => '',
		'product'	 => ''
	);
	//
	// Current CWIS version
	var $version = CWIS_VERSION;
	//
	// Current and latest versions
	var $versions = array(
		'current'	 => '',
		'latest'	 => ''
	);

	// --- Boolean methods ---

	/**
	 * Checks if database tables scanning is finished.
	 * @return bool
	 */
	function isDatabaseScanFinished()
	{
		return (bool) ($this->tables['completed'] > 0 || $this->tables['skipped'] > 0);
	}

	/**
	 * Checks if file scanning is finished.
	 * @return bool
	 */
	function isFileScanFinished()
	{
		return (bool) ($this->scan['completed'] > 0);
	}

	/**
	 * Checks if file rescanning is finished.
	 * @return bool
	 */
	function isFileRescanFinished()
	{
		// Check that file rescan is completed
		return (bool) ($this->rescan['completed'] > 0);
	}

	/**
	 * Checks if file rescanning is in progress.
	 * @return bool
	 */
	function isFileRescanInProgress()
	{
		return (bool) ($this->rescan['discovered'] >= 0);
	}

	/**
	 * Checks if server prescan is finished.
	 * @return bool
	 */
	function isPrescanFinished()
	{
		// Is prescan finished?
		return (bool) ($this->prescan['completed'] > 0);
	}

	/**
	 * Checks if server scanning is finished.
	 * @return bool
	 */
	function isScanFinished()
	{
		// Return result
		return (bool) ($this->isPrescanFinished() && $this->isFileScanFinished() && $this->isDatabaseScanFinished());
	}

	/**
	 * Checks if server rescanning is finished.
	 * @return bool
	 */
	function isRescanFinished()
	{
		return (bool) ($this->isPrescanFinished() && $this->isFileRescanFinished() && $this->isDatabaseScanFinished());
	}

	/**
	 * Checks if database/server prescan, rescan AND scan are finished.
	 * @since 3.1.1
	 * @return bool
	 */
	function isAllFinished()
	{
		return (bool) ($this->isScanFinished() && $this->isRescanFinished());
	}

	// --- Helper methods ---

	/**
	 * Adds system error to the list.
	 * @param string $error
	 */
	function addError($error = '')
	{
		if (!empty($error)) {
			$this->errors[] = $error;

			// Remove duplicates (use faster analog of array_unique)
			$this->errors = array_keys(array_flip($this->errors));
		}

		// Limit elements count to 10
		//$this->errors = array_slice($this->errors, -9, 9);
	}

	/**
	 * Adds system message to the list.
	 * @param string $message
	 */
	function addMessage($message = '')
	{
		if (!empty($message)) {
			// Sanitize characters using utf8_sanitize
			$this->messages[] = utf8_sanitize($message);

			// Remove duplicates (use faster analog of array_unique)
			$this->messages = array_keys(array_flip($this->messages));
		}

		// Limit elements count to 10
		//$this->messages = array_slice($this->messages, -9, 9);
	}

	/**
	 * Merges with another queue data.
	 * @param mixed $queue
	 */
	function mergeScanProgress($queue = null)
	{
		// Check and fix the issue with empty queue data
		if (null === $queue || !gettype($queue) === 'object') {
			$queue = new CwisQueue();
		}

		// System errors
		// -------------
		if (is_array($queue->errors)) {
			$this->errors = array_merge($this->errors, $queue->errors);
		}

		// System messages
		// ---------------
		if (is_array($queue->messages)) {
			$this->messages = array_unique(array_merge($this->messages, $queue->messages));
		}

		// Prescan progress
		// ----------------
		if (is_array($queue->prescan)) {
			$this->prescan['completed'] = min($this->prescan['completed'], $queue->prescan['completed']);
			$this->prescan['cmsplgs'] = min($this->prescan['cmsplgs'], $queue->prescan['cmsplgs']);
			$this->prescan['cmsvers'] = min($this->prescan['cmsvers'], $queue->prescan['cmsvers']);
			if ($queue->prescan['discovered'] > 0) {
				$this->prescan['discovered'] += $queue->prescan['discovered'];
			}
			$this->prescan['depth'] = max($this->prescan['depth'], $queue->prescan['depth']);
			$this->prescan['processed'] += $queue->prescan['processed'];
		}

		// Progress, current path
		// ----------------------
		if (!$this->progress) {
			$this->progress = $queue->progress;
		}

		// Rescan progress
		// ---------------
		if (is_array($queue->rescan)) {
			$this->rescan['completed'] = min($this->rescan['completed'], $queue->rescan['completed']);
			$this->rescan['counter'] += $queue->rescan['counter'];
			if ($queue->rescan['discovered'] > 0) {
				$this->rescan['discovered'] += $queue->rescan['discovered'];
			}
			$this->rescan['processed'] += $queue->rescan['processed'];
			if ($queue->rescan['offset'] > 0) {
				$this->rescan['offset'] += $queue->rescan['offset'];
			}
		}

		// Scan results report
		// -------------------
		if (is_array($queue->results)) {
			foreach ($queue->results as $i => $result) {
				$result_name = $result['name'];
				if (!isset($this->results[$i])) {
					$this->results[$i] = $result;
				} elseif ($this->results[$i]['name'] === $result_name) {
					$this->results[$i]['count'] += $result['count'];
				}
			}
		}

		// Scan progress
		// -------------
		if (is_array($queue->scan)) {
			$this->scan['completed'] = min($this->scan['completed'], $queue->scan['completed']);
			$this->scan['counter'] += $queue->scan['counter'];
			$this->scan['database'] = $queue->scan['database'];
			// Files stats
			if (is_array($queue->scan['files'])) {
				$this->scan['files']['found'] += $queue->scan['files']['found'];
				$this->scan['files']['scanned'] += $queue->scan['files']['scanned'];
				$this->scan['files']['skipped'] += $queue->scan['files']['skipped'];
			}
			// Directories stats
			if (is_array($queue->scan['directories'])) {
				$this->scan['directories']['found'] += $queue->scan['directories']['found'];
				$this->scan['directories']['scanned'] += $queue->scan['directories']['scanned'];
				$this->scan['directories']['skipped'] += $queue->scan['directories']['skipped'];
			}
			// Misc scan data
			$this->scan['extskip'] = $queue->scan['extskip'];
			$this->scan['level'] = $queue->scan['level'];
			$this->scan['license'] = $queue->scan['license'];
			$this->scan['load'] = max($this->scan['load'], $queue->scan['load']);
			if ($queue->scan['offset'] > 0) {
				$this->scan['merged'] ++;
				$this->scan['offset'] += $queue->scan['offset'];
			}
			$this->scan['promode'] = $queue->scan['promode'];
			$this->scan['size'] += $queue->scan['size'];
			$this->scan['speed'] = round(($this->scan['speed'] + $queue->scan['speed']) / 2);
			$this->scan['timeout'] = max($this->scan['timeout'], $queue->scan['timeout']);
			$this->scan['type'] = $queue->scan['type'];
		}

		// Scanner statistics
		// ------------------
		if (isset($queue->statistics)) {
			$this->statistics = $queue->statistics;
		}

		// System info and stats
		// ---------------------
		if (is_array($queue->system)) {
			$this->system['cpumark'] = max($this->system['cpumark'], $queue->system['cpumark']);
			if (is_array($queue->system['memory'])) {
				$this->system['memory']['limit'] = max($this->system['memory']['limit'], $queue->system['memory']['limit']);
				$this->system['memory']['usage'] = max($this->system['memory']['usage'], $queue->system['memory']['usage']);
			}
			$this->system['signatures'] = max($this->system['signatures'], $queue->system['signatures']);
		}

		// Database tables scan
		// --------------------
		if (is_array($queue->tables)) {
			$this->tables['completed'] = min($this->tables['completed'], $queue->tables['completed']);
			if ($this->tables['discovered'] < 0) {
				$this->tables['discovered'] = $queue->tables['discovered'];
			} else {
				$this->tables['discovered'] += $queue->tables['discovered'];
			}
			$this->tables['processed'] += $queue->tables['processed'];
			$this->tables['rows'] += $queue->tables['rows'];
			$this->tables['size'] += $queue->tables['size'];
			$this->tables['skipped'] += $queue->tables['skipped'];
		}

		// Scan timings
		// ------------
		if (is_array($queue->time)) {
			$this->time['elapsed'] += $queue->time['elapsed'];
			$this->time['left'] += $queue->time['left'];
			$this->time['overall'] += $queue->time['overall'];
			$this->time['taken'] += $queue->time['taken'];
			$this->time['throttled'] += $queue->time['throttled'];
			$this->time['timelast'] = min($this->time['timelast'], $queue->time['timelast']);
			$this->time['timestamp'] = min($this->time['timestamp'], $queue->time['timestamp']);
		}

		// User info
		// ---------
		if (method_exists($queue, 'validUserData') && $queue->validUserData()) {
			$this->userinfo = $queue->userinfo;
		}

		// Current and latest versions
		// ---------------------------
		if (is_array($queue->versions)) {
			$this->versions['current'] = max($this->versions['current'], $queue->versions['current']);
			$this->versions['latest'] = max($this->versions['latest'], $queue->versions['latest']);
		}
	}

	/**
	 * Resets scan progress (e.g prepares for quick or full rescan).
	 * @param bool $full_rescan
	 */
	function resetScanProgress($full_rescan = false)
	{
		// Reset prescan status
		$this->prescan['completed'] = -1;
		$this->prescan['cmsplgs'] = -1;
		$this->prescan['cmsvers'] = -1;

		// Reset rescan progress
		$this->rescan['completed'] = $full_rescan ? 1 : -1;
		$this->rescan['counter'] = 0;
		$this->rescan['discovered'] = -1;
		$this->rescan['modified'] = $full_rescan ? 0 : -1;
		$this->rescan['offset'] = -1;
		$this->rescan['processed'] = 0;

		// Set a new scan type
		$this->scan['type'] = $full_rescan ? 1 : 2;

		// Restart database scan
		$this->tables['completed'] = -1;
		$this->tables['discovered'] = -1;
		$this->tables['offset'] = 0;
		$this->tables['processed'] = 0;
		$this->tables['rows'] = 0;
		$this->tables['size'] = 0;

		// Sync overall and elapsed times
		$this->time['overall'] += $this->time['elapsed'];
		$this->time['elapsed'] = 0;
		$this->time['left'] = 0;
		$this->time['timestamp'] = time();

		// Clear old queue errors
		$this->errors = array();

		// Clear old queue messages
		$this->messages = array();

		// Update versions
		$this->updateVersions();
	}

	/**
	 * Sets last progress path.
	 * @param string $path
	 */
	function setProgress($path = '', $limit = 50)
	{
		if (($base_path = CWIS_SCAN_PATH ? CWIS_SCAN_PATH : CWIS_ROOT_PATH)) {
			$path = str_replace($base_path, '', $path);
		}

		// Limit path length and sanitize characters
		$utilities = new CwisUtilities();
		$this->progress = $utilities->filenameShorten($path, $limit);
	}

	function setUserData($results = array())
	{
		$this->userinfo = array(
			'company'	 => isset($results['companyname']) ? $results['companyname'] : '',
			'datebeg'	 => isset($results['regdate']) ? $results['regdate'] : '',
			'datenext'	 => isset($results['nextduedate']) ? $results['nextduedate'] : '',
			'dateend'	 => isset($results['enddate']) ? $results['enddate'] : '',
			'daysleft'	 => isset($results['daysleft']) ? $results['daysleft'] : -1,
			'domain'	 => get_server_host(),
			'email'		 => isset($results['email']) ? $results['email'] : '',
			'error'		 => isset($results['error']) ? $results['error'] : '',
			'name'		 => isset($results['registeredname']) ? $results['registeredname'] : '',
			'product'	 => isset($results['productname']) ? $results['productname'] : ''
		);
	}

	function validUserData()
	{
		if (!is_array($this->userinfo)) {
			$this->setUserData();
		}

		// Validate user data
		if ((isset($this->userinfo['error']) && $this->userinfo['error']) ||
				!isset($this->userinfo['email']) || !$this->userinfo['email'] ||
				!isset($this->userinfo['name']) || !$this->userinfo['name'] ||
				!isset($this->userinfo['product']) || !$this->userinfo['product']) {
			return false;
		}

		return true;
	}

	function updateBenchmarks($benchmark)
	{
		// Pass benchmark object
		if (!gettype($benchmark) === 'object') {
			return false;
		}

		// Check if sample CPU benchmark is defined
		if (!defined('CPU_BENCHMARK') || CPU_BENCHMARK <= 0) {
			// Take a break, relax...
			usleep(84000);

			// Run the one-time benchmark with extended accuracy
			$cpu_benchmark_test = $benchmark->cpuSpeedTest($accuracy = 32, true);
		} else {
			$cpu_benchmark_test = CPU_BENCHMARK;
		}

		// CPU load average (related to scan speed)
		$this->scan['load'] = $benchmark->cpuLoadAverage();
		if ($this->scan['load'] > .3 && $this->scan['load'] < 1) { // dynamic correction
			$cpu_benchmark_test = round($this->scan['load'] * $cpu_benchmark_test);
		}

		// Update system data
		$this->system['cpumark'] = $cpu_benchmark_test;
		$this->system['memory'] = array(
			'limit'	 => max($benchmark->getMemoryLimit(), 1048576),
			'usage'	 => $benchmark->getMemoryUsage()
		);

		// Get scan timing data from the benchmark class
		$this->time['throttled'] = $benchmark->time_cpu_throttled;

		// Store the last timestamp
		$this->time['timestamp'] = time();

		return true;
	}

	function updateProgress($config, $time_taken = 0)
	{
		// Pass configuration options
		if (!gettype($config) === 'object') {
			return false;
		}

		// Average connection delays (10ms in CLI mode)
		$time_correction = CWIS_IS_CLI ? 0.01 : 0.12;

		// Update time taken
		if ($time_taken > 0) {
			$total_time_elapsed = round($time_correction + $this->time['elapsed'] + $time_taken, 3);
		} else {
			// Leave taken time unchanged
			$time_taken = $this->time['taken'];
			$total_time_elapsed = round($time_correction + $this->time['elapsed'], 3);
		}

		// Count total directories and files found and scanned/skipped
		$total_found = ($this->scan['directories']['found'] - $this->scan['directories']['skipped']) +
				($this->scan['files']['found'] - $this->scan['files']['skipped']);
		$total_scanned = $this->scan['directories']['scanned'] + $this->scan['files']['scanned'];

		// Database tables scan
		if ($this->tables['discovered'] > 0) {
			if ($this->tables['size'] >= 0 && $this->tables['processed'] <= $this->tables['discovered']) {
				$this->tables['percent'] = round(100 * $this->tables['processed'] / $this->tables['discovered']);
			} else {
				$this->tables['percent'] = 100;
			}
		} else {
			$this->tables['percent'] = !$this->isDatabaseScanFinished() ? 0 : 100;
		}

		// Prescan percent (consists of dirs prescan and CMS/plugins detectors)
		if ($this->prescan['depth'] < 0) {
			if ($this->prescan['discovered'] > 0) {
				$this->prescan['percent'] = 45 + // first 45 percents of prescan
						round(55 * $this->prescan['processed'] / $this->prescan['discovered']);
			} else {
				$this->prescan['percent'] = 100;
			}
		} else {
			// Caclulate the first 45 percents of prescan, 9 * 5 levels = 45
			$this->prescan['percent'] = $this->prescan['depth'] > 0 ? round(15 * sqrt($this->prescan['depth'])) : 0;
			if ($this->prescan['percent'] > 45) {
				$this->prescan['percent'] = 45;
			}
		}

		// Scan progress percent
		if (/* $this->isPrescanFinished() && */$this->scan['counter'] > 0 && $this->scan['offset'] >= 0) {
			// Calculate progress percent and time left if queue is active (ie positive)
			$this->scan['percent'] = round(100 * $this->scan['offset'] / $this->scan['counter']);
			$total_processed = $this->prescan['processed'] >= $this->prescan['discovered'] ?
					$this->scan['offset'] : $this->prescan['processed'];
			$scan_speed = $total_time_elapsed ?
					round($total_processed / $total_time_elapsed) : 0;
			$time_left = $scan_speed ? round(($total_found - $total_scanned) / $scan_speed, 3) : 0;
		} else {
			// Calculate scan speed (files / sec) and set time to zero
			$this->scan['percent'] = $this->scan['completed'] > 0 ? 100 : 0;
			$scan_speed = $total_time_elapsed ?
					round($total_scanned / $total_time_elapsed) : 0;
			$time_left = 0;
		}

		// Merged scan corrections
		if ($this->scan['merged']) {
			$total_merged = $config->countScanPaths();
			$this->scan['percent'] = round($this->scan['percent'] * $this->scan['merged'] / $total_merged);
		}

		// Current scan speed
		$this->scan['speed'] = $scan_speed;

		// Rescan progress percent
		if ($this->isFileScanFinished() && $this->rescan['counter'] > 0 && $this->rescan['offset'] >= 0) {
			// Calculate progress percent as sum of half of rescan list preparing with a half of rescan progress
			$this->rescan['percent'] = round(50 * $this->rescan['offset'] / $this->rescan['counter']);
			if ($this->rescan['discovered'] > 0) {
				$this->rescan['percent'] += round(50 * $this->rescan['processed'] / $this->rescan['discovered']);
			}

			// Calculate progress percent and time left if queue is active (ie positive)
			$rescan_processed = $this->rescan['offset'] + $this->rescan['processed'];
			$rescan_unprocessed = $this->rescan['counter'] + $this->rescan['discovered'] - $rescan_processed;
			$rescan_speed = $total_time_elapsed > 0 ?
					round($rescan_processed / $total_time_elapsed) : 0;
			$time_left = $rescan_speed ? round($rescan_unprocessed / $rescan_speed, 3) : 0;
		} else {
			// Calculate scan speed (files / sec) and set time to zero
			$this->rescan['percent'] = $this->rescan['completed'] > 0 ? 100 : 0;
			$rescan_speed = $total_time_elapsed > 0 ?
					round($total_scanned / $total_time_elapsed) : 0;
		}

		// Rescan speed
		$this->rescan['speed'] = $rescan_speed;

		// Current scan parameters from config
		$this->scan['extskip'] = $config->ext_skip;
		$this->scan['database'] = $config->scan_database;
		$this->scan['level'] = $config->scan_level;
		$this->scan['license'] = $config->license;
		$this->scan['path'] = $config->getScanPath($relative = true);
		$this->scan['promode'] = $config->license ? 1 : 0;
		$this->scan['timeout'] = $config->scan_timeout;
		$this->scan['type'] = $config->scan_type;

		// Calculate average load on scan finish
		if ($config->scan_type === 1 && $this->isAllFinished()) {
			$this->scan['load'] = $total_time_elapsed ?
					round(sqrt($this->time['throttled'] / $total_time_elapsed), 3) : 0;

			// Store the last time the scan has been finished
			$this->time['timelast'] = time();
		}

		// Scan timings stats
		$this->time['elapsed'] = $total_time_elapsed;
		$this->time['left'] = $time_left;
		$this->time['taken'] = $time_taken;

		// Update current CWIS version
		$this->version = CWIS_VERSION;
		$this->versions['current'] = substr(CWIS_VERSION, 1);

		return true;
	}

	function updateVersions()
	{
		// Version files
		$basename = 'version.json';
		$localname = CWIS_ASSETS_PATH . DIRECTORY_SEPARATOR . $basename;
		$remotename = str_replace(CWIS_SIGNATURE . '/%s', $basename, CWIS_REMOTE_DIR);

		// Store the current version
		$this->versions['current'] = substr(CWIS_VERSION, 1);

		// Update file content every 6 hours
		if (!is_file($localname) || time() - filemtime($localname) > 21600) {
			$options = array(
				'connect_timeout'	 => 3,
				'encoding'			 => 'gzip',
				'user_agent'		 => get_server_env('HTTP_USER_AGENT')
			);

			// Get remote version file
			$content = http_open_url($remotename, $options);
			if (false !== $content && isset($content['body']) && is_object(json_decode($content['body']))) {
				file_put_contents_safe($localname, $content['body']);
			}
		}

		// Get and store the latest version
		$json = json_decode(file_get_contents($localname), true);
		if (isset($json['version'])) {
			$this->versions['latest'] = $json['version'];
			return true;
		}

		return false;
	}

}

class CwisResults
{

	/**
	 * Holds the last error message.
	 * @var string 
	 */
	var $last_error = '';

	/**
	 * All results.
	 * @var array 
	 */
	var $results = array();

	/**
	 * Results by name.
	 * @var array 
	 */
	var $result = null;

	/**
	 * Result's name.
	 * @var string 
	 */
	var $var_name = '';

	/**
	 * Adds a key-value pair to a result entries array.
	 * @param mixed $key
	 * @param mixed $result
	 * @return bool
	 */
	function add($key = null, $result = null)
	{
		// Validate name, results array and array key
		if ($this->isValidName($this->var_name) && $this->isValidKey($key)) {
			// Directly adds a result entry directly
			$this->results[$this->var_name][$key] = $result;
		}

		return $this;
	}

	/**
	 * Gets all results.
	 * @return array
	 */
	function all()
	{
		return $this->results;
	}

	/**
	 * Builds a valid result from an array with entry data (possible array
	 * keys are: 'id', 'name', 'fragment', 'sig', 'stat' and 'crc').
	 * @param array $entry_data
	 * @return $this
	 */
	function buildEntry($entry_data = array())
	{
		$this->result = array();

		// Entry index (or row number of a record)
		if (isset($entry_data['id'])) {
			$this->result['id'] = $entry_data['id'];
		}

		// String entry name
		if (isset($entry_data['name'])) {
			$this->result['name'] = $entry_data['name'];
		}

		// Code fragment (or an array of)
		if (isset($entry_data['fragment'])) {
			$this->result['fragment'] = $entry_data['fragment'];
		}


		// Signature ID (CRC)
		if (isset($entry_data['sig'])) {
			$this->result['sig'] = $entry_data['sig'];
		}

		// Pack entry stat (size, ctime and mtime)
		if (isset($entry_data['stat'])) {
			$entry_stat = $entry_data['stat'];
			if (is_array($entry_stat)) {
				$entry_stat = pack("I3", isset($entry_stat['size']) ? (int) $entry_stat['size'] : 0,
								   isset($entry_stat['ctime']) ? (int) $entry_stat['ctime'] : 0,
				 isset($entry_stat['mtime']) ? (int) $entry_stat['mtime'] : 0);
			}

			$this->result['stat'] = $entry_stat;
		}

		// Pack entry CRC (SHA1 hash)
		if (isset($entry_data['crc'])) {
			$entry_crc = $entry_data['crc'];

			// Pack the 40-character hexadecimal number or save 20 bytes
			$this->result['crc'] = strlen($entry_crc) === 40 && ctype_xdigit($entry_crc) ?
					pack("H*", $entry_crc) : substr($entry_crc, 0, 20);
		}

		return $this;
	}

	/**
	 * Copies a key-value pair to another result entries array.
	 * @param string $var_name_to
	 * @param mixed $key_from
	 * @param mixed $key_to
	 * @return bool
	 */
	function copyTo($var_name_to = '', $key_from = null, $key_to = null)
	{
		// Validate a second results name
		if ($this->isValidName($var_name_to)) {

			// Get a result entry value by key
			$result = $this->find($key_from);
			if (null !== $result) {

				// Save an original var_name and select another one
				$var_name_from = $this->var_name;
				$this->select($var_name_to);

				// Add a new result entry directly
				if (null !== $key_to && $this->isValidKey($key_to)) {
					$this->add($key_to, $result);
				} else {
					$this->push($result);
				}

				// Restore an original var_name
				$this->select($var_name_from);
				return true;
			}
		}

		return false;
	}

	/**
	 * Counts the results selected by var name.
	 * @return array
	 */
	function count()
	{
		return count($this->get());
	}

	/**
	 * Deletes a key-value pair from a result entries array.
	 * @param int|string $key
	 * @return bool
	 */
	function delete($key = null)
	{
		// Validate name, results array and array key
		if ($this->isValidName($this->var_name) && $this->isValidKey($key)) {
			// Directly deletes a result entry directly
			unset($this->results[$this->var_name][$key]);
		}

		return $this;
	}

	/**
	 * Converts string entry index (looks as VAR_NAME[KEY]) to VAR_NAME and KEY or backward.
	 * @param string $entry_index
	 * @param string $var_name
	 * @param string $key
	 * @return bool
	 */
	function convertEntryIndex(&$entry_index, &$var_name, &$key)
	{
		$var_name = (string) $var_name;
		$key = (string) $key;

		// Extract entry index
		if ($entry_index) {
			$bracket_pos = strpos($entry_index, '[');
			if (false !== $bracket_pos) {
				$var_name = substr($entry_index, 0, $bracket_pos);
				$key = substr($entry_index, $bracket_pos + 1, -1);
				return true;
			}
		} else {
			// Build entry index
			$entry_index = $var_name . '[' . $key . ']';
			return true;
		}

		return false;
	}

	/**
	 * Set empty results with report vars.
	 */
	function emptyResults()
	{
		$this->results = array();
		$config = new CwisConfig();
		foreach ($config->report_vars as $report_vars) {
			foreach ($report_vars as $var => $name) {
				if (!$var || !$name) {
					continue;
				}

				// Set the result
				$this->results[$var] = array();
			}
		}
	}

	/**
	 * Returns an array of entries filtered by key ('id', 'name', 'fragment', 'sig', 'stat' or 'crc').
	 * @param string $entry_key
	 * @return type
	 */
	function filterByKey($entry_key = '')
	{
		$entries = array();

		// Filter result entries by key
		foreach ($this->results as $var_name => $array) {
			if (!$entry_key || !is_array($array)) {
				continue;
			}

			// Filter entries by key
			foreach ($array as $key => $entry_data) {
				if (is_array($entry_data) && array_key_exists($entry_key, $entry_data)) {
					$entry_index = ''; // initialize string entry index (looks as VAR_NAME[KEY])
					if ($this->convertEntryIndex($entry_index, $var_name, $key)) {
						$entries[$entry_index] = $entry_data[$entry_key];
					}
				}
			}
		}

		return $entries;
	}

	/**
	 * Gets the result selected by var name and key or NULL on error.
	 * @param int|string $key
	 * @return null|array
	 */
	function find($key = null)
	{
		// Validate name, results array and array key
		if ($this->isValidName($this->var_name) && $this->isValidKey($key) &&
				isset($this->results[$this->var_name][$key])) {
			// Directly returns a result entry
			return $this->results[$this->var_name][$key];
		}

		return null;
	}

	/**
	 * Gets the results selected by var name.
	 * @return array
	 */
	function get()
	{
		// Validate name and result
		if ($this->isValidName($this->var_name)) {
			return $this->results[$this->var_name];
		}

		return array();
	}

	/**
	 * Returns the last error message.
	 * @return string 
	 */
	function getLastError()
	{
		return $this->last_error;
	}

	/**
	 * Checks for duplicate result entries.
	 * @param mixed $result
	 * @return bool
	 */
	function isUnique($result = null)
	{
		if (null === $result) {
			$result = $this->result;
		}

		if (!empty($result)) {
			// Prevent duplicate result entries
			foreach ($this->get() as $result_value) {
				if ($result_value == $result) {
					return false;
				}
			}
		}

		return true;
	}

	/**
	 * Validates results variable name and result.
	 * @param string $var_name
	 * @return bool
	 */
	function isValidName($var_name = '')
	{
		// Process string names only
		if (!is_string($var_name) || !strlen($var_name)) {
			$this->last_error = 'Incorrect result name type "' . gettype($var_name) . '".';
			return false;
		}

		// Process previously defined variables only
		if (!isset($this->results[$var_name])) {
			$this->last_error = 'Undefined results by name "' . $var_name . '".';
			return false;
		}

		// Process result arrays only
		if (!is_array($this->results[$var_name])) {
			$this->last_error = 'Incorrect results by name "' . $var_name . '".';
			return false;
		}

		return true;
	}

	/**
	 * Validates result key type.
	 * @param int|string $key
	 * @return bool
	 */
	function isValidKey($key = null)
	{
		// Validate as an array key
		if (is_integer($key) || is_string($key)) {
			return true;
		}

		$this->last_error = 'Incorrect result key type "' . gettype($key) . '".';
		return false;
	}

	/**
	 * Merges scan results (raw report data)
	 * @param mixed $config
	 * @param array $results
	 * @return array
	 */
	function mergeScanResults($results)
	{
		if (empty($this->results)) {
			$this->emptyResults();
		}

		// Merge scan results by var name (raw report data)
		foreach ($this->results as $var_name => $array) {
			if ($var_name && isset($results[$var_name]) && is_array($results[$var_name])) {
				$this->results[$var_name] = array_merge($this->results[$var_name], $results[$var_name]);
			}
		}

		return $this->results;
	}

	/**
	 * Moves a key-value pair to another result entries array.
	 * @param string $var_name_to
	 * @param mixed $key_from
	 * @param mixed $key_to
	 * @return bool
	 */
	function moveTo($var_name_to = '', $key_from = null, $key_to = null)
	{
		// Validate a second results name
		if ($this->copyTo($var_name_to, $key_from, $key_to)) {

			// Delete a result entry by key
			$this->delete($key_from);
			return true;
		}

		return false;
	}

	/**
	 * Removes duplicate result entries.
	 * @param string $var_name
	 * @param bool $strict
	 * @return $this
	 */
	function unique($var_name = '', $strict = false)
	{
		// Validate results name
		if ($this->isValidName($var_name)) {
			if ($strict) {
				// Strict object serializing
				$results = array_map("serialize", $this->results[$var_name]);
			} else {
				// Optimized method
				$results = array();
				foreach ($this->results[$var_name] as $key => $value) {

					// Array format support
					if (is_array($value)) {
						$file_name = isset($value['name']) ? $value['name'] : 'N';
						$file_fragment = isset($value['fragment']) ? serialize($value['fragment']) : 'F';
					} else {
						$file_name = 'N';
						$file_fragment = 'F';
					}

					// Add a compact result
					$results[$key] = '_' . $file_name . $file_fragment;
				}
			}

			// Get keys difference (duplicates)
			$key_duplicates = array_diff(array_keys($results), array_flip($results));
			foreach ($key_duplicates as $key) {
				unset($this->results[$var_name][$key]);
			}
		}

		return $this;
	}

	/**
	 * Optimizes results array values.
	 * @param string $var_name
	 */
	function optimize($var_name = '')
	{
		// Validate results name
		if ($this->isValidName($var_name)) {
			$this->results[$var_name] = array_values($this->results[$var_name]);
		}

		return $this;
	}

	/**
	 * Pushs the result.
	 * @param mixed $result
	 * @return $this
	 */
	function push($result = null)
	{
		// Validate and prevent duplicate result entries
		if ($this->isValidName($this->var_name) && $this->isUnique($result)) {

			// Push result
			array_push($this->results[$this->var_name], (null !== $result ? $result : $this->result));
		}

		return $this;
	}

	/**
	 * Resets the last error message.
	 * @return $this 
	 */
	function resetLastError()
	{
		$this->last_error = '';

		return $this;
	}

	/**
	 * Selects current results var name, optionally resets result entries.
	 * @param string $var_name
	 * @param bool $reset
	 * @return bool
	 */
	function select($var_name = '', $reset = false)
	{
		$this->var_name = (string) $var_name;

		// Reset result entries (optionally)
		if ($reset && $this->var_name) {
			$this->results[$this->var_name] = array();
		}

		return $this;
	}

	/**
	 * Sets the results selected by var name.
	 * @param array $results
	 * @return $this
	 */
	function set($results = array())
	{
		// Validate name and set result
		if (true === $this->isValidName($this->var_name)) {
			$this->results[$this->var_name] = $results;
		}

		return $this;
	}

	/**
	 * Sets the results.
	 * @param array $results
	 * @return $this
	 */
	function setResults(& $results)
	{
		// Set result
		if (is_array($results)) {
			$this->results = & $results;
		} elseif (isset($results->results)) {
			$this->results = & $results->results;
		} else {
			header('HTTP/1.0 500 Internal Server Error');
			die('Cannot set the results!');
		}

		return $this;
	}

	/**
	 * Removes blank, empty or commented lines from results.
	 * @return $this
	 */
	function stripComments()
	{
		$ml_comment = false;
		foreach ($this->get() as $key => $result_value) {
			$result = trim($result_value);

			// Blank or empty line
			if (!$result) {
				$this->delete($key);
				continue;
			}

			// Analyse first character
			$first_char = $result[0];

			// PHP multi line comment's opening tag
			if (!$ml_comment && $first_char === '/' && preg_match("#^/\*#", $result)) {
				$ml_comment = true;
			}

			// PHP multi line comment's closing tag
			if ($ml_comment && preg_match("#\*/$#", $result)) {
				$ml_comment = false;
				$this->delete($key);
				continue;
			}

			// Remove multi-line or single line comment
			if ($ml_comment || $first_char === '#' || $first_char === ';') {
				$this->delete($key);
			}
		}

		return $this;
	}

	/**
	 * Prepends the result.
	 * @param mixed $result
	 * @return $this
	 */
	function unshift($result = null)
	{
		// Validate and prevent duplicate result entries
		if ($this->isValidName($this->var_name) && $this->isUnique($result)) {

			// Prepend result
			array_unshift($this->results[$this->var_name], (null !== $result ? $result : $this->result));
		}

		return $this;
	}

}

class CwisTimer
{

	var $start;

	function get($decimals = 3)
	{
		return round((microtime_float() - $this->start), $decimals);
	}

	function isTimeUp($time = 0, $decimals = 3)
	{
		return (bool) ($this->get($decimals) >= $time);
	}

	function start()
	{
		$this->start = microtime_float();
	}

}

class CwisTranslations
{

	/**
	 * Known languages and they plural rules in CLDR format
	 * http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
	 */
	var $langs = array(
		'en' => array(
			'name'	 => 'English',
			'rules'	 => array(
				'one'	 => '$n == 1', // 1
				'other'	 => 'everything else' // 0, 2-999; 1.2, 2.07...
			)
		),
		'ru' => array(
			'name'	 => 'Russian',
			'rules'	 => array(
				'one'	 => '$n % 10 == 1 && $n % 100 != 11', // 1, 21, 31, 41, 51, 61...
				'few'	 => '($n % 10 >= 2 && $n % 10 <= 4) && ($n % 100 < 12 && $n % 100 > 14)', // 2-4, 22-24, 32-34...
				'many'	 => '$n % 10 == 0 || ($n % 10 >= 5 && $n % 10 <= 9) || ($n % 100 >= 11 && $n % 100 <= 14)', // 0, 5-20, 25-30, 35-40...
				'other'	 => 'everything else', // 1.2, 2.07, 5.94...
			)
		)
	);
	//
	// Constants prefix
	var $prefix = '_CWIS_';

	/**
	 * Validates language selected by user.
	 * @param string $lang
	 * @return string
	 */
	function validateLang($lang = 'en')
	{
		if (strlen($lang) >= 2 && isset($this->langs[$lang])) {
			return $lang;
		}

		return 'en';
	}

	// --- PUBLIC METHODS ---

	/**
	 * Defines translation strings as constants.
	 * @param string $lang
	 */
	function defineConstants($lang = 'en')
	{
		$translations = $this->read($lang);
		if ($translations && is_array($translations)) {
			foreach ($translations as $key => $value) {
				$constant = $this->prefix . $key;
				if (!defined($constant)) {
					define($constant, $value);
				}
			}

			unset($translations);
		}
	}

	/**
	 * Replaces defined translation constant names with they values.
	 * @param string $string
	 */
	function replaceConstants($string = '')
	{
		$matches = array();
		if (preg_match_all('/' . $this->prefix . '\w+/', $string, $matches)) {
			foreach ($matches[0] as $match) {
				if (defined($match)) {
					$string = str_replace($match, constant($match), $string);
				}
			}
		}

		// Remove control characters from string
		return preg_replace('/[\x00-\x1F\x7F]+(?:\s+)/', ' ', $string);
	}

	/**
	 * Pluralizes using CLDR rules and sprintf (plural categories taken from expression).
	 * @param string $expression
	 * @param integer|float $n
	 * @param string $lang
	 * @return string
	 */
	function pluralize($expression = '', $n = 0, $lang = _CWIS_LANGUAGE_CODE)
	{
		$plural_forms = explode('|', $expression);

		// Handle language plural rules
		if (!empty($this->langs[$lang]['rules'])) {
			$i = 0;
			foreach ($this->langs[$lang]['rules'] as $rule) {
				if (false !== strpos($rule, 'everything') ||
						false !== strpos($rule, 'else') ||
						true === eval('return (' . $rule . ');')) {
					return sprintf($plural_forms[$i], $n);
				}

				$i++;
			}
		}

		// Return the first plural form
		return sprintf($plural_forms[0], $n);
	}

	/**
	 * Reads translations from a "cwis-lang" file.
	 * @param string $lang
	 * @return array
	 */
	function read($lang = null)
	{
		$language = $this->validateLang($lang);
		if ($language !== 'en') {
			$i18n_translations = require_file('cwis-lang-' . $language . '.php');
			$eng_translations = require_file('cwis-lang-en.php');

			// Append english translations using the + array union operator
			$translations = $i18n_translations + $eng_translations;
		} else {
			$translations = require_file('cwis-lang-en.php');
		}

		// One time loaded translations
		if (!$translations || !is_array($translations)) {
			//print_r($translations);
			header('HTTP/1.0 500 Internal Server Error');
			die('Cannot read from translations file.');
		}

		// Define current language code
		$translations['LANGUAGE_CODE'] = $lang;

		return $translations;
	}

}

class CwisUtilities
{

	var $scan_path = '';

	/**
	 * Creates results directory.
	 */
	function createResultsDirectory()
	{
		$dirsCreator = new CwisDirsCreator();
		if (!$dirsCreator->createResultsDir()) {
			header('HTTP/1.0 500 Internal Server Error');
			die($dirsCreator->getLastError());
		}
	}

	/**
	 * Builds absolute path to files, used for logs with DEBUG and SCANLOG,
	 * and for scan results with PRESCAN, PROGRESS, QUEUE, RESCAN, SHARED.
	 * @param string $basename
	 * @param string $extension
	 * @return string
	 */
	function defineFilePath($basename = '', $extension = '.dat')
	{
		// Create results directories
		$dirsCreator = new CwisDirsCreator();
		$dirsCreator->setFilePathHash($this->scan_path);

		// Create scan results subdirectory (using path's MD5 hash)
		if (!$dirsCreator->createResultsSubdir()) {
			header('HTTP/1.0 500 Internal Server Error');
			die($dirsCreator->getLastError());
		}

		// Return absolute path to the file
		return $path_to_file = $dirsCreator->getResultsFilePath($basename, $extension);
	}

	/**
	 * Checks if filename is PDO record.
	 * @param string $file_name
	 * @return string
	 */
	function filenameIsPdoRecord($file_name = '')
	{
		return is_string($file_name) && substr($file_name, 0, 4) === 'PDO ';
	}

	/**
	 * Expands (inflates) filename or array of filenames.
	 * @param string|array $filename
	 * @param string $replacement
	 * @return string
	 */
	function filenameExpand($filename = '', $replacement = '>')
	{
		if (($base_path = CWIS_SCAN_PATH ? CWIS_SCAN_PATH : CWIS_ROOT_PATH)) {
			return str_replace($replacement, $base_path, $filename);
		}

		return $filename;
	}

	/**
	 * String sanitizer for the filename (basename + extension).
	 * @param string $filename
	 * @return type
	 */
	function filenameSanitize($filename = '')
	{
		return preg_replace("#[^\pL\w_,;~\.\-\=\'\!\@\#\$\%\^\&\(\)\[\]\{\}]+#su", '', $filename);
	}

	/**
	 * Expands (inflates) filename and returns SHA1 hash of a file.
	 * @param string $file_name_packed
	 * @param string $replacement
	 * @return string
	 */
	function filenameSha1($file_name_packed = '', $replacement = '>')
	{
		// sha1_file (PHP 4 >= 4.3.0)
		if (PHP_VERSION_ID >= 40300) {
			$filename = $this->filenameExpand($file_name_packed, $replacement);
			if (is_file($filename) && is_readable($filename) &&
					(MAX_SIZE_TO_SCAN <= 0 || filesize($filename) <= MAX_SIZE_TO_SCAN)) {
				return @sha1_file($filename);
			}
		}

		return null;
	}

	/**
	 * Shortens filename for display in UI.
	 * @param string $filename
	 * @param int $limit
	 * @return string
	 */
	function filenameShorten($filename = '', $limit = 50, $ellipsis = '...')
	{
		// Limit path length
		$filename_shorten = strlen($filename) > $limit ?
				substr($filename, 0, $limit >> 1) . $ellipsis . substr($filename, 3 - $limit >> 1) : $filename;

		// Sanitize characters using utf8_sanitize
		return utf8_sanitize($filename_shorten);
	}

	/**
	 * Shrinks (deflates) filename or array of filenames.
	 * @param string|array $filename
	 * @param string $replacement
	 * @return string
	 */
	function filenameShrink($filename = '', $replacement = '>')
	{
		if (($base_path = CWIS_SCAN_PATH ? CWIS_SCAN_PATH : CWIS_ROOT_PATH)) {
			return str_replace($base_path, $replacement, $filename);
		}

		return $filename;
	}

	/**
	 * Sets scan path.
	 * @param string $scan_path
	 * @return string
	 */
	function setScanPath($scan_path = '')
	{
		$this->scan_path = $scan_path;
	}

	// ---

	/**
	 * Returns realpath only for relative paths (realpath returns FALSE on error).
	 * @param string $scan_path
	 * @return bool|string
	 */
	function getRealScanPath($scan_path = '')
	{
		if (!strlen($scan_path) || $scan_path === '.' || $scan_path === '..') {
			return false;
		} else //ignore an absolute path and resolve relative
		if ($scan_path[0] !== '/' && $scan_path[1] !== ':') {
			$scan_path = realpath(CWIS_SCAN_PATH . DIRECTORY_SEPARATOR . $scan_path);
			if (false === $scan_path && false === ($scan_path = realpath($scan_path))) {
				return false;
			}
		}

		return $scan_path;
	}

	/**
	 * Gets an array of unique non-empty scan paths (eg start points).
	 * @return array
	 */
	function splitScanPath($scan_path = '')
	{
		// Split scan path and trim values
		$scan_paths = array_map('trim', explode(',', $scan_path));

		// Remove invalid and empty paths
		foreach ($scan_paths as $i => $scan_path) {
			if (false === $this->getRealScanPath($scan_path)) {
				unset($scan_paths[$i]);
			}
		}

		// Empty arrays support
		return !empty($scan_paths) ?
				array_keys(array_flip($scan_paths)) : array();
	}

	/**
	 * Reads database settings from a file or system defaults and returns as an array.
	 * @param string $base_dir  Base directory to start from
	 * @param string $settings  Predefined database settings
	 * @return array
	 */
	function getDatabaseSettingsFromFile($base_dir = '', $settings = array())
	{
		// Override with settings from the root file
		if (defined('CWIS_DB_TYPE')) {
			$settings['type'] = CWIS_DB_TYPE;
		}
		if (defined('CWIS_DB_HOST')) {
			$settings['host'] = CWIS_DB_HOST;
		}
		if (defined('CWIS_DB_USER')) {
			$settings['user'] = CWIS_DB_USER;
		}
		if (defined('CWIS_DB_PASS')) {
			$settings['pass'] = CWIS_DB_PASS;
		}
		if (defined('CWIS_DB_NAME')) {
			$settings['name'] = CWIS_DB_NAME;
		}

		// Is auto parsing enabled?
		if ($settings['type'] !== 'auto') {
			return $settings;
		}

		// Known systems
		$systems = array(
			'Wordpress'	 => array(
				'file'	 => $base_dir . DIRECTORY_SEPARATOR . 'wp-config.php',
				'match'	 => array(
					'~define\s*\(\s*["\'](\w+)["\'],\s*["\'](.*?)["\']\s*\)~si',
					'~\$(\w+)\s*=\s*["\'](.*?)["\']~si'
				),
			),
			'Joomla!'	 => array(
				'file'	 => $base_dir . DIRECTORY_SEPARATOR . 'configuration.php',
				'match'	 => '~(?:public|var)\s*\$(\w+)\s*=\s*["\'](.*?)["\']~si',
			),
			'Magento1'	 => array(
				'file'	 => $base_dir . DIRECTORY_SEPARATOR . 'app' . DIRECTORY_SEPARATOR . 'etc' . DIRECTORY_SEPARATOR . 'local.xml',
				'match'	 => '~<(\w+)><!\[CDATA\[(.*?)\]\]><\/\1>~si',
			),
			'Magento'	 => array(
				'file'	 => $base_dir . DIRECTORY_SEPARATOR . 'app' . DIRECTORY_SEPARATOR . 'etc' . DIRECTORY_SEPARATOR . 'env.php',
				'match'	 => '~["\'](\w+)["\']\s*=>\s*["\'](.*?)["\']~si',
			),
			'MODX'		 => array(
				'file'	 => $base_dir . DIRECTORY_SEPARATOR . 'core' . DIRECTORY_SEPARATOR . 'config' . DIRECTORY_SEPARATOR . 'config.inc.php',
				'match'	 => array(
					'~\$(\w+)\s*=\s*["\'](.*?)["\']~si'
				),
			),
		);

		// Get database settings
		foreach ($systems as $system) {
			$filename = $system['file'];
			$regexps = $system['match'];
			if (!is_array($regexps)) {
				$regexps = array($regexps);
			}

			// Check setting filename
			if (!is_file($filename)) {
				continue;
			}

			$matches = array();
			$content = file_get_array($filename);

			// Loop through the file contents
			foreach ($content as $line) {
				foreach ($regexps as $regexp) {
					if (!preg_match($regexp, $line, $matches)) {
						continue;
					}

					// Parse values
					$name = strtoupper($matches[1]);
					$value = $matches[2];
					switch ($name) {
						case 'DATABASE_TYPE': // MODX
						case 'DBTYPE': // Joomla!
							$settings['type'] = $value;
							break;

						case 'DATABASE_SERVER': // MODX
						case 'DB_HOST': // WP
						case 'HOST': // Joomla!
							$settings['host'] = $value;
							break;

						case 'DATABASE_USER': // MODX
						case 'DB_USER': // WP
						case 'USER': // Joomla!
							$settings['user'] = $value;
							break;

						case 'DATABASE_PASSWORD': // MODX
						case 'DB_PASSWORD': // WP
						case 'PASSWORD': // Joomla!
							$settings['pass'] = $value;
							break;

						case 'DATABASE_NAME': // MODX
						case 'DB_NAME': // WP
						case 'DB': // Joomla!
							$settings['name'] = $value;
							break;

						case 'TABLE_PREFIX': // WP
						case 'DBPREFIX': // Joomla!
							$settings['prefix'] = $value;
							break;
					}
				}
			}
		}

		return $settings;
	}

	/**
	 * Formats bytes to human readable.
	 * @param integer $bytes
	 * @param integer $decimals
	 * @return string
	 */
	function formatBytes($bytes, $decimals = 0)
	{
		$units = array(
			'Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'
		);

		foreach ($units as $i => $unit) {
			if (abs($bytes) < 1024) {
				return ($i ? number_format($bytes, $decimals) : $bytes) . ' ' . $unit;
			}

			$bytes /= 1024;
		}
	}

	/**
	 * Formats a local time/date.
	 * @param integer $timestamp
	 * @param string $format
	 * @return string
	 */
	function formatDates($timestamp, $format = 'Y-m-d H:i')
	{
		return date($format, $timestamp);
	}

	/**
	 * Formats time to human readable "h:mm:ss".
	 * @param integer $time
	 * @param integer $decimals
	 * @return string
	 */
	function formatSeconds($time, $decimals = 0)
	{
		$hours = floor($time / 3600);
		$time -= $hours * 3600;

		$minutes = floor($time / 60);
		$time -= $minutes * 60;

		if ($decimals > 0 && $decimals <= 20) {
			$seconds = number_format($time, intval($decimals, 10));
		} else {
			$seconds = intval($time % 60, 10);
		}

		return $hours
				. ':' . ($minutes < 10 ? '0' . $minutes : $minutes)
				. ':' . ($seconds < 10 ? '0' . $seconds : $seconds);
	}

	/**
	 * Extracts email addresses from the string.    
	 * @param string $string
	 * @return array of strings with emails or false on error
	 */
	function getEmails($string = '')
	{
		$matches = array();

		// Regex used in HTML5's type=email from W3C, source: http://emailregex.com/
		if (preg_match_all("/[a-z0-9.!#$%&*+\/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9-]+)*/i", $string, $matches)) {
			return array_keys(array_flip($matches[0]));
		}

		return false;
	}

	/**
	 * 
	 * @param string $base_dir
	 * @param int $max_depth
	 * @param int $depth
	 * @return array
	 */
	function recursiveDirectoryScan($base_dir = '', $max_depth = 255, $depth = 0)
	{
		$directories = array();

		if ($base_dir && is_dir($base_dir) && is_readable($base_dir) && ($handle = opendir($base_dir))) {
			$directories[] = $base_dir;

			while (false !== ($entry = readdir($handle))) {
				// Strip out "." and ".."
				if ($entry == '.' || $entry == '..') {
					continue;
				}

				$filename = $base_dir . DIRECTORY_SEPARATOR . $entry;
				if (is_dir($filename) && $depth < $max_depth) {
					$directories = array_merge($directories, $this->recursiveDirectoryScan($filename, $max_depth, $depth + 1));
				}
			}
			closedir($handle);
			unset($handle);
		}

		// Optimize using faster analog of array_unique
		return array_keys(array_flip($directories));
	}

	function unwrapObfuscated($file_contents = '')
	{
		if (!function_exists('escapedHexToHex')) {

			function escapedHexToHex($escaped)
			{
				return chr(hexdec($escaped[1]));
			}

		}

		if (!function_exists('escapedOctDec')) {

			function escapedOctDec($escaped)
			{
				return chr(octdec($escaped[1]));
			}

		}

		if (!function_exists('quotWrapperFunc')) {

			function quotWrapperFunc($matches)
			{
				return "'" . chr(intval($matches[1], 0)) . "'";
			}

		}

		$search = array(' ;', ' =', ' ,', ' .', ' (', ' )', ' {', ' }', '; ', '= ',
			', ', '. ', '( ', '( ', '{ ', '} ', ' !', ' >', ' <', ' _', '_ ', '< ', '> ',
			' $', ' %', '% ', '# ', ' #', '^ ', ' ^', ' &', '& ', ' ?', '? ');
		$replace = array(';', '=', ',', '.', '(', ')', '{', '}', ';', '=', ',', '.',
			'(', ')', '{', '}', '!', '>', '<', '_', '_', '<', '>', '$', '%', '%',
			'#', '#', '^', '^', '&', '&', '?', '?');

		$file_contents = str_replace('@', '', $file_contents);
		$file_contents = preg_replace('/\s+/', ' ', $file_contents);
		$file_contents = str_replace($search, $replace, $file_contents);

		$file_contents = preg_replace_callback('#\bchr\(\s*([0-9a-fA-FxX]+)\s*\)#', 'quotWrapperFunc', $file_contents);
		$file_contents = preg_replace_callback('#\\\\x([a-fA-F0-9]{1,2})#i', 'escapedHexToHex', $file_contents);
		$file_contents = preg_replace_callback('#\\\\([0-9]{1,3})#i', 'escapedOctDec', $file_contents);

		// Replace string concatenations ('x' . 'y' = 'xy' in PHP and 'x' + 'y' = 'xy' in JS)
		$file_contents = preg_replace('#(\'\s*[.+]+\s*\'|\"\s*[.+]+\s*\")#', '', $file_contents);

		return $file_contents;
	}

}

///////////////////////////////////////////////////////////////////////

/**
 * Prints message to the console.
 * @param mixed $text
 * @param bool $line_break Add line break
 * @return void
 */
function cwis_stdout_message($text = '', $line_break = true)
{
	if (!(CWIS_IS_CLI && !CWIS_IS_CGI)) {
		return null;
	}

	// Convert to printable
	if (is_bool($text)) {
		$text = $text ? 'true' : 'false';
	} elseif (is_null($text)) {
		$text = 'null';
	} else // non-scalar to string
	if (!is_scalar($text)) {
		$text = print_r($text, true);
	}

	@fwrite(STDOUT, $text . ($line_break ? "\n" : ''));
}

// This is our shutdown function, in 
// here we can do any last operations
// before the script is complete.
function cwis_shutdown_function()
{
	$error = error_get_last();
	if (null !== $error) {

		// Parse error has occured
		if ($error['type'] === E_PARSE) {

			// Pass absolute path to ignore file
			$ignore_filepath = CWIS_RESULTS_PATH . DIRECTORY_SEPARATOR . 'CWIS-IGNORE.dat';
			file_put_contents_safe($ignore_filepath, $error['file'] . "\t" . $error['message'] . "\n", FILE_APPEND | LOCK_EX);

			// Force server error
			if (!headers_sent()) {
				header('HTTP/1.0 500 Internal Server Error');
			}
		}

		// Force HTTP status to 500
		if ($error['type'] === E_ERROR && !headers_sent()) {
			header('HTTP/1.0 500 Internal Server Error');

			// Print custom error message
			if (!error_reporting()) {
				echo '<br />' . PHP_EOL . '<b>Error type' . $error['type'] . '</b>: ' . $error['message']
				. ' in <b>' . $error['file'] . '</b> on line <b>' . $error['line'] . '</b><br />';
			}
		}
	}
}

register_shutdown_function('cwis_shutdown_function');
