<?php

// ezscan7objrldgpfvmqkdthyuwi4x2x5
if (!defined('CWIS_SIGNATURE')) {
	header('HTTP/1.0 403 Forbidden');
	die('-1');
}

/**
 * Minimal PHP version supported is: 
 *  PHP 4 >= 4.1.0 (10-Dec-2001)
 *  
 * Limited by functions:
 *  array_filter (PHP 4 >= 4.0.6)
 *  disk_free_space (PHP 4 >= 4.1.0)
 *  get_defined_vars (PHP 4 >= 4.0.4)
 *  user_error (PHP 4 >= 4.0.1)
 *  version_compare (PHP 4 >= 4.1.0)
 */
if (!defined('PHP_VERSION_ID')) {
	$version = array_pad(explode('.', PHP_VERSION), 3, 0);

	// PHP_VERSION_ID is available as of PHP 5.2.7, emulate it
	define('PHP_VERSION_ID', ($version[0] * 10000 + $version[1] * 100 + $version[2]));
}

// Check for minimal PHP version
if (PHP_VERSION_ID < 40100) {
	header('HTTP/1.0 500 Internal Server Error');
	die("Your host needs to use PHP 4.1.0 or higher to run this application!");
}

// Randomize in PHP 4 < 4.2.0
if (PHP_VERSION_ID < 40200) {
	srand(time());
}

// Prevent "undefined constant" notice on pre-5.3.0
if (!defined('ENT_IGNORE')) {
	define('ENT_IGNORE', 4);
}

// We want the char removal behavior on pre-5.4.0
if (!defined('ENT_SUBSTITUTE')) {
	define('ENT_SUBSTITUTE', ENT_IGNORE);
}

if (function_exists('date_default_timezone_set')) {
	// PHP 5.4+ error warning fix
	date_default_timezone_set('UTC');
}

if (!function_exists('ctype_xdigit')) {

	// Check if hexadecimal digits
	function ctype_xdigit($text)
	{
		return preg_match("#^[0-9a-f]+$#i", $text);
	}

}

if (!function_exists('detect_utf_encoding')) {
	// Unicode BOM is U+FEFF, but after encoded, it will look like this:
	define('UTF32_BIG_ENDIAN_BOM', "\x00\x00\xfe\xff");
	define('UTF32_LITTLE_ENDIAN_BOM', "\xff\xfe\x00\x00");
	define('UTF16_BIG_ENDIAN_BOM', "\xfe\xff");
	define('UTF16_LITTLE_ENDIAN_BOM', "\xff\xfe");
	define('UTF8_BOM', "\xef\xbb\xbf");

	// A simple way to detect UTF-8/16/32 of file by its BOM (not work with string or file without BOM)
	// http://php.net/manual/ru/function.mb-detect-encoding.php#91051
	function detect_utf_encoding($str)
	{
		$first3 = substr($str, 0, 3);
		if ($first3 == UTF8_BOM) {
			return 'UTF-8';
		}

		$first4 = substr($str, 0, 4);
		if ($first4 == UTF32_BIG_ENDIAN_BOM) {
			return 'UTF-32BE';
		} elseif ($first4 == UTF32_LITTLE_ENDIAN_BOM) {
			return 'UTF-32LE';
		}

		$first2 = substr($str, 0, 2);
		if ($first2 == UTF16_BIG_ENDIAN_BOM) {
			return 'UTF-16BE';
		} elseif ($first2 == UTF16_LITTLE_ENDIAN_BOM) {
			return 'UTF-16LE';
		}

		return null;
	}

}

if (!function_exists('error_get_last')) {

	set_error_handler(
			create_function(
					'$errno,$errstr,$errfile,$errline,$errcontext',
	 '
                global $__error_get_last_retval__;
                $__error_get_last_retval__ = array(
                    \'type\'        => $errno,
                    \'message\'     => $errstr,
                    \'file\'        => $errfile,
                    \'line\'        => $errline
                );
                return false;
            ')
	);

	function error_get_last()
	{
		global $__error_get_last_retval__;
		if (!isset($__error_get_last_retval__)) {
			return null;
		}
		return $__error_get_last_retval__;
	}

}

if (!function_exists('is_empty')) {

	// String “0” is not treated as empty
	function is_empty($var)
	{
		return !isset($var) || (empty($var) && $var !== '0');
	}

}

if (!function_exists('parse_request_vars')) {

	function parse_request_vars($method)
	{
		$parsed = array();
		$request_method = strtoupper($method);
		if (strtoupper(get_server_env('REQUEST_METHOD')) === $request_method) {
			parse_str($_SERVER[$request_method], $parsed);
		}

		return $parsed;
	}

}

// Used sanitize filters
defined('FILTER_SANITIZE_SPECIAL_CHARS') OR define('FILTER_SANITIZE_SPECIAL_CHARS', 515);

if (!function_exists('filter_input_get')) {

	function filter_input_get($variable_name = '', $default = null, $filter = FILTER_SANITIZE_SPECIAL_CHARS)
	{
		if (CWIS_IS_CGI) {
			$_GET = parse_request_vars('GET');
		}

		if (!CWIS_IS_CGI && PHP_VERSION_ID >= 50200) {
			$result = filter_input(INPUT_GET, $variable_name, $filter);
		} else {
			$result = isset($_GET[$variable_name]) ? $_GET[$variable_name] : $default;
			if ($filter) { // sanitize special characters
				$result = htmlspecialchars($result);
			}
		}

		return is_empty($result) ? $default : $result;
	}

}

if (!function_exists('filter_input_post')) {

	function filter_input_post($variable_name = '', $default = null, $filter = FILTER_SANITIZE_SPECIAL_CHARS)
	{
		if (CWIS_IS_CGI) {
			$_POST = parse_request_vars('POST');
		}

		if (!CWIS_IS_CGI && PHP_VERSION_ID >= 50200) {
			$result = filter_input(INPUT_POST, $variable_name, $filter);
		} else {
			$result = isset($_POST[$variable_name]) ? $_POST[$variable_name] : $default;
			if ($filter) { // sanitize special characters
				$result = htmlspecialchars($result);
			}
		}

		return is_empty($result) ? $default : $result;
	}

}

if (!function_exists('file_get_array')) {

	function file_get_array($filename)
	{
		if (is_file($filename) && ($lines = file($filename))) {
			return array_filter(array_map('trim', $lines), 'strlen');
		} else {
			return array();
		}
	}

}

if (!function_exists('file_get_contents')) {

	function file_get_contents($filename)
	{
		$fp = fopen($filename, "rb");
		if ($fp === false) {
			return FALSE;
		} else {
			$contents = fread($fp, filesize($filename));
			fclose($fp);

			return $contents;
		}
	}

}

if (!function_exists('file_get_contents_safe')) {

	// Thread-safe atomic file reading solution
	function file_get_contents_safe($filename)
	{
		$mode = 'rb';
		for ($attempts = 0; $attempts < 250; $attempts++) {
			$fp = @fopen($filename, $mode);
			if (false !== $fp) {
				break;
			}

			// Wait for 4ms
			usleep(4000);
		}

		if (false === $fp) {
			return FALSE;
		}

		// Lock the file
		$locked = flock($fp, LOCK_SH);

		// Read the data
		if (($filesize = filesize($filename))) {
			$contents = fread($fp, $filesize);

			// Checks if the content has BOM
			if (substr($contents, 0, 3) === UTF8_BOM) {
				$contents = substr($contents, 3);
			}
		} else {
			$contents = '';
		}

		// Release the lock
		if ($locked) {
			flock($fp, LOCK_UN);
		}

		fclose($fp);
		return $contents;
	}

}

if (!function_exists('file_put_contents')) {
	defined('FILE_APPEND') OR define('FILE_APPEND', 8);
	defined('LOCK_SH') OR define('LOCK_SH', 1);
	defined('LOCK_EX') OR define('LOCK_EX', 2);
	defined('LOCK_NB') OR define('LOCK_NB', 4);
	defined('LOCK_UN') OR define('LOCK_UN', 3);

	function file_put_contents($filename, $data, $flag = false)
	{
		$mode = ($flag & FILE_APPEND) ? 'ab+' : 'wb+';
		$fp = fopen($filename, $mode);

		if (false === $fp) {
			return FALSE;
		}

		// Lock the file
		$operation = $flag & (LOCK_EX | LOCK_SH);
		$locked = $operation ? flock($fp, $operation) : false;

		// Write the data
		if (is_array($data)) {
			$data = implode($data);
		}
		$bytes_written = fwrite($fp, $data);

		// Release the lock
		if ($locked) {
			flock($fp, LOCK_UN);
		}

		fclose($fp);
		return $bytes_written;
	}

}

if (!function_exists('file_put_contents_safe')) {

	// Thread-safe atomic file writing solution
	function file_put_contents_safe($filename, $data, $flag = LOCK_EX, $temp_ext = '.tmp')
	{
		if ($flag & FILE_APPEND) {
			for ($attempts = 0; $attempts < 250; $attempts++) {
				// Write (append) content to the file
				$bytes_written = file_put_contents($filename, $data, $flag);
				if (false !== $bytes_written) {
					break;
				} elseif (function_exists('disk_free_space') && disk_free_space() < strlen($data)) {
					header('HTTP/1.0 500 Internal Server Error');
					die('Possibly out of free disk space.');
				}

				// Wait for 4ms
				usleep(4000);
			}

			return $bytes_written;
		} else {
			for ($attempts = 0; $attempts < 100; $attempts++) {
				// Write content to the temporal file (with a temp_ext extension added)
				$bytes_written = @file_put_contents($filename . $temp_ext, $data, $flag);
				if (false !== $bytes_written) {
					break;
				}

				// Wait for 4ms
				usleep(4000);
			}

			if (false === $bytes_written) {
				return false;
			}

			// Rename the file with a temporal extension
			if (@rename($filename . $temp_ext, $filename)) {
				return $bytes_written;
			}

			// There are issues on Windows systems when the target file already exists
			if (@copy($filename . $temp_ext, $filename)) {
				@unlink($filename . $temp_ext);
				return $bytes_written;
			}
		}

		return false;
	}

}

if (!function_exists('functions_exists')) {

	function functions_exists()
	{
		$function_names = func_get_args();

		foreach ($function_names as $function_name) {
			if (!is_string($function_name)) {
				continue;
			}

			// Check if function is defined and callable
			if (!function_exists($function_name) || !is_callable($function_name)) {
				return false;
			}
		}

		return true;
	}

}

if (!function_exists('shorthand_to_bytes')) {

	// Get bytes from shorthand byte values (1M, 1G...)
	function shorthand_to_bytes($value = '0K')
	{
		$val = trim($value);
		if (($strlen = strlen($val)) > 0) {
			$last = strtoupper($val[$strlen - 1]);
			$val = intval($val);
			switch ($last) {
				case 'T':
					$val *= 1024;
				case 'G':
					$val *= 1024;
				case 'M':
					$val *= 1024;
				case 'K':
					$val *= 1024;
			}
		}

		return $val;
	}

}

if (!function_exists('get_client_ip')) {

	function get_client_ip()
	{
		$possibleIpSources = array(
			'HTTP_CLIENT_IP',
			'HTTP_X_FORWARDED_FOR',
			'HTTP_X_FORWARDED',
			'HTTP_X_CLUSTER_CLIENT_IP',
			'HTTP_FORWARDED_FOR',
			'HTTP_FORWARDED',
			'REMOTE_ADDR'
		);

		$ip_address = '';
		foreach ($possibleIpSources as $source) {
			if (empty($_SERVER[$source])) {
				continue;
			}

			// Treat as a list of IPs
			$elements = explode(',', $_SERVER[$source]);
			$ip_address = trim(end($elements));

			if (!empty($ip_address)) {
				break;
			}
		}

		return $ip_address;
	}

}

if (!function_exists('get_server_ip')) {

	function get_server_ip()
	{
		$local_addr = get_server_env('LOCAL_ADDR');
		$ip_address = $local_addr ? $local_addr : get_server_env('SERVER_ADDR');
		if (!$ip_address) {
			$ip_address = gethostbyname(
					functions_exists('gethostname') ? gethostname() : php_uname('n')
			);
		}

		return $ip_address;
	}

}

if (!function_exists('get_server_host')) {

	function get_server_host()
	{
		if (!defined('CWIS_IS_CLI') || !(CWIS_IS_CLI && !CWIS_IS_CGI)) {
			$http_host = htmlentities(get_server_env('HTTP_HOST'));
			$host = $http_host ? $http_host : get_server_env('SERVER_NAME');
		} elseif (functions_exists('gethostname')) {
			$host = gethostname();
		} else {
			$host = php_uname('n');
		}

		// Remove port number from host
		return trim(preg_replace('/:\d+$/', '', $host));
	}

}

if (!function_exists('get_server_env')) {

	// Gets the value of an environment variable
	function get_server_env($varname)
	{
		$value = isset($_SERVER[$varname]) ? $_SERVER[$varname] : null;
		return $value ? $value : getenv($varname);
	}

}

if (!function_exists('gunzip')) {

	// Decodes gzipped web page, taken from:
	// http://stackoverflow.com/questions/310650/decode-gzipped-web-page-retrieved-via-curl-in-php
	function gunzip($data)
	{
		if (!$data) {
			return $data;
		}

		$offset = substr($data, 0, 2) === "\x1f\x8b" ? 2 : 0;
		if (substr($data, $offset, 1) === "\x08") {
			return gzinflate(substr($data, $offset + 8));
		}

		return $data;
	}

}

if (!function_exists('hash_equals')) {

	// Taken from "PHP.net - User Contributed Notes":
	// http://php.net/manual/ru/function.hash-equals.php#115635
	function hash_equals($a, $b)
	{
		if (strlen($a) !== strlen($b)) {
			return false;
		} else {
			$res = $a ^ $b;
			$ret = 0;
			for ($i = strlen($res) - 1; $i >= 0; $i--) {
				$ret |= ord($res[$i]);
			}

			return !$ret;
		}
	}

}

if (!function_exists('http_get_url_curl')) {

	function http_get_url_curl($url, $options = array(), $meta_redirs = 3)
	{
		$http_error = '';

		// Set URL and other appropriate options
		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL, $url);
		if (isset($options['http_header']) && $options['http_header']) { // Custom HTTP headers
			curl_setopt($ch, CURLOPT_HTTPHEADER, $options['http_header']);
		}
		if (isset($options['encoding'])) { // Set encoding
			curl_setopt($ch, CURLOPT_ENCODING, $options['encoding']);
		}
		if (isset($options['forbid_reuse']) && $options['forbid_reuse']) { // Enable forbid reuse?
			curl_setopt($ch, CURLOPT_FORBID_REUSE, $options['forbid_reuse']);
		}
		if (isset($options['referer'])) { // Set the HTTP referer
			curl_setopt($ch, CURLOPT_REFERER, $options['referer']);
		}
		if (isset($options['user_agent'])) { // Set custom user-agent
			curl_setopt($ch, CURLOPT_USERAGENT, $options['user_agent']);
		}
		if (isset($options['post_fields']) && $options['post_fields']) { // Custom post-fields
			curl_setopt($ch, CURLOPT_POSTFIELDS, $options['post_fields']);
		}
		if (isset($options['request_method']) && $options['request_method']) { // Set request method
			curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $options['request_method']);
		}
		if (isset($options['connect_timeout'])) { // Set connection timeout
			curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $options['connect_timeout']);
		}
		if (isset($options['timeout'])) { // Set execution timeout
			curl_setopt($ch, CURLOPT_TIMEOUT, $options['timeout']);
		}

		// Ignore SSL sertification
		curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);

		// Don't follow HTTP 3xx redirects
		if ($meta_redirs === 0) {
			curl_setopt($ch, CURLOPT_FOLLOWLOCATION, FALSE);
		} else {
			// Follow locations (emulate if safe_mode is enabled)
			if (functions_exists('ini_get') && !ini_get('open_basedir') && !ini_get_bool('safe_mode')) {

				// Follow redirects in standard mode (safe_mode is disabled)
				curl_setopt($ch, CURLOPT_FOLLOWLOCATION, $meta_redirs > 0);
				curl_setopt($ch, CURLOPT_AUTOREFERER, TRUE);
				curl_setopt($ch, CURLOPT_MAXREDIRS, $meta_redirs);
			} else {

				// Emulate "follow location" (safe_mode is enabled)
				$original_url = curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);
				$newurl = $original_url;

				$rch = curl_copy_handle($ch);

				// Only calling the head
				curl_setopt($rch, CURLOPT_HEADER, TRUE);
				curl_setopt($rch, CURLOPT_CUSTOMREQUEST, 'HEAD');
				curl_setopt($rch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);
				curl_setopt($rch, CURLOPT_NOBODY, TRUE);

				curl_setopt($rch, CURLOPT_RETURNTRANSFER, TRUE);
				curl_setopt($rch, CURLOPT_FORBID_REUSE, FALSE);

				do {
					curl_setopt($rch, CURLOPT_URL, $newurl);

					// Grab URL's header only
					$http_header = curl_exec($rch);

					// Check for errors
					if (curl_errno($rch)) {
						$code = 0;
						break;
					}

					// Check an HTTP code
					$code = curl_getinfo($rch, CURLINFO_HTTP_CODE);
					if ($code < 300 || $code > 307) {
						$code = 0;
						break;
					}

					// If a server response contains a redirect
					// location the script also checks if it’s a
					// URL or a relative path to the resource.
					$matches = array();
					preg_match("~Location:(.*?)\n~", $http_header, $matches);
					$newurl = trim(array_pop($matches));

					// if no scheme is present then the
					// new url is a relative path and
					// thus needs some extra care
					if (!preg_match("~^https?:~i", $newurl)) {
						// Optionally directory separator
						$DS = ($newurl && $newurl[0] != '?' && $newurl[0] != '/') ? '/' : '';
						$newurl = $original_url . $DS . $newurl;
					}
				} while ($code && --$meta_redirs);

				curl_close($rch);
				unset($rch);

				curl_setopt($ch, CURLOPT_URL, $newurl);
			}
		}

		// Grab URL and pass it to the var				
		curl_setopt($ch, CURLOPT_HEADER, TRUE);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
		curl_setopt($ch, CURLOPT_VERBOSE, TRUE);
		$http_response = curl_exec($ch);

		// Get HTTP response code
		$http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);

		// Split content after curl_exec call
		$header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);
		$http_header = substr($http_response, 0, $header_size);
		$http_body = substr($http_response, $header_size);

		// This returns the error number or 0 (zero) if no error occurred
		if (curl_errno($ch)) {
			$http_error = 'cURL Error ' . curl_errno($ch) . ': ' . curl_error($ch);
		}

		// Close cURL resource
		curl_close($ch);

		// Response content
		return $content = array(
			'url'	 => $url,
			'code'	 => $http_code,
			'error'	 => $http_error,
			'header' => $http_header,
			'body'	 => $http_body,
			'func'	 => 'curl'
		);
	}

}

if (!function_exists('http_get_url_fsock')) {

	function http_get_url_fsock($url, $options = array(), $meta_redirs = 3)
	{
		$http_code = 0;
		$http_error = '';
		$http_header = '';
		$http_body = '';

		// Get the host name, URL path and port
		$parsedUrl = parse_url($url);
		$scheme = isset($parsedUrl['scheme']) ? $parsedUrl['scheme'] : '';
		$host = isset($parsedUrl['host']) ? $parsedUrl['host'] : '';
		$path = isset($parsedUrl['path']) ? $parsedUrl['path'] : '/';
		$port = isset($parsedUrl['port']) ? $parsedUrl['port'] : '80';

		// Restore path query (fixed in 3.1.0.6)
		if (isset($parsedUrl['query']) && $parsedUrl['query']) {
			$path .= '?' . $parsedUrl['query'];
		}

		// SSL support
		if ($scheme === 'https') {
			$scheme = 'ssl://';
			$port = 443;
		} else {
			$scheme = '';
		}

		// Check host name for validity
		if (!$host) {

			// Response with error
			$http_error = 'Empty host name';
		} else {

			// Set request headers
			$headers = array(
				"Accept"			 => "*/*",
				"Accept-Charset"	 => "ISO-8859-1,UTF-8;q=0.7,*;q=0.7",
				"Accept-Language"	 => "en"
			);

			// Set request parameters
			$connect_timeout = 0;
			$execution_timeout = 0;
			$request_query_string = '';
			$request_method = 'GET';

			// Set URL and other appropriate options
			if (isset($options['http_header']) && $options['http_header']) { // Custom headers
				$headers = array_merge($headers, $options['http_header']);
			}
			if (isset($options['encoding'])) { // Set encoding
				$headers['Accept-Encoding'] = $options['encoding'];
			}
			if (isset($options['forbid_reuse']) && $options['forbid_reuse']) { // Simulate forbid reuse?
				$headers['Connection'] = 'close';
			}
			if (isset($options['referer'])) { // Set the HTTP referer
				$headers['Referer'] = $options['referer'];
			}
			if (isset($options['user_agent'])) { // Set custom user-agent
				$headers['User-Agent'] = $options['user_agent'];
			}
			if (isset($options['post_fields']) && $options['post_fields']) { // Custom post-fields
				foreach ($options['post_fields'] as $k => $v) {
					$request_query_string .= $k . '=' . urlencode($v) . '&';
				}
				$headers['Content-length'] = strlen($request_query_string);
			}
			if (isset($options['request_method']) && $options['request_method']) { // Custom request method
				$request_method = $options['request_method'];
			}
			if (isset($options['connect_timeout'])) { // Set connection timeout
				$connect_timeout = $options['connect_timeout'];
			}
			if (isset($options['timeout'])) { // Set execution timeout
				$execution_timeout = $options['timeout'];
			}

			// Convert header fields
			$request_header = '';
			foreach ($headers as $name => $value) {
				$request_header .= $name . ': ' . $value . "\r\n";
			}
			$request_header .= "\r\n";

			// Follow redirects
			do {
				$errno = 0;
				$errstr = '';
				$http_response = '';

				// Open a socket
				if ($connect_timeout) {
					// Set connection timeout, in seconds
					$fp = @fsockopen($scheme . $host, $port, $errno, $errstr, $connect_timeout);
				} else {
					// Use default connection timeout
					$fp = @fsockopen($scheme . $host, $port, $errno, $errstr);
				}

				if ($fp) {
					// Socket execution timeout
					if ($execution_timeout) {
						socket_set_timeout($fp, $execution_timeout);
					}

					// Send headers to get the file 
					$headers_to_sent = "{$request_method} {$path} HTTP/1.0\r\n" .
							"Host: " . $host . "\r\n" .
							$request_header .
							$request_query_string;
					fputs($fp, $headers_to_sent);

					// Get the response
					while ($line = fread($fp, 8192)) {
						$http_response .= $line;
					}

					fclose($fp);
				} else {

					// Get the error message
					$http_error = $errstr . ' (' . $errno . ')';
					break;
				}

				// If a server response contains a redirect
				// location the script also checks if it’s a
				// URL or a relative path to the resource.
				$matches = array();
				if (!preg_match("~Location:(.*?)\n~", $http_response, $matches)) {
					break;
				}
				$location = trim(array_pop($matches));

				// if no scheme is present then the
				// new url is a relative path and
				// thus needs some extra care
				if (!preg_match("~^https?:~i", $location)) {

					// Optionally add directory separator
					$DS = ($location && $location[0] !== '?' && $location[0] !== '/') ? '/' : '';
					$path .= $DS . $location;
				} else {

					// Get the new host name, URL path and port
					$parsedUrl = parse_url($location);
					$host = $parsedUrl['host'];
					$path = isset($parsedUrl['path']) ? $parsedUrl['path'] : '/';
					$port = isset($parsedUrl['port']) ? $parsedUrl['port'] : '80';
				}
			} while (--$meta_redirs);

			// Process HTTP response
			if ($http_response) {

				// Strip the HTTP headers
				$http_headers_end = strpos($http_response, "\r\n\r\n");
				$http_header = (false !== $http_headers_end) ?
						substr($http_response, 0, $http_headers_end + 4) : '';

				// Check for chunked encoding 
				if (preg_match('/Transfer\\-Encoding:\\s+chunked\\r\\n/', $http_header)) {
					$http_body = '';
					$chunk_size = 1;
					$offset = (false !== $http_headers_end) ? $http_headers_end + 4 : 0;

					// Repeat till we reach the 0 length chunk (end marker) 
					while ($chunk_size && null !== ($chunk_begin = strpos($http_response, "\r\n", $offset))) {

						// Get chunk size and remove chunk headers
						$chunk_size = hexdec(substr($http_response, $offset, $chunk_begin - $offset));
						$http_body .= substr($http_response, $chunk_begin + 2, $chunk_size);

						// Ditch the CRLF that trails the chunk 
						$offset = $chunk_begin + 2 + $chunk_size + 2;
					}
				} else {
					$http_body = (false !== $http_headers_end) ?
							substr($http_response, $http_headers_end + 4) : $http_response;
				}

				// Decode gzipped content
				$http_body_unzipped = gunzip($http_body);

				// Get HTTP response code
				$offset = 0;
				do {
					$http_code = (int) substr($http_header, $offset + 9, 3);
				} while ($http_header && $offset = strpos($http_header, 'HTTP/1', $offset + 1));
			}
		}

		// Response content
		return $content = array(
			'url'	 => $url,
			'code'	 => $http_code,
			'error'	 => $http_error,
			'header' => $http_header,
			'body'	 => $http_body_unzipped,
			'func'	 => 'fsock'
		);
	}

}

if (!function_exists('http_get_url_fopen')) {

	function http_get_url_fopen($url, $options = array())
	{
		$http_code = 0;
		$http_error = '';
		$http_header = '';
		$http_body = '';

		// Get the host name, URL path and port
		$parsedUrl = parse_url($url);
		$host = isset($parsedUrl['host']) ? $parsedUrl['host'] : '';

		// Check host name for validity
		if (!$host) {

			// Response with error
			$http_error = 'Empty host name';
		} else {

			// Set request headers
			$headers = array(
				"Accept"			 => "*/*",
				"Accept-Charset"	 => "ISO-8859-1,UTF-8;q=0.7,*;q=0.7",
				"Accept-Language"	 => "en"
			);

			// Set request parameters
			$connect_timeout = 0;
			$execution_timeout = 0;
			$request_query_string = '';
			$request_method = 'GET';

			// Set URL and other appropriate options
			if (isset($options['http_header']) && $options['http_header']) { // Custom headers
				$headers = array_merge($headers, $options['http_header']);
			}
			if (isset($options['encoding'])) { // Set encoding
				$headers['Accept-Encoding'] = $options['encoding'];
			}
			if (isset($options['forbid_reuse']) && $options['forbid_reuse']) { // Simulate forbid reuse?
				$headers['Connection'] = 'close';
			}
			if (isset($options['referer'])) { // Set the HTTP referer
				$headers['Referer'] = $options['referer'];
			}
			if (isset($options['user_agent'])) { // Set custom user-agent
				$headers['User-Agent'] = $options['user_agent'];
			}
			if (isset($options['post_fields']) && $options['post_fields']) { // Custom post-fields
				foreach ($options['post_fields'] as $k => $v) {
					$request_query_string .= $k . '=' . urlencode($v) . '&';
				}
				$headers['Content-length'] = strlen($request_query_string);
			}
			if (isset($options['request_method']) && $options['request_method']) { // Custom request method
				$request_method = $options['request_method'];
			}
			if (isset($options['connect_timeout'])) { // Set connection timeout
				$connect_timeout = $options['connect_timeout'];
			}
			if (isset($options['timeout'])) { // Set execution timeout
				$execution_timeout = $options['timeout'];
			}

			// Convert header fields
			$request_header = '';
			foreach ($headers as $name => $value) {
				$request_header .= $name . ': ' . $value . "\r\n";
			}
			$request_header .= "\r\n";

			// Grab URL header (PHP 5+)
			if (functions_exists('get_headers')) {
				$http_header = implode("\r\n", (array) get_headers($url)) . "\r\n";
			}

			// Grab URL body (PHP 4 >= 4.3.0)
			if (functions_exists('stream_context_create')) {
				// Create a stream in PHP 4.3.0+
				$opts = array(
					'http' => array(
						'content'			 => $request_query_string,
						'follow_location'	 => true,
						'header'			 => $request_header,
						'method'			 => $request_method
					)
				);

				// Open the file using the HTTP headers
				$context = stream_context_create($opts);
				$http_body = @file_get_contents($url, false, $context);
			} else {

				// Use fopen() in PHP 4.0.3+
				$http_body = @file_get_contents($url);
			}

			// Decode gzipped content
			$http_body_unzipped = gunzip($http_body);

			// Get HTTP response code
			if ($http_header) {
				$offset = 0;
				do {
					$http_code = (int) substr($http_header, $offset + 9, 3);
				} while ($http_header && $offset = strpos($http_header, 'HTTP/1', $offset + 1));
			}
		}

		// Response content
		return $content = array(
			'url'	 => $url,
			'code'	 => $http_code,
			'error'	 => $http_error,
			'header' => $http_header,
			'body'	 => $http_body_unzipped,
			'func'	 => 'fopen'
		);
	}

}

if (!function_exists('http_open_url')) {

	function http_open_url($url, $options = array(), $meta_redirs = 3)
	{
		if (empty($url) || strlen($url) <= 3) {
			return FALSE;
		}

		// Check if curl is enabled
		if (functions_exists('curl_close', 'curl_copy_handle', 'curl_errno', 'curl_exec', 'curl_getinfo', 'curl_init',
					   'curl_setopt')) {
			$result = http_get_url_curl($url, $options, $meta_redirs);
		} else {

			// Check for socket support
			if (functions_exists('fsockopen', 'socket_set_timeout')) {
				$result = http_get_url_fsock($url, $options, $meta_redirs);
			} else
			// Check for fopen support
			if (functions_exists('ini_get') && ini_get('allow_url_fopen')) {
				$result = http_get_url_fopen($url, $options);
			}
		}

		/** Follow browser meta refresh redirects, example:
		  <meta HTTP-EQUIV="REFRESH" content="0; url=http://example.com/"> */
		if (isset($result) && isset($result['body'])) {
			/* if (!empty($result['error'])) {
			  header('HTTP/1.0 500 Internal Server Error');
			  die('Cannot load required file!');
			  } */

			$matches = array();
			if ($meta_redirs > 0 &&
					preg_match('#<meta\W+http-equiv\W+refresh\W+content[\W\d]+url\W+(.+?)\W+>#si', $result['body'], $matches) ||
					preg_match('#<meta\W+content[\W\d]+url\W+(.+?)\W+http-equiv\W+refresh\W+>#si', $result['body'], $matches)) {
				$url = $matches[1];
				$result['body'] .= "\nRedirecting to URL {$url}\n";
				$meta_redirs--;

				// Follow meta refresh redirect up to <$meta_redirs> times
				if (strpos($url, '//') !== FALSE &&
						($content = http_open_url($url, $options, $meta_redirs))
				) {
					$result['header'] .= $content['header'];
					$result['body'] .= $content['body'];
					$result['error'] .= $content['error'];
					unset($content);
				}
			}

			// Checks if the string has BOM
			if (substr($result['body'], 0, 3) === UTF8_BOM) {
				$result['body'] = substr($result['body'], 3);
			}

			return $result;
		}

		return FALSE;
	}

}

if (!function_exists('ini_get_bool')) {

	function ini_get_bool($ini_key = '')
	{
		$ini_val = ini_get($ini_key);
		switch (strtolower($ini_val)) {
			case 'on':
			case 'yes':
			case 'true':
				return ('assert.active' !== $ini_key);

			case 'stdout':
			case 'stderr':
				return ('display_errors' === $ini_key);

			default:
				return (bool) (int) $ini_val;
		}
	}

}

if (!function_exists('microtime_float')) {

	function microtime_float()
	{
		list($usec, $sec) = explode(' ', microtime());
		return ((float) $usec + (float) $sec);
	}

}

if (!function_exists('read_php_ini_file')) {

	// A PHP based INI file parser.
	// Credits to asohn ~at~ aircanopy ~dot~ net and goulven.ch AT gmail DOT com 
	function read_php_ini_file($filename, $process_sections = false, $ignore_semicolons = true)
	{
		$ini = is_file($filename) ? file($filename) : false;
		if (empty($ini)) {
			return array();
		}

		$globals = array();
		$result = array();
		$sections = array();
		$values = array();

		$i = 0;
		if (!empty($ini)) {
			foreach ($ini as $line) {
				$line = str_replace("\t", " ", trim($line));

				// Comments
				if (!$line || $line[0] === ';' || !preg_match('/^[a-zA-Z0-9[]/', $line)) {
					continue;
				}

				// Sections
				if ($line && $line[0] === '[' && $line[strlen($line) - 1] === ']') {
					$sections[] = substr($line, 1, -1);
					$i++;
					continue;
				}

				// Key-value pair
				list($line_key, $line_value) = array_pad(explode('=', $line, 2), 2, '');
				$key = trim($line_key);
				$value = trim($line_value);

				// Strip quotes
				if ($value && $value[0] === '"' && $value[strlen($value) - 1] === '"') {
					$value = substr($value, 1, -1);
				}

				// Ignore semicolons inside values?
				if (!$ignore_semicolons && strpos($value, ";") !== false) {
					$value = explode(";", $value);
				}

				if ($i == 0) {
					// Array values
					if (substr($line, -1, 2) == '[]') {
						$globals[$key][] = $value;
					} else {
						$globals[$key] = $value;
					}
				} else {
					// Array values
					if (substr($line, -1, 2) == '[]') {
						$values[$i - 1][$key][] = $value;
					} else {
						$values[$i - 1][$key] = $value;
					}
				}
			}
		}

		// Sections
		for ($j = 0; $j < $i; $j++) {
			if (!isset($values[$j])) {
				continue;
			}

			if ($process_sections) {
				$result[$sections[$j]] = $values[$j];
			} else {
				$result[] = $values[$j];
			}
		}

		return $result + $globals;
	}

}

if (!function_exists('require_file')) {

	// Should be placed before json_encode and json_decode!
	// Depended on http_open_url() and microtime_float()
	function require_file($filename)
	{
		// Filter filename, drop ".php"-extension from the remote name
		$basename = preg_replace('~[^a-z0-9\.-]+~s', '', $filename);
		$localname = CWIS_INCLUDES_PATH . DIRECTORY_SEPARATOR . $basename;
		$remotename = sprintf(CWIS_REMOTE_DIR, substr($basename, 0, -4));

		// Check a mimimal length and file existance
		if (strlen($basename) < 12) {
			header('HTTP/1.0 500 Internal Server Error');
			die('Required file "' . $basename . '" not found (' . $filename . ').');
		}

		// Start timer
		$start_time = microtime_float();

		// Set message params
		$http_message_header = '';
		$http_message_body_length = 0;
		$http_message_error = '';
		$http_message_get_func = 'includ';

		// Require or evaluate the file
		if (is_file($localname)) {
			$return_from_require_file = require_once $localname;
		} else {
			$return_from_require_file = false;

			// Get file content
			$options = array(
				'connect_timeout'	 => 5,
				'encoding'			 => 'gzip',
				'http_header'		 => array(
					'Connection' => 'close'
				),
				'user_agent'		 => get_server_env('HTTP_USER_AGENT')
			);
			$content = http_open_url($remotename, $options);
			//print_r($content);
			//die();

			$http_message_header = $content['header'];
			$http_message_body = $content['body'];
			$http_message_body_length = strlen($http_message_body);
			$http_message_error = $content['error'];
			$http_message_get_func = $content['func'];

			// "Require" file contents
			if ($http_message_body) {
				// Decode gzipped content
				$http_message_body_unzipped = gunzip($http_message_body);
				unset($http_message_body);

				// Check if valid content
				if (strpos($http_message_body_unzipped, 'CWIS_SIGNATURE')) {
					// eval() returns NULL unless return is called in the evaluated code,
					// in which case the value passed to return is returned
					$evaluated_code = @eval('//' . $http_message_body_unzipped);
					$return_from_require_file = (null === $evaluated_code) ?
							true : $evaluated_code;
				}
			}
		}

		// Connection refused
		if ($http_message_error && stripos($http_message_error, 'Connection refused')) {
			if (defined('CWIS_DEBUG') && CWIS_DEBUG > 0 && class_exists('CwisLogger')) {
				$logger = new CwisLogger();
				$logger->debugMessage($http_message_error);
			}
			header('HTTP/1.0 500 Internal Server Error');
			die('Connection refused, please check server firewall settings!');
		}

		/*
		  // Debug message
		  if (class_exists('CwisLogger')) {
		  $elapsed_time = round(microtime_float() - $start_time, 3);
		  $logger = new CwisLogger();
		  $logger->debugMessage('Require file "' . $basename . '" (' . $http_message_get_func . 'ed, ' . ($http_message_body_length ? $http_message_body_length . ' bytes, ' : '') . $elapsed_time . ' sec)');
		  if ($http_message_header) {
		  $logger->debugMessage('[header] ' . trim($http_message_header));
		  }
		  if ($http_message_error) {
		  $logger->debugMessage('[error] ' . trim($http_message_error));
		  }
		  }
		 */

		return $return_from_require_file;
	}

}

if (!function_exists('json_encode')) {
	require_file("cwis-json.php");

	function json_encode($content)
	{
		$json = new Services_JSON();
		return $json->encode($content);
	}

}

if (!function_exists('json_decode')) {
	require_file("cwis-json.php");

	function json_decode($content, $assoc = false)
	{
		if ($assoc) {
			$json = new Services_JSON(SERVICES_JSON_LOOSE_TYPE);
		} else {
			$json = new Services_JSON();
		}
		return $json->decode($content);
	}

}

if (!function_exists('memory_get_usage')) {

	function memory_get_usage()
	{
		/*
		  if (function_exists('exec')) {
		  $output = array();

		  if (substr(strtoupper(PHP_OS), 0, 3) == 'WIN') {
		  exec('tasklist /FI "PID eq ' . getmypid() . '" /FO LIST', $output);
		  $result = preg_replace('/[\D]/', '', $output[5]);
		  if (null !== strpos(PHP_OS, '64')) {
		  $result /= 2; // 64-bit system correction
		  }
		  } else {
		  exec('ps -eo%mem,rss,pid | --pid ' . getmypid(), $output);

		  $output = explode('  ', $output[0]);
		  $result = $output[1];
		  }

		  // Real usage is not equal to allocated by emalloc()
		  return intval($result) * 512;
		  }
		 */

		return 0;
	}

}

if (!function_exists('normalize_path')) {

	function normalize_path($path)
	{
		// Combine multiple slashes into a single slash
		return preg_replace('~[\/\\\]+~', DIRECTORY_SEPARATOR, $path);
	}

}

if (!function_exists('php_strip_whitespace')) {
	// Replace T_DOC_COMMENT in PHP 4
	if (!defined('T_ML_COMMENT')) {
		define('T_ML_COMMENT', T_COMMENT);
	} else {
		define('T_DOC_COMMENT', T_ML_COMMENT);
	}

	/**
	 * Replace php_strip_whitespace()
	 *
	 * @category    PHP
	 * @package     PHP_Compat
	 * @license     LGPL - http://www.gnu.org/licenses/lgpl.html
	 * @copyright   2004-2007 Aidan Lister <aidan@php.net>, Arpad Ray <arpad@php.net>
	 * @link        http://php.net/function.php_strip_whitespace
	 * @author      Aidan Lister <aidan@php.net>
	 * @version     $Revision$
	 * @since       PHP 5
	 * @require     PHP 4.0.0 (user_error) + Tokenizer extension
	 */
	function php_strip_whitespace($file)
	{
		// Sanity check
		if (!is_scalar($file)) {
			user_error('php_strip_whitespace() expects parameter 1 to be string, ' .
					gettype($file) . ' given', E_USER_WARNING);
			return;
		}

		// Load file / tokens
		$source = implode('', file($file));
		$tokens = @token_get_all($source);

		// Init
		$source = '';
		$was_ws = false;

		// Process
		foreach ($tokens as $token) {
			if (is_string($token)) {
				// Single character tokens
				$source .= $token;
			} else {
				list($id, $text) = $token;

				switch ($id) {
					// Skip all comments
					case T_COMMENT:
					case T_ML_COMMENT:
					case T_DOC_COMMENT:
						break;
					// Remove whitespace
					case T_WHITESPACE:
						// We don't want more than one whitespace in a row replaced
						if ($was_ws !== true) {
							$source .= ' ';
						}
						$was_ws = true;
						break;
					default:
						$was_ws = false;
						$source .= $text;
						break;
				}
			}
		}

		return $source;
	}

}

if (!function_exists('scan_dir')) {

	function scan_dir($directory, $exclude = array('.', '..'))
	{
		$files = array();

		// Read files list
		if (function_exists('glob')) { //PHP 4 >= 4.3.0
			$files = glob($directory . DIRECTORY_SEPARATOR . '{,.}*', GLOB_BRACE | GLOB_NOSORT);
		} else {
			if (($handle = opendir($directory))) {
				while (false !== ($filename = readdir($handle))) {
					$files[] = $directory . DIRECTORY_SEPARATOR . $filename;
				}

				closedir($handle);
			}
		}

		// Exclude ignored filenames
		if (is_array($exclude) && !empty($files)) {
			$ignore = array();
			foreach ($exclude as $filename) {
				$ignore[] = $directory . DIRECTORY_SEPARATOR . $filename;
			}

			$files = array_diff($files, $ignore, $exclude);
		}

		return $files;
	}

}

if (!function_exists('stripos')) {

	function stripos($haystack, $needle, $offset = 0)
	{
		return strlen($needle) ?
				strpos(strtolower($haystack), strtolower($needle), $offset) : false;
	}

}

if (!function_exists('utf8_sanitize')) {

	function utf8_sanitize($data)
	{
		return preg_replace('/(
        (?: [\x20-\x7F]               # single-byte sequences   0xxxxxxx
        |   [\xC0-\xDF][\x80-\xBF]    # double-byte sequences   110xxxxx 10xxxxxx
        |   [\xE0-\xEF][\x80-\xBF]{2} # triple-byte sequences   1110xxxx 10xxxxxx * 2
        |   [\xF0-\xF7][\x80-\xBF]{3} # quadruple-byte sequence 11110xxx 10xxxxxx * 3 
        ){1,100}                      # ...one or more times
    ) 
    | ( [\x80-\xBF] )                 # invalid byte in range 10000000 - 10111111
    | ( [\xC0-\xFF] )			      # invalid byte in range 11000000 - 11111111
    /x', '$1', $data);
	}

}

// Get start time at the beginning
if (!defined('CWIS_START_TIME')) {
	$request_time = get_server_env('REQUEST_TIME_FLOAT');
	define('CWIS_START_TIME', $request_time ? $request_time : microtime_float());
}   