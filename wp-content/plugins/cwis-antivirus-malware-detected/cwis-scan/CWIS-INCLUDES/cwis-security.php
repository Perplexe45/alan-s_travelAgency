<?php

// ezscan7objrldgpfvmqkdthyuwi4x2x5
if (!defined('CWIS_SIGNATURE')) {
	header('HTTP/1.0 403 Forbidden');
	die('-1');
}

/**
 * 
 * RIPS - A static source code analyser for vulnerabilities in PHP scripts
 * by Johannes Dahse (johannes.dahse@rub.de)
 * 
 * Copyright (C) 2012 Johannes Dahse
 * 
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 3 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, see <http://www.gnu.org/licenses/>.
 *
 */
ini_set('short_open_tag', 1);   // who knows if I use them ;)
ini_set('auto_detect_line_endings', 1); // detect newlines in MAC files

define('MAXTRACE', 30);  // maximum of parameter traces per sensitive sink
define('PHPDOC', 'http://php.net/'); // PHP documentation link
define('MAX_ARRAY_ELEMENTS', 50);  // maximum array(1,2,3,4,...) elements to be indexed
define('MAX_ARRAY_KEYS', 10);   // maximum array key $array[1][2][3][4]..
define('PRELOAD_SHOW_LINE', 500);  // every X line a preloader information is added
define('SCAN_REGISTER_GLOBALS', false); // EXPERIMENTAL: scan as if register_globals=on

class CwisSec
{

	var $rips_scan;

	function construct($file_name = '', $file_contents = '')
	{
		$scan_functions = array_merge(
				CwisSecSinks::$F_XSS, CwisSecSinks::$F_HTTP_HEADER, CwisSecSinks::$F_SESSION_FIXATION, CwisSecSinks::$F_CODE,
	CwisSecSinks::$F_REFLECTION, CwisSecSinks::$F_FILE_READ, CwisSecSinks::$F_FILE_AFFECT, CwisSecSinks::$F_FILE_INCLUDE,
	CwisSecSinks::$F_EXEC, CwisSecSinks::$F_DATABASE, CwisSecSinks::$F_XPATH, CwisSecSinks::$F_LDAP,
	CwisSecSinks::$F_CONNECT, CwisSecSinks::$F_POP, CwisSecSinks::$F_OTHER
		);
		$info_functions = CwisSecInfo::$F_INTEREST;
		$source_functions = array_merge(CwisSecSources::$F_OTHER_INPUT, CwisSecSources::$F_FILE_INPUT,
								  CwisSecSources::$F_DATABASE_INPUT);

		$this->rips_scan = new CwisSecRipsScan($file_name, $file_contents, $scan_functions, $info_functions, $source_functions);
		$this->rips_scan->parse();
	}

	function parse_vars()
	{
		$t_parser = new CwisSecParser();

		foreach ($this->rips_scan->var_declares_global as $var_declares_global) {
			foreach ($var_declares_global as &$var_declare) {
				$t_parser->set_tokens($var_declare->tokens);
				$t_parser->evaluate_expressions();
				$t_parser->parse_concatenations();
				$t_parser->evaluate_functions();
				$t_parser->parse_concatenations();
				$var_declare->parsedtokens = array_values(array_filter($t_parser->get_tokens()));
			}
		}

		foreach ($this->rips_scan->var_declares_local as $var_declares_local) {
			foreach ($var_declares_local as &$var_declare) {
				$t_parser->set_tokens($var_declare->tokens);
				$t_parser->evaluate_expressions();
				$t_parser->parse_concatenations();
				$t_parser->evaluate_functions();
				$t_parser->parse_concatenations();
				$var_declare->parsedtokens = array_values(array_filter($t_parser->get_tokens()));
			}
		}
	}

}

class CwisSecAnalyzer
{

	var $recursion = 0;

	// reconstructs string from a list of tokens
	function get_tokens_value($file_name, $tokens, $var_declares, $var_declares_global, $tokenid, $start = 0, $stop = 0, $source_functions = array())
	{
		if ($this->recursion++ > 100000) {
			return; //prevent infinite recursion
		}

		$value = '';
		if (!$stop) {
			$stop = count($tokens);
		}

		// check all tokens until instruction ends
		for ($i = $start; $i < $stop; $i++) {
			if (!isset($tokens[$i]) || !is_array($tokens[$i])) {
				continue;
			}

			// trace variables for its values
			if ($tokens[$i][0] === T_VARIABLE || (isset($tokens[$i + 1]) && $tokens[$i][0] === T_STRING && $tokens[$i + 1] !== '(' )) {
				if (!in_array($tokens[$i][1], CwisSecSources::$V_USERINPUT)) {
					// constant CONSTANTS
					if ($tokens[$i][1] === 'DIRECTORY_SEPARATOR') {
						$value .= '/';
					} else if ($tokens[$i][1] === 'PATH_SEPARATOR') {
						$value .= ';';
					}

					// global $varname -> global scope, CONSTANTS
					else if ((isset($tokens[$i - 1]) && is_array($tokens[$i - 1]) && $tokens[$i - 1][0] === T_GLOBAL) || $tokens[$i][1][0] !== '$') {
						$value .= $this->get_var_value($file_name, $tokens[$i], $var_declares_global, $var_declares_global, $tokenid);
					}
					// local scope
					else {
						$value .= $this->get_var_value($file_name, $tokens[$i], $var_declares, $var_declares_global, $tokenid);
					}
				} else {
					if (isset($tokens[$i][3])) {
						$parameter_name = str_replace(array("'", '"'), '', $tokens[$i][3][0]);
					} else {
						$parameter_name = '';
					}

					// mark userinput for quote analysis
					if (($tokens[$i][1] !== '$_SERVER' || (empty($parameter_name) ||
							in_array($parameter_name, CwisSecSources::$V_SERVER_PARAMS) ||
							substr($parameter_name, 0, 5) === 'HTTP_')) &&
							!((isset($tokens[$i - 1]) && is_array($tokens[$i - 1]) &&
							in_array($tokens[$i - 1][0], CwisSecTokens::$T_CASTS)) ||
							(isset($tokens[$i + 1]) && is_array($tokens[$i + 1]) &&
							in_array($tokens[$i + 1][0], CwisSecTokens::$T_ARITHMETIC)))) {
						$value .= '$_USERINPUT';
					} else {
						$value .= '1';
					}
				}
			}
			// add strings
			// except first string of define('var', 'value')
			else if ($tokens[$i][0] === T_CONSTANT_ENCAPSED_STRING &&
					!(isset($tokens[$i - 2]) && $tokens[$i - 2][0] === T_STRING && $tokens[$i - 2][1] === 'define')) {
				// add string without quotes
				$value .= substr($tokens[$i][1], 1, -1);
			}
			// add directory name dirname(__FILE__)
			else if ($tokens[$i][0] === T_FILE &&
					(isset($tokens[$i - 2]) && $tokens[$i - 2][0] === T_STRING && $tokens[$i - 2][1] === 'dirname')) {
				// overwrite value because __FILE__ is absolute
				// add slash just to be sure
				$value = dirname($file_name) . '/';
			}
			// add numbers
			else if ($tokens[$i][0] === T_LNUMBER ||
					$tokens[$i][0] === T_DNUMBER ||
					$tokens[$i][0] === T_NUM_STRING) {
				$value .= round($tokens[$i][1]);
			} else if ($tokens[$i][0] === T_ENCAPSED_AND_WHITESPACE) {
				$value .= $tokens[$i][1];
			}
			// if in foreach($bla as $key=>$value) dont trace $key, $value back
			else if ($tokens[$i][0] === T_AS) {
				break;
			}
			// function calls
			else if (isset($tokens[$i + 1]) && $tokens[$i][0] === T_STRING && $tokens[$i + 1] === '(') {
				// stop if strings are fetched from database/file (otherwise SQL query will be added)
				if (in_array($tokens[$i][1], CwisSecSources::$F_DATABASE_INPUT) ||
						in_array($tokens[$i][1], CwisSecSources::$F_FILE_INPUT) ||
						isset(CwisSecInfo::$F_INTEREST[$tokens[$i][1]])) {
					break;
				}
				// add userinput for functions that return userinput
				else if (in_array($tokens[$i][1], $source_functions)) {
					$value .= '$_USERINPUT';
				}
			}
		}

		return $value;
	}

	// traces values of variables and reconstructs string
	function get_var_value($file_name, $var_token, $var_declares, $var_declares_global, $last_token_id, $source_functions = array())
	{
		if ($this->recursion++ > 100000) {
			return; //prevent infinite recursion
		}

		$var_value = '';

		// CONSTANTS
		if ($var_token[1][0] !== '$') {
			$var_token[1] = strtoupper($var_token[1]);
		}

		// check if var declaration could be found for this var
		if (isset($var_declares[$var_token[1]])) {
			foreach ($var_declares[$var_token[1]] as $var_declare) {
				// check if array keys are the same (if it is an array)
				$array_key_diff = false;
				if (isset($var_token[3]) && !empty($var_declare->array_keys)) {
					$array_key_diff = @array_diff_assoc((array) $var_token[3], $var_declare->array_keys);
				}

				if ($var_declare->id < $last_token_id && empty($array_key_diff)) {
					$var_value .= $this->get_tokens_value($file_name, $var_declare->tokens, $var_declares, $var_declares_global,
										   $var_declare->id, $var_declare->tokenscanstart, $var_declare->tokenscanstop, $source_functions);
				}

				if ('' !== $var_value) {
					break;
				}
			}
		}

		return $var_value;
	}

	// gets end of codeblock (detects brace ending, ignores new brace opening and closing in between)
	function get_brace_end($tokens, $i)
	{
		if ($this->recursion++ > 100000) {
			return; //prevent infinite recursion
		}

		$c = 1;
		$newbraceopen = 1;
		while (!($newbraceopen === 0 || $tokens[$i + $c] === ';')) {

			// watch function calls in function call
			if ($tokens[$i + $c] === '(') {
				$newbraceopen++;
			} else if ($tokens[$i + $c] === ')') {
				$newbraceopen--;
			}
			if ($c > 50) {
				break;
			}
			$c++;
		}

		return $c;
	}

	function get_ini_paths($path)
	{
		if (!preg_match('/([;\\\\]|\W*[C-Z]{1}:)/', $path)) {
			$path = str_replace(':', ';', $path);
		}

		return explode(';', $path);
	}

}

class CwisSecInfo
{

	// interesting functions, output and comment them if seen
	static $F_INTEREST = array(
		'phpinfo'				 => 'phpinfo() detected',
		'registerPHPFunctions'	 => 'registerPHPFunctions() allows code exec in XML',
		'session_start'			 => 'uses sessions',
		#'session_destroy'				=> 'session_destroy(), delete arbitrary file in PHP 5.1.2',
		'dbase_open'			 => 'using DBMS dBase',
		'dbplus_open'			 => 'using DBMS DB++',
		'dbplus_ropen'			 => 'using DBMS DB++',
		'fbsql_connect'			 => 'using DBMS FrontBase',
		'ifx_connect'			 => 'using DBMS Informix',
		'db2_connect'			 => 'using DBMS IBM DB2',
		'db2_pconnect'			 => 'using DBMS IBM DB2',
		'ftp_connect'			 => 'using FTP server',
		'ftp_ssl_connect'		 => 'using FTP server',
		'ingres_connect'		 => 'using DBMS Ingres',
		'ingres_pconnect'		 => 'using DBMS Ingres',
		'ldap_connect'			 => 'using LDAP server',
		'msession_connect'		 => 'using msession server',
		'msql_connect'			 => 'using DBMS mSQL',
		'msql_pconnect'			 => 'using DBMS mSQL',
		'mssql_connect'			 => 'using DBMS MS SQL',
		'mssql_pconnect'		 => 'using DBMS MS SQL',
		'mysql_connect'			 => 'using DBMS MySQL',
		#'mysql_escape_string'			=> 'insecure mysql_escape_string',
		'mysql_pconnect'		 => 'using DBMS MySQL',
		'mysqli'				 => 'using DBMS MySQL, MySQLi Extension',
		'mysqli_connect'		 => 'using DBMS MySQL, MySQLi Extension',
		'mysqli_real_connect'	 => 'using DBMS MySQL, MySQLi Extension',
		'oci_connect'			 => 'using DBMS Oracle OCI8',
		'oci_new_connect'		 => 'using DBMS Oracle OCI8',
		'oci_pconnect'			 => 'using DBMS Oracle OCI8',
		'ocilogon'				 => 'using DBMS Oracle OCI8',
		'ocinlogon'				 => 'using DBMS Oracle OCI8',
		'ociplogon'				 => 'using DBMS Oracle OCI8',
		'ora_connect'			 => 'using DBMS Oracle',
		'ora_pconnect'			 => 'using DBMS Oracle',
		'ovrimos_connect'		 => 'using DBMS Ovrimos SQL',
		'pg_connect'			 => 'using DBMS PostgreSQL',
		'pg_pconnect'			 => 'using DBMS PostgreSQL',
		'sqlite_open'			 => 'using DBMS SQLite',
		'sqlite_popen'			 => 'using DBMS SQLite',
		'SQLite3'				 => 'using DBMS SQLite3',
		'sybase_connect'		 => 'using DBMS Sybase',
		'sybase_pconnect'		 => 'using DBMS Sybase',
		'TokyoTyrant'			 => 'using DBMS TokyoTyrant',
		'xptr_new_context'		 => 'using XML document',
		'xpath_new_context'		 => 'using XML document'
	);
	// interesting functions for POP/Unserialze
	static $F_INTEREST_POP = array(
		'__autoload'	 => 'function __autoload',
		'__destruct'	 => 'POP gagdet __destruct',
		'__wakeup'		 => 'POP gagdet __wakeup',
		'__toString'	 => 'POP gagdet __toString',
		'__call'		 => 'POP gagdet __call',
		'__callStatic'	 => 'POP gagdet __callStatic',
		'__get'			 => 'POP gagdet __get',
		'__set'			 => 'POP gagdet __set',
		'__isset'		 => 'POP gagdet __isset',
		'__unset'		 => 'POP gagdet __unset'
	);

}

class CwisSecParser
{

	// List of file inclusions
	var $file_inclusions = array();
	// List of function calls
	var $function_calls = array();
	// List of variable assigns
	var $variable_assigns = array();
	// Supported PHP-functions and their result token types
	var $supported_functions = array(
		'addslashes'				 => T_CONSTANT_ENCAPSED_STRING,
		'base64_decode'				 => T_CONSTANT_ENCAPSED_STRING,
		'bin2hex'					 => T_CONSTANT_ENCAPSED_STRING,
		'chop'						 => T_CONSTANT_ENCAPSED_STRING,
		'chr'						 => T_CONSTANT_ENCAPSED_STRING,
		'crc32'						 => T_LNUMBER,
		'crypt'						 => T_CONSTANT_ENCAPSED_STRING,
		'gzdecode'					 => T_CONSTANT_ENCAPSED_STRING,
		'gzinflate'					 => T_CONSTANT_ENCAPSED_STRING,
		'hebrev'					 => T_CONSTANT_ENCAPSED_STRING,
		'hebrevc'					 => T_CONSTANT_ENCAPSED_STRING,
		'hex2bin'					 => T_CONSTANT_ENCAPSED_STRING,
		'html_entity_decode'		 => T_CONSTANT_ENCAPSED_STRING,
		'htmlentities'				 => T_CONSTANT_ENCAPSED_STRING,
		'htmlspecialchars_decode'	 => T_CONSTANT_ENCAPSED_STRING,
		'htmlspecialchars'			 => T_CONSTANT_ENCAPSED_STRING,
		'lcfirst'					 => T_CONSTANT_ENCAPSED_STRING,
		'ltrim'						 => T_CONSTANT_ENCAPSED_STRING,
		'md5'						 => T_CONSTANT_ENCAPSED_STRING,
		'metaphone'					 => T_CONSTANT_ENCAPSED_STRING,
		'nl_langinfo'				 => T_CONSTANT_ENCAPSED_STRING,
		'nl2br'						 => T_CONSTANT_ENCAPSED_STRING,
		'ord'						 => T_LNUMBER,
		'quoted_printable_decode'	 => T_CONSTANT_ENCAPSED_STRING,
		'quoted_printable_encode'	 => T_CONSTANT_ENCAPSED_STRING,
		'quotemeta'					 => T_CONSTANT_ENCAPSED_STRING,
		'rawurldecode'				 => T_CONSTANT_ENCAPSED_STRING,
		'rawurlencode'				 => T_CONSTANT_ENCAPSED_STRING,
		'rtrim'						 => T_CONSTANT_ENCAPSED_STRING,
		'sha1'						 => T_CONSTANT_ENCAPSED_STRING,
		'soundex'					 => T_CONSTANT_ENCAPSED_STRING,
		'str_rot13'					 => T_CONSTANT_ENCAPSED_STRING,
		'str_shuffle'				 => T_CONSTANT_ENCAPSED_STRING,
		'strip_tags'				 => T_CONSTANT_ENCAPSED_STRING,
		'stripcslashes'				 => T_CONSTANT_ENCAPSED_STRING,
		'stripslashes'				 => T_CONSTANT_ENCAPSED_STRING,
		'strlen'					 => T_LNUMBER,
		'strtok'					 => T_CONSTANT_ENCAPSED_STRING,
		'strtolower'				 => T_CONSTANT_ENCAPSED_STRING,
		'strtoupper'				 => T_CONSTANT_ENCAPSED_STRING,
		'strrev'					 => T_CONSTANT_ENCAPSED_STRING,
		'time'						 => T_LNUMBER,
		'trim'						 => T_CONSTANT_ENCAPSED_STRING,
		'ucfirst'					 => T_CONSTANT_ENCAPSED_STRING,
		'ucwords'					 => T_CONSTANT_ENCAPSED_STRING,
		'urldecode'					 => T_CONSTANT_ENCAPSED_STRING,
		'urlencode'					 => T_CONSTANT_ENCAPSED_STRING,
		'wordwrap'					 => T_CONSTANT_ENCAPSED_STRING,
		'zlib_decode'				 => T_CONSTANT_ENCAPSED_STRING,
	);
	// Current file name
	var $file_name = '';
	// An array of tokens, generated by token_get_all()
	var $tokens = array();

	function set_file_name($file_name = '')
	{
		$this->file_name = $file_name;
	}

	function set_tokens($tokens = array())
	{
		$this->tokens = $tokens;
	}

	function get_tokens($filter = false)
	{
		return $filter ? array_values(array_filter($this->tokens)) : $this->tokens;
	}

	// Calculates expressions.
	function evaluate_expressions()
	{
		foreach ($this->tokens as $token_pos => $token) {
			// Search for string tokens
			if (is_array($token)) {
				continue;
			}

			switch ($token) {
				case '+':
				case '-':
					// Check nearby tokens
					$prev_token_pos = $this->prev_token_pos($token_pos);
					$next_token_pos = $this->next_token_pos($token_pos);
					if ($this->get_token_type($prev_token_pos) === T_LNUMBER &&
							$this->get_token_type($next_token_pos) === T_LNUMBER) {
						// Calculate and place result into next token
						switch ($token) {
							case '+':
								$this->tokens[$next_token_pos][1] = @($this->tokens[$prev_token_pos][1] + $this->tokens[$next_token_pos][1]);
								break;

							case '-':
								$this->tokens[$next_token_pos][1] = @($this->tokens[$prev_token_pos][1] - $this->tokens[$next_token_pos][1]);
								break;
						}

						// Clear processed tokens
						for ($pos = $prev_token_pos; $pos < $next_token_pos; $pos++) {
							$this->tokens[$pos] = '';
						}
					}
					break;
			}
		}
	}

	// Evaluates functions.
	function evaluate_functions()
	{
		foreach ($this->tokens as $token_pos => $token) {
			// Search for closing parenthesis
			if (is_array($token) || $token !== ')') {
				continue;
			}

			// Check if the token is surrounded by parenthesis
			$func_argument_pos = $this->prev_token_pos($token_pos);
			if ('(' === $this->get_token($func_argument_pos)) {
				$opening_parenthesis_pos = $func_argument_pos;
				$func_argument_pos = null; // no argument passed
			} else {
				$opening_parenthesis_pos = $this->prev_token_pos($func_argument_pos);
				if ('(' !== $this->get_token($opening_parenthesis_pos)) {
					continue; // no opening parenthesis found
				}
			}

			// Define function name and check if supported
			$func_call_pos = $this->prev_token_pos($opening_parenthesis_pos);
			$func_name = $this->get_token_content($func_call_pos);
			if (isset($this->supported_functions[$func_name]) && function_exists($func_name)) {

				// Cast function argument to a string
				if (null !== $func_argument_pos) {
					$func_argument_token_type = $this->get_token_type($func_argument_pos);
					$func_argument = $this->tokens[$func_argument_pos][1];
					if ($func_argument_token_type === T_CONSTANT_ENCAPSED_STRING) {
						$func_argument = substr($func_argument, 1, -1);
					}

					// Evaluate function with a parameter
					$func_result = @$func_name($func_argument);
				} else {
					// Evaluate with no parameters (void)
					$func_result = @$func_name();
				}

				// Cast function result, support for NULL
				$func_result_token_type = $this->supported_functions[$func_name];
				if ($func_result_token_type === T_CONSTANT_ENCAPSED_STRING) {
					$func_result = '"' . $func_result . '"';
				} elseif (null === $func_result) {
					$func_result = 'NULL';
				}

				// Line number (PHP 5 >= 5.2.2)
				$line_number = isset($this->tokens[$func_call_pos][2]) ? $this->tokens[$func_call_pos][2] : 0;

				// Place result into a single token
				$this->tokens[$token_pos] = array(
					$func_result_token_type,
					$func_result,
					$line_number
				);

				// Clear processed tokens
				for ($pos = $func_call_pos; $pos < $token_pos; $pos++) {
					$this->tokens[$pos] = '';
				}
			} elseif ('.' === $func_name || '(' === $func_name || ',' === $func_name ||
					'=' === $func_name || '?' === $func_name || ':' === $func_name) {
				// Strip parenthesized expressions
				$this->tokens[$opening_parenthesis_pos] = '';
				$this->tokens[$token_pos] = '';
			}
		}
	}

	// Parses string (and var values) concatenations.
	function parse_concatenations($var_declares_global = array(), $tokenid = 0)
	{
		$analyser = new CwisSecAnalyzer();
		foreach ($this->tokens as $token_pos => $token) {
			// Search for concatenation token "."
			if (is_array($token) || $token !== '.') {
				continue;
			}

			// Check left argument
			$prev_token_pos = $this->prev_token_pos($token_pos);
			$prev_token = $this->tokens[$prev_token_pos];
			if (!is_array($prev_token) || ($prev_token_type = $prev_token[0]) === T_STRING) {
				if (!isset($prev_token[1])) {
					continue;
				}

				// Convert PHP-constants
				if ($prev_token[1] === 'DIRECTORY_SEPARATOR') {
					$prev_token[1] = '/';
				} elseif ($prev_token[1] === 'PATH_SEPARATOR') {
					$prev_token[1] = ';';
				} else {
					continue; // invalid argument
				}
			} elseif ($prev_token_type === T_VARIABLE) {
				if ('' === ($var_value = $analyser->get_var_value($this->file_name, $prev_token, $var_declares_global,
													  $var_declares_global, $tokenid))) {
					continue; // invalid value
				}

				// Convert var value
				$prev_token[1] = $var_value;
				$prev_token_type = T_STRING;
			}

			// Check right argument
			$next_token_pos = $this->next_token_pos($token_pos);
			$next_token = $this->tokens[$next_token_pos];
			if (!is_array($next_token) || ($next_token_type = $next_token[0]) === T_STRING ||
					$next_token_type === T_VARIABLE) {
				continue; // invalid argument
			}

			// Cast left argument to a string
			$left_argument = $prev_token[1];
			if ($prev_token_type === T_CONSTANT_ENCAPSED_STRING) {
				$left_argument = substr($left_argument, 1, -1);
			}

			// Cast right argument to a string
			$right_argument = $next_token[1];
			if ($next_token_type === T_CONSTANT_ENCAPSED_STRING) {
				$right_argument = substr($right_argument, 1, -1);
			}

			// Concatenate into a single token
			$concat_result = '"' . $left_argument . $right_argument . '"';

			// Line number (PHP 5 >= 5.2.2)
			$line_number = isset($prev_token[2]) ? $prev_token[2] : 0;

			// Place result into a single token
			$this->tokens[$next_token_pos] = array(
				T_CONSTANT_ENCAPSED_STRING,
				$concat_result,
				$line_number
			);

			// Clear processed tokens
			for ($pos = $prev_token_pos; $pos < $next_token_pos; $pos++) {
				$this->tokens[$pos] = '';
			}
		}
	}

	// Indexes inclusions statements.
	function index_file_inclusions($inclusion_pos, $inc_args_pos)
	{
		// Initial token position
		$token_pos = $inclusion_pos;

		// Init loop vars
		$next_token_is_argument = false;
		$opened_parenthesis = 0; // ()

		do {
			// Search for the statement argument
			$next_token_pos = $this->next_token_pos($token_pos);
			if (false === $next_token_pos) {
				break; // no tokens left
			}

			// Extract token type
			$next_token_type = $this->get_token_type($next_token_pos);
			switch ($next_token_type) {
				case '(':
					// Ignore parenthesized statements
					$opened_parenthesis++;
					break;

				case ')':
					$opened_parenthesis--;
					break;

				case T_STRING:
				case T_VARIABLE:
				default:
					// Indexing statement argument
					$inc_args_pos = $next_token_pos;
					$next_token_is_argument = true;
			}

			// Argument is detected and parenthesis is closed
			if ($next_token_is_argument && $opened_parenthesis <= 0) {
				break;
			}

			$token_pos = $next_token_pos;
		} while ($next_token_pos);

		// Save if var dest pos is set
		if (null !== $inc_args_pos) {
			$this->file_inclusions[$inclusion_pos] = $inc_args_pos;
		}

		return $next_token_pos;
	}

	// Indexes functions calls.
	function index_function_calls($func_call_pos, $func_args_pos)
	{
		// Init token positions and values
		$prev_token_pos = $func_call_pos;
		$prev_token = $this->get_token_content($prev_token_pos);
		$token_pos = $func_args_pos;
		$token = $this->get_token_content($token_pos);

		// Init loop vars
		$function_arguments = array();
		$next_token_is_argument = (bool) (null !== $func_call_pos);
		$opened_brackets = 0; // []
		$opened_parenthesis = 0; // ()

		do {
			// Search for the next argument
			$next_token_pos = $this->next_token_pos($token_pos);
			if (false === $next_token_pos) {
				break; // no tokens left
			}

			// Extract token value
			$next_token = $this->get_token_content($next_token_pos);
			switch ($next_token) {
				case '@':
					// Ignore error control operator
					break;

				case '.':
				case '=':
				case '?':
				case ':':
					// Skip concatenations, assigments and ternary operators (?:)
					$next_token_is_argument = false;
					break;

				case ',':
					$next_token_is_argument = true;
					break;

				case '[':
					$opened_brackets++;
					break;

				case ']':
					$opened_brackets--;
					break;

				case '(':
					// Handle parenthesized parameters, e.g. func(($param),'');
					if ('(' !== $token && '?' !== $token && ':' !== $token) {
						$next_token_pos = $this->index_function_calls($token_pos, $next_token_pos);
					}
					$opened_parenthesis++;
					break;

				case ')':
					$opened_parenthesis--;
					break;

				default:
					if (!$opened_parenthesis) {
						// Indexing function arguments
						if ($next_token_is_argument) {
							$function_arguments[] = $next_token_pos;
							$next_token_is_argument = false;
						}
					}
			}

			// Exit if brackets or parenthesis are closed
			if ($opened_brackets < 0 || $opened_parenthesis < 0) {
				break;
			}

			$prev_token_pos = $token_pos;
			$prev_token = $token;

			$token_pos = $next_token_pos;
			$token = $next_token;
		} while ($next_token_pos);

		// Save if prev token set
		if (null !== $func_call_pos) {
			$this->function_calls[$func_call_pos] = $function_arguments;
			return $func_args_pos + 1;
		}

		return $next_token_pos;
	}

	// Indexes functions calls.
	function index_variable_assigns($var_dest_pos, $var_source_pos)
	{
		// Initial token position
		$token_pos = $var_source_pos;

		// Init loop vars
		$next_token_is_source = false;
		$opened_parenthesis = 0; // ()

		do {
			// Search for the assigment source
			$next_token_pos = $this->next_token_pos($token_pos);
			if (false === $next_token_pos) {
				break; // no tokens left
			}

			// Extract token type
			$next_token_type = $this->get_token_type($next_token_pos);
			switch ($next_token_type) {
				case '@':
					// Ignore error control operator
					break;

				case '(':
					// Ignore parenthesized expressions like $var = ('value');
					$opened_parenthesis++;
					break;

				case ')':
					$opened_parenthesis--;
					break;

				case T_STRING:
				case T_VARIABLE:
				default:
					// Indexing function arguments
					$var_source_pos = $next_token_pos;
					$next_token_is_source = true;
			}

			// Source is detected and parenthesis is closed
			if ($next_token_is_source && $opened_parenthesis <= 0) {
				break;
			}

			$token_pos = $next_token_pos;
		} while ($next_token_pos);

		// Save if var dest pos is set
		if (null !== $var_dest_pos) {
			$this->variable_assigns[$var_dest_pos] = $var_source_pos;
		}

		return $next_token_pos;
	}

	// Parses variables and functions.
	// @todo Improve function processing, arguments counting etc
	function index_func_and_var_tokens()
	{
		$next_token_pos = 0;
		foreach ($this->tokens as $token_pos => $token) {
			// Skip already processed tokens
			if ($token_pos < $next_token_pos) {
				continue;
			}

			// Get token type
			$token_type = is_array($token) ? $token[0] : $token;
			switch ($token_type) {
				case '=':
				case T_AND_EQUAL:
				case T_CONCAT_EQUAL:
				case T_DIV_EQUAL:
				case T_MINUS_EQUAL:
				case T_MOD_EQUAL:
				case T_MUL_EQUAL:
				case T_OR_EQUAL:
				case T_PLUS_EQUAL:
				case T_POW_EQUAL:
				case T_SL_EQUAL:
				case T_SR_EQUAL:
				case T_XOR_EQUAL:
					// Indexing variable assigns and assignment operators
					$prev_token_pos = $this->prev_token_pos($token_pos);
					$next_token_pos = $this->index_variable_assigns($prev_token_pos, $token_pos);
					break;

				case T_INCLUDE_ONCE:
				case T_INCLUDE:
				case T_REQUIRE_ONCE:
				case T_REQUIRE:
					// Indexing file inclusions
					$prev_token_pos = $this->prev_token_pos($token_pos);
					$next_token_pos = $this->index_file_inclusions($token_pos, $token_pos);
					break;

				case '(':
					// Indexing function calls
					$prev_token_pos = $this->prev_token_pos($token_pos);
					$prev_token_type = $this->get_token_type($prev_token_pos);
					if ($prev_token_type === T_STRING || $prev_token_type === T_VARIABLE) {
						$next_token_pos = $this->index_function_calls($prev_token_pos, $token_pos);
					}
					break;
			}
		}
	}

	// Removes comments from a tokenized PHP source.
	function remove_php_comments()
	{
		foreach ($this->tokens as $token_pos => $token) {
			if (is_array($token)) {
				$token_type = $token[0];
				if ($token_type === T_COMMENT || $token_type === T_DOC_COMMENT || $token_type === T_ML_COMMENT) {
					$this->tokens[$token_pos] = '';
				}
			}
		}
	}

	// Removes whitespaces from a tokenized PHP source.
	function remove_whitespaces()
	{
		foreach ($this->tokens as $token_pos => $token) {
			if (is_array($token) && $token[0] === T_WHITESPACE) {
				$this->tokens[$token_pos] = '';
			}
		}
	}

	/**
	 * Retrieve the next token position in the array of tokens.
	 *
	 * @param int $position The position in the token array
	 * @param int $modifier The token to get (Defaults to 1, for the previous token)
	 * @return false|int
	 *
	 * @access protected
	 */
	function next_token_pos($position, $modifier = 1)
	{
		while (isset($this->tokens[$position + $modifier])) {
			$next_token = $this->tokens[$position + $modifier];

			// If the requested token is a T_WHITESPACE token, add 1 to the modifer
			if ($next_token === '' || (is_array($next_token) && $next_token[0] === T_WHITESPACE)) {
				$modifier++;
			} else {
				return $position + $modifier;
			}
		}

		// No tokens left
		return false;
	}

	/**
	 * Retrieve the previous token position in the array of tokens
	 *
	 * @param int $position The position in the token array
	 * @param int $modifier The token to get (Defaults to 1, for the previous token)
	 * @return false|int
	 *
	 * @access protected
	 */
	function prev_token_pos($position, $modifier = 1)
	{
		while (isset($this->tokens[$position - $modifier])) {
			$prev_token = $this->tokens[$position - $modifier];

			// If the requested token is a T_WHITESPACE token, add 1 to the modifer
			if ($prev_token === '' || (is_array($prev_token) && $prev_token[0] === T_WHITESPACE)) {
				$modifier++;
			} else {
				return $position - $modifier;
			}
		}

		// No tokens left
		return false;
	}

	/**
	 * Retrieves the token from the array of tokens.
	 *
	 * @param int $position The position in the token array
	 * @return mixed
	 *
	 * @access protected
	 */
	function get_token($position)
	{
		// No tokens left?
		if (!$position || !isset($this->tokens[$position])) {
			return false;
		}

		return $this->tokens[$position];
	}

	/**
	 * Retrieve the token type from the array of tokens.
	 *
	 * @param int $position The position in the token array
	 * @return mixed
	 *
	 * @access protected
	 */
	function get_token_type($position)
	{
		$token = $this->get_token($position);
		return is_array($token) ? $token[0] : $token;
	}

	/**
	 * Retrieve the token content from the array of tokens.
	 *
	 * @param int $position The position in the token array
	 * @return mixed
	 *
	 * @access protected
	 */
	function get_token_content($position)
	{
		$token = $this->get_token($position);
		return is_array($token) ? $token[1] : $token;
	}

	/**
	 * Retrieve the next token from the array of tokens.
	 *
	 * @param int $position The current position in the token array
	 * @return mixed
	 *
	 * @access protected
	 */
	function next_token($position)
	{
		$next_token_pos = $this->next_token_pos($position);
		return $this->get_token_type($next_token_pos);
	}

	/**
	 * Retrieve the previous token from the array of tokens
	 *
	 * @param int $position The position in the token array
	 * @param int $modifier The token to get (Defaults to 1, for the previous token)
	 * @return int
	 *
	 * @access protected
	 */
	function prev_token($position)
	{
		$prev_token_pos = $this->prev_token_pos($position);
		return $this->get_token_type($prev_token_pos);
	}

}

class CwisSecRipsScan
{

	var $analyser;
	// main
	var $file_name;
	var $scan_functions;
	var $info_functions;
	var $source_functions;
	// vars
	var $var_declares_global = array();
	var $globals_from_function = array();
	// classes
	var $in_class = false;
	var $class_name = '';
	var $vuln_classes = array();
	var $class_vars = array();
	var $brace_save_class;
	// funcs
	var $in_function = 0;
	var $brace_save_func = -1;
	var $function_obj = null;
	var $var_declares_local = array();
	var $put_in_global_scope = array();
	// params
	var $in_condition = 0;
	var $braces_open = 0;
	var $ignore_requirement = false;
	var $dependencies = array();
	var $dependencytokens = array();
	// sec
	var $securedby = array();
	var $ignore_securing_function = false;
	var $userfunction_secures = false;
	var $userfunction_taints = false;
	var $comment = '';
	// info
	var $inc_file_stack = array();
	var $inc_map = array();
	var $include_paths = array();
	var $file_pointer = '';
	var $lines_stack = array();
	var $lines_pointer = '';
	var $tif = 0; // tokennr in file
	var $tif_stack = array();
	// tokens
	var $tokens = array();
	// ex-global vars
	var $count_inc = 0;
	var $count_inc_fail = 0;
	var $file_sinks_count = array();
	var $files = array();
	var $result_info = array();
	var $result_output = array();
	var $user_functions = array();
	var $user_functions_offset = array();
	var $user_input = array();
	var $verbosity = 1;

	function __construct($file_name, $file_contents, $scan_functions, $info_functions, $source_functions)
	{
		$this->analyser = new CwisSecAnalyzer();

		$this->file_name = $file_name;
		$this->scan_functions = $scan_functions;
		$this->info_functions = $info_functions;
		$this->source_functions = $source_functions;

		$this->inc_file_stack = array(realpath($this->file_name));
		$this->include_paths = functions_exists('ini_get') ? $this->analyser->get_ini_paths(ini_get("include_path")) : array();
		$this->file_pointer = end($this->inc_file_stack);
		if (!isset($this->file_sinks_count[$this->file_pointer])) {
			$this->file_sinks_count[$this->file_pointer] = 0;
		}
		if ($file_contents) { //use file contents, if possible
			$this->lines_stack[] = explode("\n", str_replace(array("\r\n", "\r"), "\n", $file_contents));
		} else {
			$this->lines_stack[] = file($this->file_name);
		}
		$this->lines_pointer = end($this->lines_stack);
		$this->user_functions_offset['__main__'] = array();

		// preload output
		/* echo $GLOBALS['fit'] . '|' . $GLOBALS['file_amount'] . '|' . $this->file_pointer . ' (tokenizing)|' . $GLOBALS['timeleft'] . '|' . "\n";
		  @ob_flush();
		  flush(); */

		// tokenizing
		$tokenizer = new CwisSecTokenizer($this->file_pointer);
		$this->tokens = $tokenizer->tokenize(implode($file_contents ? "\n" : '', $this->lines_pointer));
		unset($tokenizer);

		// add auto includes from php.ini
		/* if (ini_get('auto_prepend_file')) {
		  $this->add_auto_include(ini_get('auto_prepend_file'), true);
		  }
		  if (ini_get('auto_append_file')) {
		  $this->add_auto_include(ini_get('auto_append_file'), false);
		  } */
	}

	// create require tokens for auto_prepend/append_files and add to tokenlist
	function add_auto_include($path, $beginning = false)
	{
		$paths = $this->analyser->get_ini_paths($path);
		$addtokens = array();
		foreach ($paths as $file) {
			$includetokens = array(
				array(T_REQUIRE, 'require', 0),
				array(T_CONSTANT_ENCAPSED_STRING, "'$file'", 0),
				';'
			);
			$addtokens = array_merge($addtokens, $includetokens);
		}
		if ($beginning) {
			$this->tokens = array_merge($addtokens, $this->tokens);
		} else {
			$this->tokens = array_merge($this->tokens, $addtokens);
		}
	}

	// traces recursivly parameters and adds them as child to parent
	// returns true if a parameter is tainted by userinput (1=directly tainted, 2=function param)
	function scan_parameter($mainparent, $parent, $var_token, $var_keys = array(), $last_token_id = 0, $var_declares = array(), $var_declares_global = array(), $userinput = false, $F_SECURES = array(), $return_scan = false, $ignore_securing = false, $secured = false)
	{
		#print_r(func_get_args());echo "\n----------------\n";
		$vardependent = false;

		$var_name = $var_token[1];
		// constants
		if ($var_name[0] !== '$') {
			$var_name = strtoupper($var_name);
		}
		// variables
		else {
			// reconstruct array key values $a[$b]
			if (isset($var_token[3])) {
				for ($k = 0; $k < count($var_token[3]); $k++) {
					if (is_array($var_token[3][$k])) {
						$var_token[3][$k] = $this->analyser->get_tokens_value(
								$this->file_pointer, $var_token[3][$k], $var_declares, $var_declares_global, $last_token_id
						);
					}
				}
			}

			// handle $GLOBALS and $_SESSIONS
			if (isset($var_token[3])) {
				if ($var_name == '$GLOBALS' && !isset($var_declares[$var_name]) && !empty($var_token[3][0])) {
					$var_name = '$' . str_replace(array("'", '"'), '', $var_token[3][0]);
					// php $GLOBALS: ignore previous local vars and take only global vars
					$var_declares = $var_declares_global;
				} else if ($var_name === '$_SESSION' && !isset($var_declares[$var_name]) && !empty($var_declares_global)) {
					// $_SESSION data is handled as global variables
					$var_declares = array_merge($var_declares_global, $var_declares);
				}
			}

			// if a register_globals implementation is present shift it to the beginning of the var_declare array
			if (isset($var_declares['register_globals']) && !in_array($var_name, CwisSecSources::$V_USERINPUT) && (!$this->in_function || in_array($var_name,
																																		  $this->put_in_global_scope))) {
				if (!isset($var_declares[$var_name])) {
					$var_declares[$var_name] = $var_declares['register_globals'];
				} else {
					foreach ($var_declares['register_globals'] as $glob_obj) {
						if ($glob_obj->id < $last_token_id) {
							$var_declares[$var_name][] = $glob_obj;
						}
					}
				}
			}
		}

		// check if var declaration could be found for this var
		// and if the latest var_declares id is smaller than the last_token_id, otherwise continue with function parameters
		#echo "trying: $var_name, isset: ".(int)(isset($var_declares[$var_name])).", ".end($var_declares[$var_name])->id." < ".$last_token_id."?\n";
		if (isset($var_declares[$var_name]) && (end($var_declares[$var_name])->id < $last_token_id || $userinput)) {
			foreach ($var_declares[$var_name] as $var_declare) {
				// check if array keys are the same (if it is an array)
				$array_key_diff = array();
				if (!empty($var_token[3]) && !empty($var_declare->array_keys)) {
					$array_key_diff = array_diff_assoc($var_token[3], $var_declare->array_keys);
				}

				#print_r($var_declares[$var_name]);
				#echo "<br>var:".$var_name; echo " varkeys:";print_r($var_token[3]); echo " declarekeys:";print_r($var_declare->array_keys); echo " diff:"; print_r($array_key_diff); echo " |||";
				#if(!empty($var_declare->array_keys)) die(print_r($var_declare->array_keys) . print_r($var_keys));

				if ($var_declare->id < $last_token_id && (empty($array_key_diff) || in_array('*', $array_key_diff) || in_array('*',
																												   $var_declare->array_keys)) /* && (empty($var_declare->array_keys) || empty($var_keys) || $var_declare->array_keys == $var_keys || in_array('*', $var_keys) || in_array('*', $array_key_diff) || in_array('*', $var_declare->array_keys) ) */) {
					$comment = '';
					// add line to output
					if (count($mainparent->lines) < MAXTRACE) {
						$clean_vars_before_ifelse = false;
						// add same var_name with different dependencies
						if (!empty($var_declare->dependencies) && $mainparent->dependencies != $var_declare->dependencies) {
							foreach ($var_declare->dependencies as $deplinenr => $dependency) {
								if (!isset($mainparent->dependencies[$deplinenr]) && $deplinenr != $var_declare->line) {
									$vardependent = true;
									$comment .= $this->tokens_to_string($dependency) . ', ';
									// if dependencie has an ELSE clause, same vars before are definetely overwritten
									if ($dependency[count($dependency) - 1][0] === T_ELSE) {
										$clean_vars_before_ifelse = true;
									}
								}
							}
						}

						// stop at var declarations before if else statement. they are overwritten
						if ($clean_vars_before_ifelse) {
							for ($c = 0; $c < count($var_declares[$var_name]); $c++) {
								if (count($var_declares[$var_name][$c]->dependencies) < count($var_declare->dependencies)) {
									if (isset($var_declares[$var_name][$c - 1])) {
										$var_declares[$var_name][$c - 1]->stopvar = true;
									}
									break;
								}
							}
						}

						$mainparent->lines[] = $var_declare->line;
						$var_trace = new CwisSecVarDeclare('');
						$parent->children[] = $var_trace;
					} else {
						$stop = new CwisSecVarDeclare('... Trace stopped.');
						$parent->children[] = $stop;
						return $userinput;
					}

					// find other variables in this line
					$tokens = $var_declare->tokens;
					//$last_scanned = '';
					$last_userinput = false;
					$in_arithmetic = false;
					$in_securing = false;
					$parentheses_open = 0;
					$parentheses_save = -1;

					$tainted_vars = array();
					$var_count = 1;

					for ($i = $var_declare->tokenscanstart; $i < $var_declare->tokenscanstop; $i++) {
						if (!isset($tokens[$i])) {
							continue;
						}

						$this_one_is_secure = false;
						if (is_array($tokens[$i])) {
							// if token is variable or constant
							if (isset($tokens[$i + 1]) &&
									(($tokens[$i][0] === T_VARIABLE && $tokens[$i + 1][0] !== T_OBJECT_OPERATOR) ||
									($tokens[$i][0] === T_STRING && $tokens[$i + 1] !== '('))) {
								$var_count++;

								// check if typecasted
								if ((isset($tokens[$i - 1]) && is_array($tokens[$i - 1]) &&
										in_array($tokens[$i - 1][0], CwisSecTokens::$T_CASTS)) ||
										(is_array($tokens[$i + 1]) && in_array($tokens[$i + 1][0], CwisSecTokens::$T_ARITHMETIC))) {
									// mark user function as a securing user function
									$this->userfunction_secures = true;
									$this_one_is_secure = true;

									$var_trace->marker = 2;
								}

								// check for automatic typecasts by arithmetic
								if ((isset($tokens[$i - 1]) && in_array($tokens[$i - 1], CwisSecTokens::$S_ARITHMETIC)) ||
										in_array($tokens[$i + 1], CwisSecTokens::$S_ARITHMETIC)) {
									// mark user function as a securing user function
									$this->userfunction_secures = true;

									$in_arithmetic = true;

									$var_trace->marker = 2;
								}

								// scan in global scope
								$userinput = $this->scan_parameter(
										$mainparent, $var_trace, $tokens[$i], $var_keys, $var_declare->id,
		  ((isset($tokens[$i - 1]) && is_array($tokens[$i - 1]) &&
										$tokens[$i - 1][0] === T_GLOBAL) || $tokens[$i][1][0] !== '$') ?
										$var_declares_global : $var_declares, // global or local scope
										 $var_declares_global, $userinput, $F_SECURES, $return_scan, $ignore_securing,
										 ($this_one_is_secure || $in_securing || $in_arithmetic)
								);

								// consider securing applied to parent variable
								if ($secured && $this->verbosity < 3 && !$last_userinput) {
									$userinput = false;
								}

								// add tainted variable to the list to get them highlighted in output
								if ($userinput && !$last_userinput) {
									$tainted_vars[] = $var_count;
								}
							}
							// if in foreach($bla as $key=>$value) dont trace $key, $value back
							else if ($tokens[$i][0] === T_AS) {
								break;
							}
							// also check for userinput from functions returning userinput
							else if (in_array($tokens[$i][1], $this->source_functions)) {
								$userinput = true;
								$var_trace->marker = 4;
								$mainparent->title = 'Userinput returned by function <i>' . $tokens[$i][1] . '()</i> reaches sensitive sink.';

								if ($return_scan) {
									$this->userfunction_taints = true;
								}
								// userinput received in function, just needs a trigger
								else if ($this->in_function) {
									$this->add_trigger_function($mainparent);
								}

								// we could return here to not scan all parameters of the tainting function
								// however we would need to add the line manually to the output here
							}
							// detect securing functions
							else if (!$ignore_securing && ( (is_array($F_SECURES) && in_array($tokens[$i][1], $F_SECURES)) || (isset($tokens[$i][1]) && in_array($tokens[$i][1],
																																			CwisSecSecuring::$F_SECURING_STRING)) || (in_array($tokens[$i][0],
																					  CwisSecTokens::$T_CASTS) && $tokens[$i + 1] === '(') )) {
								$parentheses_save = $parentheses_open;
								$in_securing = true;
								$this->securedby[] = $tokens[$i][1];
							}
							//detect insecuring functions (functions that make previous securing useless)
							else if (isset($tokens[$i][1]) && in_array($tokens[$i][1], CwisSecSecuring::$F_INSECURING_STRING)) {
								$parentheses_save = $parentheses_open;
								$ignore_securing = true;
							}
							// if this is a vuln line, it has already been scanned -> return
							else if (((in_array($tokens[$i][0], CwisSecTokens::$T_FUNCTIONS) &&
									isset($this->scan_functions[$tokens[$i][1]])) ||
									isset(CwisSecInfo::$F_INTEREST[$tokens[$i][1]]))
									// ignore oftenly used preg_replace() and alike
									&& !isset(CwisSecSinks::$F_CODE[$tokens[$i][1]]) &&
									!isset(CwisSecSinks::$F_REFLECTION[$tokens[$i][1]]) &&
									!isset(CwisSecSinks::$F_OTHER[$tokens[$i][1]])) {
								$var_trace->value = $this->highlightline($tokens, $comment . $var_declare->comment . ', trace stopped',
												 $var_declare->line);
								$var_trace->line = $var_declare->line;
								return $userinput;
							}
							// check for automatic typecasts by arithmetic assignment
							else if (in_array($tokens[$i][0], CwisSecTokens::$T_ASSIGNMENT_SECURE)) {
								// mark user function as a securing user function
								$this->userfunction_secures = true;
								$secured = 'arithmetic assignment';

								$userinput = false; // first variable before operator has alread been traced, ignore
								$var_trace->marker = 2;
							}
							// func_get_args()
							else if ($tokens[$i][1] === 'func_get_args' && $this->in_function && $tokens[$i][0] === T_STRING) {
								$this->add_function_dependend($mainparent, $parent, $return_scan, -1);
								$userinput = 2;
							}
							// func_get_arg()
							else if ($tokens[$i][1] === 'func_get_arg' && $this->in_function && $tokens[$i][0] === T_STRING) {
								$this->add_function_dependend($mainparent, $parent, $return_scan, $tokens[$i + 2][1]);
								$userinput = 2;
							}
						}
						// string concat disables arithmetic
						else if ($tokens[$i] === '.') {
							$in_arithmetic = false;
						}
						// watch opening parentheses
						else if ($tokens[$i] === '(') {
							$parentheses_open++;
						}
						// watch closing parentheses
						else if ($tokens[$i] === ')') {
							$parentheses_open--;
							if ($parentheses_open === $parentheses_save) {
								$parentheses_save = -1;
								$in_securing = false;
								$ignore_securing = false;
							}
						}

						// save userinput (true|false) for vars in same line
						$last_userinput = $userinput;
					}

					// add highlighted line to output, mark tainted vars
					$var_trace->value = $this->highlightline($tokens, $var_declare->comment . $comment, $var_declare->line, false,
											  false, $tainted_vars);
					$var_trace->line = $var_declare->line;

					// we only need the last var declaration, other declarations have been overwritten
					// exception: if elseif statements:
					// if else at least overwrites vars before if else statement (else always triggers)
					if (($userinput || !$vardependent || $var_declare->stopvar) && !in_array('*', $array_key_diff)) {
						break;
					}
				}
			}
		}
		// if var comes from function parameter AND has not been overwritten with static content before (else)
		else if ($this->in_function && in_array($var_name, $this->function_obj->parameters) &&
				($this->verbosity >= 3 || empty($secured))) {
			$key = array_search($var_name, $this->function_obj->parameters);
			$this->add_function_dependend($mainparent, $parent, $return_scan, $key);
			$userinput = 2;
		}
		// register globals
		else if (SCAN_REGISTER_GLOBALS && $var_token[0] === T_VARIABLE &&
				!in_array($var_name, CwisSecSources::$V_USERINPUT) &&
				(!$this->in_function || (in_array($var_name, $this->put_in_global_scope) &&
				!in_array($var_name, $this->function_obj->parameters))) && empty($secured)) {
			// add highlighted line to output, mark tainted vars
			$var_trace = new CwisSecVarDeclare('');
			$parent->children[] = $var_trace;
			$var_trace->value = $this->highlightline(array(array(T_VARIABLE, $var_name, 0), array(T_CONSTANT_ENCAPSED_STRING,
					' is not initialized and ' . PHPDOC . 'register_globals is enabled',
					0)), $var_declare->comment . $comment, 0, false, false, $tainted_vars);
			$var_trace->line = 0;
			$var_trace->marker = 1;
			$userinput = true;
			$this->add_exploit_parameter($mainparent, '$_GET', str_replace('$', '', $var_name));
		}


		// if var is userinput, return true directly
		if (in_array($var_name, CwisSecSources::$V_USERINPUT) && empty($secured)) {
			// check if userinput variable has been overwritten
			$overwritten = false;
			if (isset($var_declares[$var_name])) {
				foreach ($var_declares[$var_name] as $var) {
					// check if array keys are the same (if it is an array)
					$array_key_diff = false;
					if (isset($var_token[3]) && !empty($var_declare->array_keys)) {
						$array_key_diff = array_diff_assoc($var_token[3], $var_declare->array_keys);
					}

					// if there is a var declare for this userinput !except the same line!: overwritten
					if ($last_token_id != $var->id && !$array_key_diff) {
						$overwritten = true;
					}
				}
			}

			if (!$overwritten) {
				// add userinput markers to mainparent object
				if (isset($var_token[3])) {
					$parameter_name = str_replace(array("'", '"'), '', $var_token[3][0]);
				} else {
					$parameter_name = 'x';
				}

				// mark tainted, but only specific $_SERVER parameters
				if ($var_name !== '$_SERVER' || in_array($parameter_name, CwisSecSources::$V_SERVER_PARAMS) || substr($parameter_name,
																										  0, 5) === 'HTTP_') {
					$userinput = true;
					$parent->marker = 1;

					$this->add_exploit_parameter($mainparent, $var_name, $parameter_name);

					// analyse depencies for userinput and add it for exploit creator
					if (!empty($mainparent->dependencies)) {
						foreach ($mainparent->dependencies as $dtokens) {
							for ($t = 0; $t < count($dtokens); $t++) {
								if (isset($dtokens[$t][3]) && $dtokens[$t][0] === T_VARIABLE &&
										in_array($dtokens[$t][1], CwisSecSources::$V_USERINPUT) &&
										($dtokens[$t][1] !== '$_SERVER' ||
										in_array($dtokens[$t][3][0], CwisSecSources::$V_SERVER_PARAMS) ||
										substr($dtokens[$t][3][0], 0, 5) === 'HTTP_')) {
									$this->add_exploit_parameter($mainparent, $dtokens[$t][1], str_replace(array('"', "'"), '', $dtokens[$t][3][0]));
								}
							}
						}
					}
				}

				// userinput received in function, just needs a trigger
				if ($this->in_function && !$return_scan) {
					$this->add_trigger_function($mainparent);
				}
			}
		}

		return $userinput;
	}

	// add exploit parameter to parent
	function add_exploit_parameter($parent, $type, $parameter_name)
	{
		if (!empty($parameter_name)) {
			switch ($type) {
				case '$_GET':
				case '$_REQUEST':
				case '$HTTP_GET_VARS':
				case '$HTTP_REQUEST_VARS':
					$parent->get[] = $parameter_name;
					break;

				case '$_POST':
				case '$HTTP_POST_VARS':
				case '$HTTP_RAW_POST_DATA':
					$parent->post[] = $parameter_name;
					break;

				case '$_COOKIE':
				case '$HTTP_COOKIE_VARS':
					$parent->cookie[] = $parameter_name;
					break;

				case '$_FILES':
				case '$HTTP_POST_FILES':
					$parent->files[] = $parameter_name;
					break;

				case '$_SERVER':
					$parent->server[] = $parameter_name;
					break;
			}
		}
	}

	// add function to output that triggers something by call
	function add_trigger_function($mainparent)
	{
		// add dependency and mark this as interesting function
		$mainparent->dependencies[$this->function_obj->lines[0]] = $this->function_obj->tokens;
		$mainparent->title = "Userinput reaches sensitive sink when function <i>{$this->function_obj->name}()</i> is called.";

		// add function to scanlist
		$mainparent->funcdepend = $this->function_obj->name;
		// with all parameters as valuable since userinput comes from inside the func
		$this->user_functions[$this->file_name][$this->function_obj->name][0][0] = 0;
		// no securings
		$this->user_functions[$this->file_name][$this->function_obj->name][1] = array();
		// doesnt matter if called with userinput or not
		$this->user_functions[$this->file_name][$this->function_obj->name][3] = true;
	}

	// add function declaration to parent and mark the block as dependend of this function calls
	function add_function_dependend($mainparent, $parent, $return_scan, $key)
	{
		// add child with function declaration
		$func_name = $this->function_obj->name;
		$mainparent->lines[] = $this->function_obj->lines[0];
		if ($this->function_obj->marker !== 3) {
			$this->function_obj->value = $this->highlightline($this->function_obj->tokens, '', $this->function_obj->lines[0]);
			// mark as potential userinput
			$this->function_obj->marker = 3;
		}
		$parent->children[] = $this->function_obj;

		// add function to scanlist
		if (!$return_scan) {
			$mainparent->funcdepend = $func_name;
			// $mainparent->funcdependparam != $this->user_functions[$this->file_name][$func_name][0]
			$mainparent->funcparamdepend[] = $key + 1;

			$user_function = & $this->user_functions[$this->file_name][$func_name];
			// with potential parameters
			$map = $key < 0 ? 0 : $key;
			// scan this userfunction with the vuln parameter
			$user_function[0][$map] = $key + 1;
			// and with according securing functions from original find
			$user_function[1] = isset($this->scan_functions[$mainparent->name][1]) ?
					$this->scan_functions[$mainparent->name][1] : $this->user_functions[$this->file_name][$mainparent->name][1];

			//CWIS// support for static params
			$user_function[1] = CwisSecSecuring::get_prop($user_function[1]);
		}
	}

	// add a variable to the varlist
	function variable_add($var_name, $tokens, $comment = '', $tokenscanstart = 0, $tokenscanstop = 0, $linenr = 0, $id = 0, $array_keys = array(), $additional_keys = array())
	{
		// add variable declaration to beginning of varlist
		$new_var = new CwisSecVarDeclare($tokens, $this->comment . $comment);
		$new_var->line = $linenr;
		$new_var->id = $id;

		if ($tokenscanstart) {
			$new_var->tokenscanstart = $tokenscanstart;
		}
		if ($tokenscanstop) {
			$new_var->tokenscanstop = $tokenscanstop;
		}

		// add dependencies
		foreach ($this->dependencies as $deplinenr => $dependency) {
			if (!empty($dependency)) {
				$new_var->dependencies[$deplinenr] = $dependency;
			}
		}

		// if $GLOBALS['x'] is used outside a function its the same as using var $x, rewrite
		if ($var_name === '$GLOBALS' && !empty($array_keys) && !$this->in_function) {
			$var_name = '$' . array_shift($array_keys);
		}

		// add additional array keys
		if (!empty($additional_keys)) {
			if (empty($array_keys)) {
				$array_keys[] = $additional_keys;
			} else {
				$array_keys = array_merge($array_keys, array($additional_keys));
			}
		}

		// add/resolve array keys
		if (!empty($array_keys)) {
			foreach ($array_keys as $key) {
				if (!is_array($key)) {
					$new_var->array_keys[] = $key;
				} else {
					$recstring = $this->analyser->get_tokens_value(
							$this->file_pointer, $key, $this->in_function ? $this->var_declares_local : $this->var_declares_global,
	   $this->var_declares_global, $id
					);

					if (!empty($recstring)) {
						$new_var->array_keys[] = $recstring;
					} else {
						$new_var->array_keys[] = '*';
					}
				}
			}
		}

		// parse tokens before update
		$t_parser = new CwisSecParser();
		$t_parser->set_file_name($this->file_name);
		$t_parser->set_tokens($new_var->tokens);
		$t_parser->evaluate_expressions();
		$t_parser->parse_concatenations($this->var_declares_global, $id);
		$t_parser->evaluate_functions();
		$t_parser->parse_concatenations($this->var_declares_global, $id);
		$new_var->tokens = $t_parser->get_tokens(true);

		// update var declarations
		if ($this->in_function) {
			if (!isset($this->var_declares_local[$var_name])) {
				$this->var_declares_local[$var_name] = array($new_var);
			} else {
				array_unshift($this->var_declares_local[$var_name], $new_var);
			}

			// if variable was put in global scope, save assignments
			// later they will be pushed to the global var list when function is called
			if (in_array($var_name, $this->put_in_global_scope)) {
				if (!isset($this->globals_from_function[$this->function_obj->name][$var_name])) {
					$this->globals_from_function[$this->function_obj->name][$var_name] = array($new_var);
				} else {
					array_unshift($this->globals_from_function[$this->function_obj->name][$var_name], $new_var);
				}
			}
		} else {
			if (!isset($this->var_declares_global[$var_name])) {
				$this->var_declares_global[$var_name] = array($new_var);
			} else {
				array_unshift($this->var_declares_global[$var_name], $new_var);
			}
		}
	}

	// scans variable for $$dynamic vars or $dynamic() function calls
	function variable_scan($i, $offset, $category, $title)
	{
		if (isset($this->scan_functions[$category])) {
			// build new find
			$new_find = new CwisSecVulnTreeNode();
			$new_find->name = $category;
			$new_find->lines[] = $this->tokens[$i][2];

			// count sinks
			$this->file_sinks_count[$this->file_pointer] ++;

			if ($this->in_function) {
				if (!isset($this->user_functions_offset[$this->function_obj->name][6])) {
					$this->user_functions_offset[$this->function_obj->name][6] = 0;
				}
				$this->user_functions_offset[$this->function_obj->name][6] ++;
			} else {
				if (!isset($this->user_functions_offset['__main__'][6])) {
					$this->user_functions_offset['__main__'][6] = 0;
				}
				$this->user_functions_offset['__main__'][6] ++;
			}

			// add dependencies
			foreach ($this->dependencies as $deplinenr => $dependency) {
				if (!empty($dependency)) {
					$new_find->dependencies[$deplinenr] = $dependency;
				}
			}

			// trace back parameters and look for userinput
			$userinput = $this->scan_parameter(
					$new_find, $new_find, $this->tokens[$i], (isset($this->tokens[$i][3]) ? $this->tokens[$i][3] : null), $i,
													 $this->in_function ? $this->var_declares_local : $this->var_declares_global, $this->var_declares_global,
													 false, array()
			);

			// add find to output if function call has variable parameters (With userinput)
			if ($userinput || $this->verbosity == 4) {
				$new_find->filename = $this->file_pointer;
				$new_find->value = $this->highlightline(array_slice($this->tokens, $i - $offset,
														$offset + 3 + $this->analyser->get_brace_end($this->tokens, $i + 2)), $this->comment,
														   $this->tokens[$i][2], $this->tokens[$i][1], false, array(1));

				// add to output
				$new_find->title = $title;
				$block = new CwisSecVulnBlock($this->tif . '_' . $this->tokens[$i][2] . '_' . basename($this->file_pointer),
																						   CwisSecSinks::getVulnNodeTitle($category), $this->tokens[$i][1]);
				$block->treenodes[] = $new_find;

				if ($userinput == 1 || $this->verbosity == 4) {
					$block->vuln = true;
					CwisSecSinks::increaseVulnCounter($category);
				}

				$this->result_output[$this->file_name][] = $block;

				if ($this->in_function) {
					$this->ignore_securing_function = true;
					// mark function in class as vuln
					if ($this->in_class) {
						$this->vuln_classes[$this->class_name][] = $this->function_obj->name;
					}
				}

				// add register_globals implementation
				if ($category === 'extract') {
					$this->variable_add(
							'register_globals',
	   array_merge(array_slice($this->tokens, $i - $offset,
							($end = $offset + 3 + $this->analyser->get_brace_end($this->tokens, $i + 2))),
															array(array(T_COMMENT,
							'// is like ',
							0), array(T_STRING, 'import_request_variables', 0), '(', ')')), 'see above', 1, $end + 2, $this->tokens[$i][2],
															$i, isset($this->tokens[$i][3]) ? $this->tokens[$i][3] : array()
					);
				}
			}
		}
	}

	// --- HELPERS ---
	// check if same vulnBlock with the same unique identifier has already been scanned
	function already_scanned($i)
	{
		$uid = $this->tif . '_' . $this->tokens[$i][2] . '_' . basename($this->file_pointer);
		foreach ($this->result_output as $file) {
			foreach ($file as $vulnBlock) {
				if ($vulnBlock->uid == $uid && $vulnBlock->vuln) {
					$vulnBlock->alternatives[] = $this->file_name;
					return true;
				}
			}
		}
		return false;
	}

	// check if securing function is listed as securing that depends on quotes
	function quote_analysis_needed()
	{
		foreach ($this->securedby as /* $var => */ $func) {
			if (in_array($func, CwisSecSecuring::$F_SECURING_SQL)) {
				return true;
			}
		}
		return false;
	}

	// tokens to string for comments
	function tokens_to_string($tokens)
	{
		$output = '';
		for ($i = 0; $i < count($tokens); $i++) {
			$token = $tokens[$i];
			if (is_string($token)) {
				if ($token === ',' || $token === ';') {
					$output .= "$token ";
				} else if (in_array($token, CwisSecTokens::$S_SPACE_WRAP) ||
						in_array($token, CwisSecTokens::$S_ARITHMETIC)) {
					$output .= " $token ";
				} else {
					$output .= $token;
				}
			} else if (in_array($token[0], CwisSecTokens::$T_SPACE_WRAP) ||
					in_array($token[0], CwisSecTokens::$T_OPERATOR) ||
					in_array($token[0], CwisSecTokens::$T_ASSIGNMENT)) {
				$output .= " {$token[1]} ";
			} else {
				$output .= $token[1];
			}
		}
		return $output;
	}

	// prepare output to style with CSS
	function highlightline($tokens = array(), $comment = '', $line_nr = 0, $title = false, $udftitle = false, $tainted_vars = array())
	{
		return $line_nr . ': ' . ($title ? $title : $udftitle); // . '&nbsp;' . tokens_to_string($tokens);

		/*
		  $reference = true;
		  $output = "<span class=\"linenr\">$line_nr:</span>&nbsp;";
		  if ($title) {
		  $output.='<a class="link" href="' . PHPDOC . $title . '" title="open php documentation" target=_blank>';
		  $output.="$title</a>&nbsp;";
		  } else if ($udftitle) {
		  $output.='<a class="link" style="text-decoration:none;" href="#' . $udftitle . '_declare" title="jump to declaration">&uArr;</a>&nbsp;';
		  }

		  $var_count = 0;

		  for ($i = 0; $i < count($tokens); $i++) {
		  $token = $tokens[$i];
		  if (is_string($token)) {
		  if ($token === ',' || $token === ';') {
		  $output .= "<span class=\"phps-code\">$token&nbsp;</span>";
		  } else if (in_array($token, CwisSecTokens::$S_SPACE_WRAP) ||
		  in_array($token, CwisSecTokens::$S_ARITHMETIC)) {
		  $output .= '<span class="phps-code">&nbsp;' . $token . '&nbsp;</span>';
		  } else {
		  $output .= '<span class="phps-code">' . htmlentities($token, ENT_QUOTES, 'utf-8') . '</span>';
		  }
		  } else if (is_array($token) && $token[0] !== T_OPEN_TAG && $token[0] !== T_CLOSE_TAG) {

		  if (in_array($token[0], CwisSecTokens::$T_SPACE_WRAP) ||
		  in_array($token[0], CwisSecTokens::$T_OPERATOR) ||
		  in_array($token[0], CwisSecTokens::$T_ASSIGNMENT)) {
		  $output.= '&nbsp;<span class="phps-' . str_replace('_', '-', strtolower(token_name($token[0]))) . "\">{$token[1]}</span>&nbsp;";
		  } else {
		  if ($token[0] === T_FUNCTION) {
		  $reference = false;
		  $funcname = $tokens[$i + 1][0] === T_STRING ? $tokens[$i + 1][1] : $tokens[$i + 2][1];
		  $output .= '<A NAME="' . $funcname . '_declare" class="jumplink"></A>';
		  $output .= '<a class="link" style="text-decoration:none;" href="#' . $funcname . '_call" title="jump to call">&dArr;</a>&nbsp;';
		  }

		  $text = htmlentities($token[1], ENT_QUOTES, 'utf-8');
		  $text = str_replace(array(' ', "\n"), '&nbsp;', $text);

		  if ($token[0] === T_FUNCTION) {
		  $text.='&nbsp;';
		  }

		  if ($token[0] === T_STRING && $reference && isset($this->user_functions_offset[strtolower($text)])) {
		  $text = @'<span onmouseover="getFuncCode(this,\'' . addslashes($this->user_functions_offset[strtolower($text)][0]) . '\',\'' . $this->user_functions_offset[strtolower($text)][1] . '\',\'' . $this->user_functions_offset[strtolower($text)][2] . '\')" style="text-decoration:underline" class="phps-' . str_replace('_',
		  '-',
		  strtolower(token_name($token[0]))) . "\">$text</span>\n";
		  } else {
		  $span = '<span ';

		  if ($token[0] === T_VARIABLE) {
		  $var_count++;
		  $cssname = str_replace('$', '', $token[1]);
		  $span.= 'style="cursor:pointer;" name="phps-var-' . $cssname . '" onClick="markVariable(\'' . $cssname . '\')" ';
		  $span.= 'onmouseover="markVariable(\'' . $cssname . '\')" onmouseout="markVariable(\'' . $cssname . '\')" ';
		  }

		  if ($token[0] === T_VARIABLE && @in_array($var_count, $tainted_vars)) {
		  $span.= "class=\"phps-tainted-var\">$text</span>";
		  } else {
		  $span.= 'class="phps-' . str_replace('_', '-', strtolower(token_name($token[0]))) . "\">$text</span>";
		  }

		  $text = $span;

		  // rebuild array keys
		  if (isset($token[3])) {
		  foreach ($token[3] as $key) {
		  if ($key != '*') {
		  $text .= '<span class="phps-code">[</span>';
		  if (!is_array($key)) {
		  if (is_numeric($key)) {
		  $text .= '<span class="phps-t-lnumber">' . $key . '</span>';
		  } else {
		  $text .= '<span class="phps-t-constant-encapsed-string">\'' . htmlentities($key,
		  ENT_QUOTES,
		  'utf-8') . '\'</span>';
		  }
		  } else {
		  foreach ($key as $token) {
		  if (is_array($token)) {
		  $text .= '<span ';

		  if ($token[0] === T_VARIABLE) {
		  $cssname = str_replace('$', '', $token[1]);
		  $text.= 'style="cursor:pointer;" name="phps-var-' . $cssname . '" onClick="markVariable(\'' . $cssname . '\')" ';
		  $text.= 'onmouseover="markVariable(\'' . $cssname . '\')" onmouseout="markVariable(\'' . $cssname . '\')" ';
		  }

		  $text .= 'class="phps-' . str_replace('_', '-',
		  strtolower(token_name($token[0]))) . '">' . htmlentities($token[1],
		  ENT_QUOTES,
		  'utf-8') . '</span>';
		  } else {
		  $text .= "<span class=\"phps-code\">{$token}</span>";
		  }
		  }
		  }
		  $text .= '<span class="phps-code">]</span>';
		  }
		  }
		  }
		  }
		  $output .= $text;
		  if (is_array($token) && (in_array($token[0], CwisSecTokens::$T_INCLUDES) ||
		  in_array($token[0], CwisSecTokens::$T_XSS) || $token[0] === 'T_EVAL')) {
		  $output .= '&nbsp;';
		  }
		  }
		  }
		  }

		  if (!empty($comment)) {
		  $output .= '&nbsp;<span class="phps-t-comment">// ' . htmlentities($comment, ENT_QUOTES, 'utf-8') . '</span>';
		  }

		  return $output;
		 */
	}

	// parse tokens of php file, build program model, follow program flow, initiate taint analysis
	function parse()
	{
		// scan all tokens
		for ($i = 0, $tokencount = count($this->tokens); $i < $tokencount; $i++, $this->tif++) {
			if (is_array($this->tokens[$i])) {
				$token_name = $this->tokens[$i][0];
				$token_value = $this->tokens[$i][1];
				$line_nr = $this->tokens[$i][2];

				// add preloader info for big files
				/* if ($line_nr % PRELOAD_SHOW_LINE == 0) {
				  echo $GLOBALS['fit'] . '|' . $GLOBALS['file_amount'] . '|' . $this->file_pointer . ' (line ' . $line_nr . ')|' . $GLOBALS['timeleft'] . '|' . "\n";
				  @ob_flush();
				  flush();
				  } */

				# debug
				#echo "file:".$file_name.",line:".$line_nr.",token:".token_name($token_name).",";
				#echo "value:".htmlentities($token_value).",";
				#echo "in_function:".$in_function.",in_class:".$in_class."<br>";
				// Vulnerability vectors
				$vuln_vector = isset($_POST['vector']) ? $_POST['vector'] : 'all';

				/* ===============
				  == T_VARIABLE ==
				  =============== */
				if ($token_name === T_VARIABLE) {
					// $var()
					if ($this->tokens[$i + 1][0] === '(') {
						$this->variable_scan($i, 0, 'eval',
						   'Userinput is used as dynamic function name. Arbitrary functions may be called.');
					}
					// $$var =
					else if ((($i > 0 && $this->tokens[$i - 1] === '$') ||
							($i > 1 && $this->tokens[$i - 1] === '{' && $this->tokens[$i - 2] === '$')) &&
							($this->tokens[$i + 1] === '=' ||
							in_array($this->tokens[$i + 1][0], CwisSecTokens::$T_ASSIGNMENT))) {
						$this->variable_scan($i, $this->tokens[$i - 1] === '{' ? 2 : 1, 'extract',
						   'Userinput is used to build the variable name. Arbitrary variables may be overwritten/initialized which may lead to further vulnerabilities.');
					}
					// foreach($var as $key => $value)
					else if (($i > 0 && $this->tokens[$i - 1][0] === T_AS) ||
							($i > 2 && $this->tokens[$i - 1][0] === T_DOUBLE_ARROW &&
							$this->tokens[$i - 2][0] === T_VARIABLE &&
							$this->tokens[$i - 3][0] === T_AS)) {
						$c = 3;
						while ($this->tokens[$i - $c][0] !== T_FOREACH) {
							$c++;

							if (($i - $c) < 0 || $this->tokens[$i - $c] === ';') {
								/* addError('Could not find FOREACH token before AS token',
								  array_slice($this->tokens, $i - 5, 10), $this->tokens[$i - 1][2],
								  $this->file_pointer); */
								break;
							}
						}

						$this->variable_add(
								$token_value, array_slice($this->tokens, $i - $c, $c + $this->analyser->get_brace_end($this->tokens, $i)), '',
																							  0, 0, $line_nr, $i, isset($this->tokens[$i][3]) ? $this->tokens[$i][3] : array()
						);
					}
					// for($var=1; ...)	: add whole instruction block to output
					else if (($i > 1 && $this->tokens[$i - 2][0] === T_FOR) && ($this->tokens[$i + 1] === '=' ||
							in_array($this->tokens[$i + 1][0], CwisSecTokens::$T_ASSIGNMENT))) {
						$c = 1;
						$newbraceopen = 1;
						$firstsemi = 0;
						// do not use get_brace_end() here, because we dont want to stop at ';' in for(;;)
						while ($newbraceopen !== 0) {
							// watch function calls in function call
							if ($this->tokens[$i + $c] === '(') {
								$newbraceopen++;
							} else if ($this->tokens[$i + $c] === ')') {
								$newbraceopen--;
							} else if ($this->tokens[$i + $c] === ';' && $firstsemi < 1) {
								$firstsemi = $c;
							}
							$c++;

							if (!isset($this->tokens[$i + $c])) {
								/* addError('Could not find closing parenthesis of for-statement.',
								  array_slice($this->tokens, $i - 2, 10), $this->tokens[$i - 2][2],
								  $this->file_pointer); */
								break;
							}
						}

						// overwrite value of first var because it is looped
						// this is an assumption, other vars could be declared for($var1=1;$var2=2;...)
						$this->tokens[$i + 2][0] = T_ENCAPSED_AND_WHITESPACE;
						$this->tokens[$i + 2][1] = '*';

						$this->variable_add(
								$token_value, array_slice($this->tokens, $i - 2, $c + 2), '', 1, 2 + $firstsemi, $line_nr, $i,
								  isset($this->tokens[$i][3]) ? $this->tokens[$i][3] : array()
						);
					}
					// $var = ...;
					else if ($this->tokens[$i + 1] === '=' || in_array($this->tokens[$i + 1][0], CwisSecTokens::$T_ASSIGNMENT)) {
						$vardeclare = array();

						// $var = array(1,2,3,4);
						if ($this->tokens[$i + 2][0] === T_ARRAY && $this->tokens[$i + 3] === '(' && $this->tokens[$i + 4] !== ')') {
							$d = 4;
							$keyindex = 0;
							$newbraceopen = 1;
							$keytokens = array();
							$valuetokens = array();

							while (!($newbraceopen === 0 || $this->tokens[$i + $d] === ';') && $keyindex < MAX_ARRAY_ELEMENTS) {
								// count parameters
								if ($newbraceopen === 1 && ($this->tokens[$i + $d] === ',' || $this->tokens[$i + $d] === ')' )) {
									$newindexvar = $this->tokens[$i];
									$newindexvar[3][] = empty($keytokens) ? $keyindex : $keytokens;

									$this->variable_add(
											$token_value, array_merge(array($newindexvar, $this->tokens[$i + 1]), $valuetokens), ' array() ',
									 in_array($this->tokens[$i + 1][0], CwisSecTokens::$T_ASSIGNMENT) ? 0 : 1, 0, $line_nr, $i,
				   isset($this->tokens[$i][3]) ? $this->tokens[$i][3] : array(), empty($keytokens) ? $keyindex : $keytokens
									);

									$keyindex++;
									$keytokens = array();
									$valuetokens = array();
								}
								// watch function calls in array braces
								else if ($this->tokens[$i + $d] === '(') {
									$newbraceopen++;
								} else if ($this->tokens[$i + $d] === ')') {
									$newbraceopen--;
								}
								// "=>" detected, tokens before are keyname, next one value
								else if ($this->tokens[$i + $d][0] === T_DOUBLE_ARROW) {
									$keytokens = $valuetokens;
									$valuetokens = array();
								}
								// main
								else {
									$valuetokens[] = $this->tokens[$i + $d];
								}
								$d++;

								if (!isset($this->tokens[$i + $d])) {
									/* addError('Could not find closing parenthesis of array()-declaration.',
									  array_slice($this->tokens, $i, 10), $this->tokens[$i + 2][2],
									  $this->file_pointer); */
									break;
								}
							}
							$vardeclare['end'] = $this->analyser->get_brace_end($this->tokens, $i) + 1;
							// $var = anything;
						} else {
							$vardeclare['end'] = $this->analyser->get_brace_end($this->tokens, $i) + 1;
							$this->variable_add(
									$token_value, array_slice($this->tokens, $i, $vardeclare['end']), '',
								   in_array($this->tokens[$i + 1][0], CwisSecTokens::$T_ASSIGNMENT) ? 0 : 1, 0, $line_nr, $i,
					isset($this->tokens[$i][3]) ? $this->tokens[$i][3] : array()
							);
						}
						// save var and var declare scope for data leak scan
						$vardeclare['start'] = $i;
						$vardeclare['name'] = $token_value;
						$vardeclare['linenr'] = $line_nr;
						$vardeclare['end'] += $i - 1;
					}

					// $class->var
					//else if ($token_name === T_STRING && $tokens[$i-1][0] === T_OBJECT_OPERATOR && $tokens[$i-2][0] === T_VARIABLE)
					// add user input variables to global finding list
					if (in_array($token_value, CwisSecSources::$V_USERINPUT)) {
						if (isset($this->tokens[$i][3])) {
							if (!is_array($this->tokens[$i][3][0])) {
								$this->user_input[$token_value . '[' . $this->tokens[$i][3][0] . ']'][$this->file_pointer][] = $line_nr;
							} else {
								$this->user_input[$token_value . '[' . $this->analyser->get_tokens_value(
												$this->file_pointer, $this->tokens[$i][3][0],
			$this->in_function ? $this->var_declares_local : $this->var_declares_global, $this->var_declares_global, $i
										) . ']'][$this->file_pointer][] = $line_nr;
							}
						} else {
							$this->user_input[$token_value][$this->file_pointer][] = $line_nr;
						}

						// count found userinput in function for graphs
						if ($this->in_function) {
							if (!isset($this->user_functions_offset[$this->function_obj->name][5])) {
								$this->user_functions_offset[$this->function_obj->name][5] = 0;
							}
							$this->user_functions_offset[$this->function_obj->name][5] ++;
						} else {
							if (!isset($this->user_functions_offset['__main__'][5])) {
								$this->user_functions_offset['__main__'][5] = 0;
							}
							$this->user_functions_offset['__main__'][5] ++;
						}
					}
				}
				// check if token is a function call and a function to scan
				// do not check if next token is '(' because: require $inc; does not use ()
				else if (in_array($token_name, CwisSecTokens::$T_FUNCTIONS) ||
						(in_array($token_name, CwisSecTokens::$T_XSS) &&
						($vuln_vector == 'client' || $vuln_vector == 'xss' || $vuln_vector == 'all'))) {
					$class = '';

					/* =============
					  == T_STRING ==
					  ============= */
					if ($token_name === T_STRING && isset($this->tokens[$i + 1]) && $this->tokens[$i + 1] === '(') {
						// define("FOO", $_GET['asd']);
						if ($token_value === 'define') {
							$c = 1;
							while (isset($this->tokens[$i + $c]) && $this->tokens[$i + $c] !== ',') {
								$c++;

								if ($this->tokens[$i + $c] === ';' || !isset($this->tokens[$i + $c])) {
									/* addError('Second parameter of define() is missing.',
									  array_slice($this->tokens, $i, $c), $this->tokens[$i][2],
									  $this->file_pointer); */
									break;
								}
							}

							$this->variable_add(
									str_replace(array('"', "'"), '', $this->tokens[$i + 2][1]),
					 array_slice($this->tokens, $i, $this->analyser->get_brace_end($this->tokens, $i) + 1), ' define() ', $c, 0,
																	$line_nr, $i
							);
						}
						// ini_set()
						else if ($token_value === 'ini_set') {
							$setting = str_replace(array("'", '"'), '', $this->tokens[$i + 2][1]);
							// ini_set('include_path', 'foo/bar')
							if ($setting === 'include_path') {
								$path = $this->analyser->get_tokens_value(
										$this->file_pointer,
		  array_slice($this->tokens, $i + 4, $this->analyser->get_brace_end($this->tokens, $i + 4) + 1),
																	  $this->in_function ? $this->var_declares_local : $this->var_declares_global,
																	  $this->var_declares_global, $i
								);
								$this->include_paths = array_unique(array_merge($this->include_paths, $this->analyser->get_ini_paths($path)));
							}
						}
						// set_include_path('foo/bar')
						else if ($token_value === 'set_include_path') {
							$path = $this->analyser->get_tokens_value(
									$this->file_pointer,
		 array_slice($this->tokens, $i + 1, $this->analyser->get_brace_end($this->tokens, $i + 1) + 1),
																	 $this->in_function ? $this->var_declares_local : $this->var_declares_global,
																	 $this->var_declares_global, $i
							);
							$this->include_paths = array_unique(array_merge($this->include_paths, $this->analyser->get_ini_paths($path)));
						}
						// treat error handler as called function
						else if ($token_value === 'set_error_handler') {
							$token_value = str_replace(array('"', "'"), '', $this->tokens[$i + 2][1]);
						}
						// $array = compact("event", "city");
						else if ($token_value === 'compact' && $this->tokens[$i - 2][0] === T_VARIABLE) {
							$f = 2;
							while ($this->tokens[$i + $f] !== ')') {
								// for all array keys save new variable declarations
								if ($this->tokens[$i + $f][0] === T_CONSTANT_ENCAPSED_STRING) {
									$var_name = str_replace(array('"', "'"), '', $this->tokens[$i + $f][1]);
									$var_tokens = array(
										array(T_VARIABLE, $this->tokens[$i - 2][1], $line_nr, array($var_name)),
										'=', array(T_VARIABLE, '$' . $var_name, $line_nr), ';'
									);

									// save a declaration
									$this->variable_add(
											$this->tokens[$i - 2][1], $var_tokens, ' compact() ', 2, 0, $line_nr, $i,
		   isset($this->tokens[$i - 2][3]) ? $this->tokens[$i - 2][3] : null, $var_name
									);
								}
								$f++;

								if ($this->tokens[$i + $f] === ';' || !isset($this->tokens[$i + $f])) {
									/* addError('Closing parenthesis of compact() is missing.',
									  array_slice($this->tokens, $i, $f), $this->tokens[$i][2],
									  $this->file_pointer); */
									break;
								}
							}
						}
						// preg_match($regex, $source, $matches), save $matches as var declare
						else if ($token_value === 'preg_match' || $token_value === 'preg_match_all') {
							$c = 2;
							$parameter = 1;
							$newbraceopen = 1;

							while ($newbraceopen !== 0) {
								if (is_array($this->tokens[$i + $c]) && $this->tokens[$i + $c][0] === T_VARIABLE && $parameter == 3) {
									// add variable declaration to beginning of varlist
									// fake assignment parameter so it will not get traced
									$this->variable_add(
											$this->tokens[$i + $c][1],
		   array_slice($this->tokens, $i, $this->analyser->get_brace_end($this->tokens, $i + 2) + 3), ' preg_match() ', 0,
																   $c - 1, $this->tokens[$i + $c][2], $i,
																   isset($this->tokens[$i + $c][3]) ? $this->tokens[$i + $c][3] : array()
									);
								}
								// count parameters
								else if ($newbraceopen === 1 && $this->tokens[$i + $c] === ',') {
									$parameter++;
								}
								// watch function calls in function call
								else if ($this->tokens[$i + $c] === '(') {
									$newbraceopen++;
								} else if ($this->tokens[$i + $c] === ')') {
									$newbraceopen--;
								} else if ($this->tokens[$i + $c] === ';' || !isset($this->tokens[$i + $c])) {
									/* addError('Closing parenthesis of ' . $token_value . '() is missing.',
									  array_slice($this->tokens, $i, $c), $this->tokens[$i][2],
									  $this->file_pointer); */
									break;
								}
								$c++;
							}
						}
						// import_request_variables()
						else if ($token_value === 'import_request_variables') {
							// add register_globals implementation
							$this->variable_add(
									'register_globals', array_slice($this->tokens, $i, $this->analyser->get_brace_end($this->tokens, $i + 1) + 1),
																						   'register_globals implementation', 0, 0, $line_nr, $i,
																						   isset($this->tokens[$i][3]) ? $this->tokens[$i][3] : array()
							);
						}
						// parse_str()
						else if ($token_value === 'parse_str') {
							$c = 2;
							$parameter = 1;
							$newbraceopen = 1;

							while ($newbraceopen !== 0) {
								if (is_array($this->tokens[$i + $c]) && $this->tokens[$i + $c][0] === T_VARIABLE && $parameter == 2) {
									// add variable declaration to beginning of varlist
									// fake assignment parameter so it will not get traced
									$this->variable_add(
											$this->tokens[$i + $c][1],
		   array_slice($this->tokens, $i, $this->analyser->get_brace_end($this->tokens, $i + 2) + 3), ' parse_str() ', 0,
																   $c - 1, $this->tokens[$i + $c][2], $i,
																   isset($this->tokens[$i + $c][3]) ? $this->tokens[$i + $c][3] : array()
									);
								}
								// count parameters
								else if ($newbraceopen === 1 && $this->tokens[$i + $c] === ',') {
									$parameter++;
								}
								// watch function calls in function call
								else if ($this->tokens[$i + $c] === '(') {
									$newbraceopen++;
								} else if ($this->tokens[$i + $c] === ')') {
									$newbraceopen--;
								} else if ($this->tokens[$i + $c] === ';' || !isset($this->tokens[$i + $c])) {
									/* addError('Closing parenthesis of ' . $token_value . '() is missing.',
									  array_slice($this->tokens, $i, $c), $this->tokens[$i][2],
									  $this->file_pointer); */
									break;
								}
								$c++;
							}
						}

						//add interesting function calls to info gathering
						if (isset($this->info_functions[$token_value])) {
							$this->result_info[] = $this->info_functions[$token_value];
						}
						// watch constructor calls $var = Classname($constructor_param);
						else if ($i > 1 && $this->tokens[$i - 1][0] !== T_NEW && isset($this->vuln_classes[$token_value])) {
							$this->class_vars[$this->tokens[$i - 2][1]] = $token_value;
						}
						// add function call to user-defined function list
						else {
							// $classvar->bla()
							if ($i > 0 && isset($this->tokens[$i - 2][1])) {
								if ($this->tokens[$i - 1][0] === T_OBJECT_OPERATOR) {
									$classvar = $this->tokens[$i - 2][1];
									if ($classvar[0] !== '$') {
										$classvar = '$' . $classvar;
									}
									$class = ($classvar === '$this' || $classvar === '$self' || !isset($this->class_vars[$classvar])) ?
											$this->class_name : $this->class_vars[$classvar];
								}
								// CLASS::func()
								else if ($this->tokens[$i - 1][0] === T_DOUBLE_COLON) {
									$class = $this->tokens[$i - 2][1];
								}
							}

							// save function call for graph
							if (isset($this->user_functions_offset[($class ? $class . '::' : '') . $token_value])) {
								$this->user_functions_offset[($class ? $class . '::' : '') . $token_value][3][] = array(
									$this->file_pointer, $line_nr);

								if ($this->in_function) {
									$this->user_functions_offset[$this->function_obj->name][4][] = $token_value;
								} else {
									if (!isset($this->user_functions_offset['__main__'][4])) {
										$this->user_functions_offset['__main__'][4] = array();
									}
									$this->user_functions_offset['__main__'][4][] = $token_value;
								}
							}

							// check if token is function call that affects variable scope (global)
							if (isset($this->globals_from_function[$token_value])) {
								// put all previously saved global var assignments to global scope
								foreach ($this->globals_from_function[$token_value] as $var_name => $new_vars) {
									foreach ($new_vars as $new_var) {
										$new_var->comment = $new_var->comment . " by $token_value()";

										// update var_declares_global
										if (!isset($this->var_declares_global[$var_name])) {
											$this->var_declares_global[$var_name] = array($new_var);
										} else {
											array_unshift($this->var_declares_global[$var_name], $new_var);
										}
									}
								}
							}
						}
					}
					/* ===================
					  == FILE INCLUSION ==
					  =================== */
					// include tokens from included files (disabled)
					else if (0 && in_array($token_name, CwisSecTokens::$T_INCLUDES) && !$this->in_function) {
						$this->count_inc ++;
						// include('xxx')
						if ((($this->tokens[$i + 1] === '(' && $this->tokens[$i + 2][0] === T_CONSTANT_ENCAPSED_STRING && $this->tokens[$i + 3] === ')')
								// include 'xxx'
								|| (is_array($this->tokens[$i + 1]) && $this->tokens[$i + 1][0] === T_CONSTANT_ENCAPSED_STRING && $this->tokens[$i + 2] === ';' ))) {
							// include('file')
							if ($this->tokens[$i + 1] === '(') {
								$inc_file = substr($this->tokens[$i + 2][1], 1, -1);
								$skip = 5;
							}
							// include 'file'
							else {
								$inc_file = substr($this->tokens[$i + 1][1], 1, -1);
								$skip = 3;
							}
						}
						// dynamic include
						else {
							$inc_file = $this->analyser->get_tokens_value(
									$this->file_pointer,
		 array_slice($this->tokens, $i + 1, $c = $this->analyser->get_brace_end($this->tokens, $i + 1) + 1),
																		  $this->in_function ? $this->var_declares_local : $this->var_declares_global,
																		  $this->var_declares_global, $i
							);

							// in case the get_var_value added several php files, take the first
							$several = explode('.php', $inc_file);
							if (count($several) > 1) {
								$try_file = $several[0] . '.php';
							}

							$skip = $c + 1; // important to save $c+1 here
						}

						$try_file = $inc_file;

						// try absolute include path
						foreach ($this->include_paths as $include_path) {
							if (is_file("$include_path/$try_file")) {
								$try_file = "$include_path/$try_file";
								break;
							}
						}

						// if dirname(__FILE__) appeared it was an absolute path
						if (!is_file($try_file)) {
							// check relativ path
							$try_file = dirname($this->file_name) . '/' . $inc_file;


							if (!is_file($try_file)) {
								$other_try_file = dirname($this->file_pointer) . '/' . $inc_file;

								// if file can not be found check include_path if set
								if (!is_file($other_try_file)) {
									if (isset($this->include_paths[0])) {
										foreach ($this->include_paths as $include_path) {
											if (is_file(dirname($this->file_name) . '/' . $include_path . '/' . $inc_file)) {
												$try_file = dirname($this->file_name) . '/' . $include_path . '/' . $inc_file;
												break;
											} else if (is_file(dirname($this->file_pointer) . '/' . $include_path . '/' . $inc_file)) {
												$try_file = dirname($this->file_pointer) . '/' . $include_path . '/' . $inc_file;
												break;
											}
										}
									}

									// if still not a valid file, look a directory above
									if (!is_file($try_file)) {
										$try_file = str_replace('\\', '/', $try_file);
										$pos = strlen($try_file);
										// replace each found / with /../, start from the end of file name
										for ($c = 1; $c < substr_count($try_file, '/'); $c++) {
											$pos = strripos(substr($try_file, 1, $pos), '/');
											if (is_file(substr_replace($try_file, '/../', $pos + 1, 1))) {
												$try_file = substr_replace($try_file, '/../', $pos + 1, 1);
												break;
											}
										}

										if (!is_file($try_file)) {
											$try_file = str_replace('\\', '/', $other_try_file);
											$pos = strlen($try_file);
											// replace each found / with /../, start from the end of file name
											for ($c = 1; $c < substr_count($try_file, '/'); $c++) {
												$pos = strripos(substr($try_file, 1, $pos), '/');
												if (is_file(substr_replace($try_file, '/../', $pos + 1, 1))) {
													$try_file = substr_replace($try_file, '/../', $pos + 1, 1);
													break;
												}
											}

											// if still not a valid file, guess it
											if (!is_file($try_file)) {
												$searchfile = basename($try_file);
												if (!strstr($searchfile, '$_USERINPUT')) {
													foreach ($this->files as $cfile) {
														if (basename($cfile) == $searchfile) {
															$try_file = $cfile;
															break;
														}
													}
												}
											}
										}
									}
								} else {
									$try_file = $other_try_file;
								}
							}
						}

						$try_file_unreal = $try_file;
						$try_file = realpath($try_file);

						// file is valid
						if (!empty($try_file_unreal) && !empty($try_file) && $inc_lines = @file($try_file_unreal)) {
							// file name has not been included
							if (!in_array($try_file, $this->inc_map)) {
								// Tokens
								$tokenizer = new CwisSecTokenizer($try_file);
								$inc_tokens = $tokenizer->tokenize(implode('', $inc_lines));
								unset($tokenizer);

								// if(include('file')) { - include tokens after { and not into the condition :S
								if ($this->in_condition) {
									$this->tokens = array_merge(
											array_slice($this->tokens, 0, $this->in_condition + 1), // before include in condition
					   $inc_tokens, // included tokens
					   array(array(T_INCLUDE_END, 0, 1)), // extra END-identifier
					   array_slice($this->tokens, $this->in_condition + 1)   // after condition
									);
								} else {
									// insert included tokens in current tokenlist and mark end
									$this->tokens = array_merge(
											array_slice($this->tokens, 0, $i + $skip), // before include
					   $inc_tokens, // included tokens
					   array(array(T_INCLUDE_END, 0, 1)), // extra END-identifier
					   array_slice($this->tokens, $i + $skip)  // after include
									);
								}

								$tokencount = count($this->tokens);

								// set lines pointer to included lines, save last pointer
								// (the following tokens will be the included ones)
								$this->lines_stack[] = $inc_lines;
								$this->lines_pointer = end($this->lines_stack);

								// tokennr in file
								$this->tif_stack[] = $this->tif;
								$this->tif = -$skip;

								// set the current file pointer
								$this->file_pointer = $try_file;
								if (!isset($this->file_sinks_count[$this->file_pointer])) {
									$this->file_sinks_count[$this->file_pointer] = 0;
								}

								/* echo $GLOBALS['fit'] . '|' . $GLOBALS['file_amount'] . '|' . $this->file_pointer . '|' . $GLOBALS['timeleft'] . '|' . "\n";
								  @ob_flush();
								  flush(); */

								$this->comment = basename($inc_file);

								$this->inc_file_stack[] = $try_file;

								// build include map for file list
								$this->inc_map[] = $try_file; // all basic includes
							}
						}
						// included file name could not be reversed
						// (probably dynamic with function calls)
						else {
							$this->count_inc_fail ++;
							// add information about include error in debug mode
							if ($this->verbosity == 5) {
								// add include command to output
								$found_value = $this->highlightline(array_slice($this->tokens, $i, $skip), $this->comment, $line_nr,
														$token_value);
								$new_find = new CwisSecInfoTreeNode($found_value);
								$new_find->lines[] = $line_nr;
								$new_find->filename = $this->file_pointer;
								$new_find->title = "Include error: tried to include: " . $try_file_unreal;

								if (isset($this->result_output[$this->file_name]['inc'])) {
									$this->result_output[$this->file_name]['inc']->treenodes[] = $new_find;
								} else {
									$new_block = new CwisSecVulnBlock($this->tif . '_' . $this->tokens[$i][2] . '_' . basename($this->file_pointer),
																									'Debug');
									$new_block->treenodes[] = $new_find;
									$new_block->vuln = true;
									$this->result_output[$this->file_name]['inc'] = $new_block;
								}
							}
						}
					}

					/* ===================
					  == TAINT ANALYSIS ==
					  =================== */
					if (isset($this->scan_functions[$token_value]) && $this->verbosity != 5
							// not a function of a class or a function of a vulnerable class
							&& (empty($class) || (($this->in_function && is_array($this->function_obj->parameters) &&
							in_array($classvar, $this->function_obj->parameters)) ||
							@in_array($token_value, $this->vuln_classes[$class])))) {
						if (!$this->already_scanned($i)) {
							// build new find
							$new_find = new CwisSecVulnTreeNode();
							$new_find->name = $token_value;
							$new_find->lines[] = $line_nr;

							// add dependencies (already here, because checked during var trace
							foreach ($this->dependencies as $deplinenr => $dependency) {
								if (!empty($dependency)) {
									$new_find->dependencies[$deplinenr] = $dependency;
								}
							}

							// count sinks
							$this->file_sinks_count[$this->file_pointer] ++;

							if ($this->in_function) {
								if (!isset($this->user_functions_offset[$this->function_obj->name][6])) {
									$this->user_functions_offset[$this->function_obj->name][6] = 0;
								}
								$this->user_functions_offset[$this->function_obj->name][6] ++;
							} else {
								if (!isset($this->user_functions_offset['__main__'][6])) {
									$this->user_functions_offset['__main__'][6] = 0;
								}
								$this->user_functions_offset['__main__'][6] ++;
							}

							$parameter = 1;
							$var_counter = 0;
							$vulnparams = array(0);
							$has_vuln_parameters = false;
							$parameter_has_userinput = false;
							$parameter_func_depend = false;
							$secured_by_start = false;
							// function calls without quotes (require $inc;) --> no brace count
							$parentheses_open = ($this->tokens[$i + 1] === '(') ? 1 : -2; // -2: detection of braces doesnt matter
							$parentheses_save = -1;
							$in_securing = false;
							$ignore_securing = false;
							$c = ($this->tokens[$i + 1] === '(') ? 2 : 1; // important
							$tainted_vars = array();

							$reconstructstr = '';
							//$addtitle = '';
							$securing_function = '';
							$this->securedby = array();

							// get all variables in parameter list between (...)
							// not only until ';' because: system(get($a),$b,strstr($c));
							while ($parentheses_open !== 0 && isset($this->tokens[$i + $c]) && $this->tokens[$i + $c] !== ';') {
								$this_one_is_secure = false;
								if (is_array($this->tokens[$i + $c]) && isset($this->tokens[$i + $c + 1])) {
									// scan variables and constants
									if (($this->tokens[$i + $c][0] === T_VARIABLE && $this->tokens[$i + $c + 1][0] !== T_OBJECT_OPERATOR) ||
											($this->tokens[$i + $c][0] === T_STRING && $this->tokens[$i + $c + 1] !== '(')) {
										$var_counter++;
										// scan only potential vulnerable parameters of function call
										if (in_array($parameter, $this->scan_functions[$token_value][0]) ||
												(isset($this->scan_functions[$token_value][0][0]) &&
												$this->scan_functions[$token_value][0][0] === 0)) { // all parameters accepted
											$has_vuln_parameters = true;

											if ((is_array($this->tokens[$i + $c - 1]) &&
													in_array($this->tokens[$i + $c - 1][0], CwisSecTokens::$T_CASTS)) ||
													(is_array($this->tokens[$i + $c + 1]) &&
													in_array($this->tokens[$i + $c + 1][0], CwisSecTokens::$T_ARITHMETIC)) || $in_securing) {
												$secured_by_start = true;
												$this_one_is_secure = true;
											}

											if ($in_securing && !$ignore_securing) {
												$this->securedby[] = $securing_function;
											}

											// trace back parameters and look for userinput, trace constants globally
											$userinput = $this->scan_parameter(
													$new_find, $new_find, $this->tokens[$i + $c],
			 isset($this->tokens[$i + $c][3]) ? $this->tokens[$i + $c][3] : null, $i + $c,
		  ($this->in_function && $this->tokens[$i + $c][1][0] === '$') ? $this->var_declares_local : $this->var_declares_global,
		  $this->var_declares_global, false, CwisSecSecuring::get_prop($this->scan_functions[$token_value][1]),
																 false, // no return-scan
																 $ignore_securing, ($this_one_is_secure || $in_securing)
											);

											$reconstructstr .= $this->analyser->get_var_value(
													$this->file_pointer, $this->tokens[$i + $c],
			 ($this->in_function && $this->tokens[$i + $c][1][0] === '$') ? $this->var_declares_local : $this->var_declares_global,
			 $this->var_declares_global, $i + $c, $this->source_functions
											);


											if ($userinput /* && (!$this_one_is_secure || $this->verbosity == 3) */) {
												$vulnparams[] = $parameter;
												if ($userinput == 1) {
													$parameter_has_userinput = true;
												} else if ($userinput == 2) {
													$parameter_func_depend = true;
												}
												$tainted_vars[] = $var_counter;
											}
										}

										// mark userinput for quote analysis
										if (in_array($this->tokens[$i + $c][1], CwisSecSources::$V_USERINPUT)) {
											$reconstructstr .= '$_USERINPUT';
										}
									}
									// userinput from return value of a function
									else if ($this->tokens[$i + $c][0] === T_STRING && in_array($this->tokens[$i + $c][1], $this->source_functions)
											// scan only potential vulnerable parameters of function call
											&& ( in_array($parameter, $this->scan_functions[$token_value][0]) ||
											(isset($this->scan_functions[$token_value][0][0]) &&
											$this->scan_functions[$token_value][0][0] === 0) )) {// all parameters accepted
										$has_vuln_parameters = true;
										$parameter_has_userinput = true;
										$new_find->marker = 1;
										$reconstructstr .= '$_USERINPUT';
										$new_find->title = 'Userinput returned by function <i>' . $this->tokens[$i + $c][1] . '</i> reaches sensitive sink';
										$this->add_trigger_function($new_find);
									}
									//detect insecuring functions (functions that make previous securing useless)
									else if ($this->tokens[$i + $c][0] === T_STRING && isset($this->tokens[$i + $c][1]) && in_array($this->tokens[$i + $c][1],
																										 CwisSecSecuring::$F_INSECURING_STRING) && $parentheses_save == -1) {
										$parentheses_save = $parentheses_open;
										$ignore_securing = true;
									}
									// detect securing functions embedded into the sensitive sink
									else if (!$ignore_securing && ($this->tokens[$i + $c][0] === T_STRING &&
											( (is_array(CwisSecSecuring::get_prop($this->scan_functions[$token_value][1])) &&
											in_array($this->tokens[$i + $c][1], CwisSecSecuring::get_prop($this->scan_functions[$token_value][1]))) ||
											in_array($this->tokens[$i + $c][1], CwisSecSecuring::$F_SECURING_STRING) ) ) ||
											(in_array($this->tokens[$i + $c][0], CwisSecTokens::$T_CASTS) && $this->tokens[$i + $c + 1] === '(')) {
										$securing_function = $this->tokens[$i + $c][1];
										$parentheses_save = $parentheses_open;
										$in_securing = true;
										$secured_by_start = true;
									}
									// add strings to reconstructed string for quotes analysis
									else if ($this->tokens[$i + $c][0] === T_CONSTANT_ENCAPSED_STRING) {
										$reconstructstr .= substr($this->tokens[$i + $c][1], 1, -1);
									} else if ($this->tokens[$i + $c][0] === T_ENCAPSED_AND_WHITESPACE) {
										$reconstructstr .= $this->tokens[$i + $c][1];
									}
								}
								// count parameters
								else if ($parentheses_open === 1 && $this->tokens[$i + $c] === ',') {
									$parameter++;
								}
								// watch function calls in function call
								else if ($this->tokens[$i + $c] === '(') {
									$parentheses_open++;
								} else if ($this->tokens[$i + $c] === ')') {
									$parentheses_open--;
									if ($parentheses_open === $parentheses_save) {
										$parentheses_save = -1;
										$in_securing = false;
										$securing_function = '';
										$ignore_securing = false;
									}
								} else if (!isset($this->tokens[$i + $c])) {
									/* addError('Closing parenthesis of ' . $token_value . '() is missing.',
									  array_slice($this->tokens, $i, 10), $this->tokens[$i][2],
									  $this->file_pointer); */
									break;
								}
								$c++;
							}

							// quote analysis for securing functions F_QUOTE_ANALYSIS
							// they only protect when return value is embedded into quotes
							if ($this->quote_analysis_needed() && substr_count($reconstructstr, '$_USERINPUT') > 0) {
								// idea: explode on $_USERINPUT and count quotes in SQL query before
								// if not even, then the $_USERINPUT is in an open quote
								$parts = explode('$_USERINPUT', $reconstructstr);
								foreach ($this->securedby as $var => $securefunction) {
									if (in_array($securefunction, CwisSecSecuring::$F_SECURING_SQL)) {
										// extract the string before the userinput
										$checkstring = '';
										$d = 1;
										foreach ($parts as $part) {
											$checkstring .= $part;
											if ($d >= $var) {
												break;
											}
											$d++;
										}

										// even amount of quotes (or none) in string
										// --> no quotes around userinput
										// --> securing function is	useless
										if (substr_count($checkstring, "'") % 2 === 0 && substr_count($checkstring, '"') % 2 === 0) {
											$has_vuln_parameters = true;
											$parameter_has_userinput = true;
											$new_find->title .= "Userinput reaches sensitive sink due to insecure usage of $securefunction() without quotes";
										}
									}
								}
							}

							// add find to output if function call has variable parameters (With userinput)
							if (($has_vuln_parameters && ($parameter_has_userinput || $parameter_func_depend)) ||
									$this->verbosity == 4 || isset($this->scan_functions[$token_value][3])) {
								$vulnstart = $i;
								$vulnadd = 1;
								// prepend $var assignment
								if (isset($vardeclare)) {
									$vulnstart = $vardeclare['start'];
									$vulnadd = $vardeclare['end'] - $vardeclare['start'] - $c + 1; //3;
								}
								// prepend echo statement
								else if ($i > 0 && isset($this->tokens[$i - 1])) {
									if (isset($this->tokens[$i - 1][1]) && isset(CwisSecSinks::$F_XSS[$this->tokens[$i - 1][1]])) {
										$vulnstart = $i - 1;
										$vulnadd = 2;
									}
									// prepend class var
									else if ($this->tokens[$i - 1][0] === T_DOUBLE_COLON ||
											$this->tokens[$i - 1][0] === T_OBJECT_OPERATOR) {
										$vulnstart = $i - 2;
										$vulnadd = 2;
									}
								}

								if (isset($this->user_functions[$this->file_name][$token_value])) {
									$found_line = '<A NAME="' . $token_value . '_call" class="jumplink"></A>';
									$found_line .= $this->highlightline(array_slice($this->tokens, $vulnstart, $c + $vulnadd), $this->comment,
														 $line_nr, false, $token_value);
								} else {
									$found_line = $this->highlightline(array_slice($this->tokens, $vulnstart, $c + $vulnadd), $this->comment,
														$line_nr, $token_value, false, $tainted_vars);
								}

								$new_find->value = $found_line;
								$new_find->filename = $this->file_pointer;

								if ($secured_by_start) {
									$new_find->marker = 2;
								}

								// only show vuln user defined functions
								// if call with userinput has been found
								if (isset($this->user_functions[$this->file_name][$token_value])) {
									$this->user_functions[$this->file_name][$token_value]['called'] = true;
								}

								if ($this->in_function) {
									$this->ignore_securing_function = true;
									// mark function in class as vuln
									if ($this->in_class) {
										$this->vuln_classes[$this->class_name][] = $this->function_obj->name;
									}
								}

								// putenv with userinput --> getenv is treated as userinput
								if ($token_value === 'putenv') {
									$this->source_functions[] = 'getenv';
									$new_find->title = 'User can set PHP enviroment variables. Adding getenv() to tainting functions';
								} else if ($token_value === 'apache_setenv') {
									$this->source_functions[] = 'apache_getenv';
									$new_find->title = 'User can set Apache enviroment variables. Adding apache_getenv() to tainting functions';
								} else if ($token_value === 'extract' || $token_value === 'parse_str' || $token_value === 'mb_parse_str') {
									// add register_globals implementation
									$this->variable_add(
											'register_globals', array_slice($this->tokens, $vulnstart, $c + $vulnadd), 'register_globals implementation',
										   0, 0, $line_nr, $i, isset($this->tokens[$i][3]) ? $this->tokens[$i][3] : array()
									);
								}

								// add to output
								if (isset($this->user_functions[$this->file_name][$token_value])) {
									if (!empty($this->result_output[$this->file_name])) {
										foreach ($this->result_output[$this->file_name] as $block) {
											$calleesadded = array();
											foreach ($block->treenodes as $tree) {
												if ($tree->funcdepend === $token_value &&
														( (is_array($tree->funcparamdepend) &&
														array_intersect($tree->funcparamdepend, $vulnparams)) ||
														isset($this->scan_functions[$token_value][3]) )) {
													// if funcdependend already found and added, just add foundcallee=true and continue
													// dont add tree again, it is already added to the vulnblock
													if (in_array($tree->funcdepend, $calleesadded)) {
														$tree->foundcallee = true;
														continue;
													}

													if (isset($this->scan_functions[$token_value][3])) {
														$new_find->title = 'Call triggers vulnerability in function <i>' . $token_value . '()</i>';
													} else if (empty($new_find->title)) {
														$new_find->title = 'Userinput is passed through function parameters.';
													}

													$block->treenodes[] = $new_find;
													if (!$block->vuln && ($parameter_has_userinput ||
															isset($this->scan_functions[$token_value][3]) ||
															$this->verbosity == 4)) {
														$block->vuln = true;
														CwisSecSinks::increaseVulnCounter($block->sink);
													}

													$tree->foundcallee = true;
													$calleesadded[] = $token_value;
												}
											}
										}
										// else: dont use the result
									}
								} else {
									if (empty($new_find->title)) {
										$new_find->title = 'Userinput reaches sensitive sink.';
									}
									$block = new CwisSecVulnBlock($this->tif . '_' . $this->tokens[$i][2] . '_'
											. basename($this->file_pointer), CwisSecSinks::getVulnNodeTitle($token_value), $token_value);
									$block->treenodes[] = $new_find;
									if ($parameter_has_userinput || $this->verbosity == 4) {
										$block->vuln = true;
										CwisSecSinks::increaseVulnCounter($token_value);
									}
									// if sink in var declare, offer a data leak scan - save infos for that
									if (isset($vardeclare)) {
										$block->dataleakvar = array($vardeclare['linenr'], $vardeclare['name']);
									}

									$this->result_output[$this->file_name][] = $block;
								}
							}

							// if classvar depends on function parameter, add this parameter to list
							if (isset($this->classvar) && $this->in_function && in_array($this->classvar, $this->function_obj->parameters)) {
								$param = array_search($this->classvar, $this->function_obj->parameters);
								$this->user_functions[$this->file_name][$this->function_obj->name][0][$param] = $param + 1;
							}
						}
					} // taint analysis
				} else
				/* =======================
				  == CONTROL STRUCTURES ==
				  ======================= */
				if (in_array($token_name, CwisSecTokens::$T_LOOP_CONTROL)) {
					// ignore in requirements output: while, for, foreach
					// DO..WHILE was rewritten to WHILE in tokenizer
					$this->ignore_requirement = true;

					$c = 1;
					// get variables in loop condition
					while (isset($this->tokens[$i + $c]) && $this->tokens[$i + $c] !== '{') {
						if ($this->tokens[$i + $c][0] === T_VARIABLE) {
							$this->tokens[$i + $c][3][] = '*';
						} else if (!isset($this->tokens[$i + $c])) {
							/* addError('Could not find opening brace after ' . $token_value . '-statement.',
							  array_slice($this->tokens, $i, 10), $this->tokens[$i][2], $this->file_pointer); */
							break;
						}
						$c++;
					}
				}
				// save current dependency
				else if (in_array($token_name, CwisSecTokens::$T_FLOW_CONTROL)) {
					$c = 1;
					while ($this->tokens[$i + $c] !== '{') {
						$c++;
						if (!isset($this->tokens[$i + $c])) {
							/* addError('Could not find opening brace after ' . $token_value . '-statement.',
							  array_slice($this->tokens, $i, 10), $this->tokens[$i][2], $this->file_pointer); */
							break;
						}
					}
					$this->in_condition = $i + $c;
					$this->dependencytokens = array_slice($this->tokens, $i, $c);
				} else
				/* ==============
				  == FUNCTIONS ==
				  ============== */
				// check if token is a function declaration
				if ($token_name === T_FUNCTION) {
					if ($this->in_function) {
						#addError('New function declaration in function declaration of '.$this->function_obj->name.'() found. This is valid PHP syntax but not supported by RIPS now.', array_slice($this->tokens, $i, 10), $this->tokens[$i][2], $this->file_pointer);
					} else {
						$this->in_function++;

						// the next token is the "function name()"
						$i++;
						$function_name = isset($this->tokens[$i]) && isset($this->tokens[$i][1]) ?
								$this->tokens[$i][1] : (isset($this->tokens[$i + 1][1]) ? $this->tokens[$i + 1][1] : null);
						$ref_name = ($this->in_class ? $this->class_name . '::' : '') . $function_name;

						// add POP gadgets to info
						if ($function_name && isset($this->info_functions[$function_name])) {
							$this->result_info[] = $ref_name;

							// add gadget to output
							$found_line = $this->highlightline(array_slice($this->tokens, $i - 1, 4), $this->comment, $line_nr,
													  $function_name, false, $function_name);
							$new_find = new CwisSecInfoTreeNode($found_line);
							$new_find->title = "POP gadget $ref_name";
							$new_find->lines[] = $line_nr;
							$new_find->filename = $this->file_pointer;

							if (isset($this->result_output[$this->file_name]['gadgets'])) {
								$this->result_output[$this->file_name]['gadgets']->treenodes[] = $new_find;
							} else {
								$block = new CwisSecVulnBlock($this->tif . '_' . $this->tokens[$i][2] . '_' . basename($this->file_pointer),
																							   'POP gadgets');
								$block->vuln = true;
								$block->treenodes[] = $new_find;
								$this->result_output[$this->file_name]['gadgets'] = $block;
							}
						}

						$c = 3;
						while ($this->tokens[$i + $c] !== '{' && $this->tokens[$i + $c] !== ';') {
							$c++;
						}

						// abstract functions ended
						if ($this->tokens[$i + $c] === ';') {
							$this->in_function--;
						}

						// write to user_functions offset list for referencing in output
						$this->user_functions_offset[$ref_name][0] = $this->file_pointer;
						$this->user_functions_offset[$ref_name][1] = $line_nr - 1;
						// save function as object
						$this->function_obj = new CwisSecFunctionDeclare($this->dependencytokens = array_slice($this->tokens, $i - 1,
																							 $c + 1));
						$this->function_obj->lines[] = $line_nr;
						$this->function_obj->name = $function_name;

						// save all function parameters
						$this->function_obj->parameters = array();
						$e = 1;
						// until function test(...) {
						//  OR
						// interface test { function test(...); }
						while ($this->tokens[$i + $e] !== '{' && $this->tokens[$i + $e] !== ';') {
							if (is_array($this->tokens[$i + $e]) && $this->tokens[$i + $e][0] === T_VARIABLE) {
								$this->function_obj->parameters[] = $this->tokens[$i + $e][1];
							}
							$e++;
						}
						// now skip the params from rest of scan,
						// or function test($a=false, $b=false) will be detected as var declaration
						$i += $e - 1; // -1, because '{' must be evaluated again
					}
				}
				// add globaled variables (global $a, $b, $c;) to var list
				else if ($token_name === T_GLOBAL && $this->in_function) {
					$this->globals_from_function[$this->function_obj->name] = array();

					// get all globaled variables
					$b = 1;
					while ($this->tokens[$i + $b] !== ';') {
						if ($this->tokens[$i + $b][0] === T_VARIABLE) {
							// mark variable as global scope affecting
							$this->put_in_global_scope[] = $this->tokens[$i + $b][1];
							// add variable declaration to beginning of varlist
							$new_var = new CwisSecVarDeclare(array(
								array(T_GLOBAL, 'global', $line_nr),
								array(T_VARIABLE, $this->tokens[$i + $b][1], $line_nr),
								';'
									), $this->comment);
							$new_var->line = $line_nr;
							$new_var->id = $i;

							// overwrite old local vars
							$this->var_declares_local[$this->tokens[$i + $b][1]] = array($new_var);
						}
						$b++;
					}
				}
				// watch returns before vuln function gets called
				else if ($token_name === T_RETURN && $this->in_function == 1) {
					$this->userfunction_taints = false;
					$this->userfunction_secures = false;
					$c = 1;
					// get all variables in parameter list
					while ($this->tokens[$i + $c] !== ';') {
						if (is_array($this->tokens[$i + $c])) {
							if ($this->tokens[$i + $c][0] === T_VARIABLE) {
								// check if returned var is secured --> securing function
								$new_find = new CwisSecVulnTreeNode();
								$userinput = $this->scan_parameter(
										$new_find, $new_find, $this->tokens[$i + $c],
		  isset($this->tokens[$i + $c][3]) ? $this->tokens[$i + $c][3] : null, $i + $c, $this->var_declares_local,
		  $this->var_declares_global, false, CwisSecSecuring::secures_all(), TRUE
								);

								// add function to securing functions
								// if it returns no userinput/function param
								if ((!$userinput || $this->userfunction_secures) && !$this->ignore_securing_function) {
									CwisSecSecuring::$F_SECURING_STRING[] = $this->function_obj->name;
								}

								// add function to userinput functions if userinput
								// is fetched in the function and then returned (userinput == 1)
								if ($userinput == 1 || $this->userfunction_taints) {
									$this->source_functions[] = $this->function_obj->name;
								}
							}
							// add function to securing functions if return value is secured
							else if (in_array($this->tokens[$i + $c][1], CwisSecSecuring::secures_all()) || in_array($this->tokens[$i + $c][0],
																								CwisSecTokens::$T_CASTS)) {
								CwisSecSecuring::$F_SECURING_STRING[] = $this->function_obj->name;
								break;
							}
						}
						$c++;
					}
				} else
				/* ============
				  == CLASSES ==
				  ============ */
				// check if token is a class declaration
				if ($token_name === T_CLASS && isset($this->tokens[$i + 1][1])) {
					$i++;
					$this->class_name = $this->tokens[$i][1];
					$this->vuln_classes[$this->class_name] = array();
					$this->in_class = true;
					$this->result_info[] = '<font color="red">Code is object-oriented. This is not supported yet and can lead to false negatives.</font>';
				}
				// build list of vars that are associated with a class
				// $var = new Classname()
				else if ($token_name === T_NEW && $this->tokens[$i - 2][0] === T_VARIABLE) {
					$this->class_vars[$this->tokens[$i - 2][1]] = $this->tokens[$i + 1][1];
				}
				// copy vuln functions from extended classes
				else if ($token_name === T_EXTENDS && $this->in_class) {
					$this->vuln_classes[$this->class_name] = isset($this->vuln_classes[$this->tokens[$i + 1][1]]) ?
							$this->vuln_classes[$this->tokens[$i + 1][1]] : null;
				} else
				/* ==========
				  == OTHER ==
				  ========== */
				// list($drink, $color, $power) = $info;
				if ($token_name === T_LIST) {
					$d = 2;
					while ($this->tokens[$i + $d] !== ')' && $this->tokens[$i + $d] !== ';') {
						$d++;
						if ($this->tokens[$i + $d] === ';' || !isset($this->tokens[$i + $d])) {
							/* addError('Closing parenthesis of list() is missing.', array_slice($this->tokens, $i, 10),
							  $this->tokens[$i][2],
							  $this->file_pointer); */
							break;
						}
					}
					$tokenscanstart = 0;
					if ($this->tokens[$i + $d + 1] === '=' || in_array($this->tokens[$i + $d + 1][0], CwisSecTokens::$T_ASSIGNMENT)) {
						$tokenscanstart = $d + 1;
					}
					$c = 2;
					for ($c = 2; $c < $d; $c++) {
						if (is_array($this->tokens[$i + $c]) && $this->tokens[$i + $c][0] === T_VARIABLE) {
							$this->variable_add(
									$this->tokens[$i + $c][1],
		 array_slice($this->tokens, $i, $this->analyser->get_brace_end($this->tokens, $i) + 1), ' list() ', $tokenscanstart,
																 0, $this->tokens[$i + $c][2], $i,
																 isset($this->tokens[$i + $c][3]) ? $this->tokens[$i + $c][3] : array()
							);
						}
					}
					$i = $i + $c + 2;
				}
				// switch lines pointer back to original code if included tokens end
				else if ($token_name === T_INCLUDE_END) {
					array_pop($this->lines_stack);
					$this->lines_pointer = end($this->lines_stack);
					array_pop($this->inc_file_stack);
					$this->file_pointer = end($this->inc_file_stack);
					$this->comment = basename($this->file_pointer) == basename($this->file_name) ? '' : basename($this->file_pointer);
					$this->tif = array_pop($this->tif_stack);
				}
			} elseif ($i > 0) { // token is not an array
				/* ===========
				  == BRACES ==
				  =========== */
				// keep track of { program blocks }
				// get current dependencies in program flow
				$prev_token = $this->tokens[$i - 1];
				if ($this->tokens[$i] === '{' && ($prev_token === ')' || $prev_token === ':' || $prev_token === ';' // case x:{ or case x;{
						|| (is_array($prev_token) && ($prev_token[0] === T_DO  // do {
						|| $prev_token[0] === T_ELSE // else {
						|| $prev_token[0] === T_STRING // class bla {
						|| $prev_token[0] === T_TRY // try {
						|| $prev_token[0] === T_CATCH)) )) { // catch{
					// save brace amount at start of function
					if ($this->in_function && $this->brace_save_func < 0) {
						$this->brace_save_func = $this->braces_open;
					}

					// save brace amount at start of class
					if ($this->in_class && $this->brace_save_class < 0) {
						$this->brace_save_class = $this->braces_open;
					}

					$this->in_condition = 0;

					if (empty($e)) {
						if (!$this->ignore_requirement) {
							if (!empty($this->dependencytokens) && $this->dependencytokens[0][0] === T_ELSE &&
									(!isset($this->dependencytokens[1][0]) || $this->dependencytokens[1][0] !== T_IF)) {
								$this->dependencytokens = isset($this->last_dependency) ? $this->last_dependency : array();
								$this->dependencytokens[] = array(T_ELSE, 'else',
									isset($this->dependencytokens[0]) ? $this->dependencytokens[0][2] : null);
							}
						} else {
							$this->ignore_requirement = false;
						}

						// add dependency (even push empty dependency on stack, it will get poped again)
						$this->dependencies[$line_nr] = $this->dependencytokens;
						$this->dependencytokens = array();
					} else {
						unset($e);
					}

					$this->braces_open++;
				}
				// before block ending "}" there must be a ";" or another "}". otherwise curly syntax
				else if ($this->tokens[$i] === '}' && ($prev_token === ';' || $prev_token === '}' || $prev_token === '{')) {
					$this->braces_open--;

					// delete current dependency
					$this->last_dependency = array_pop($this->dependencies);
					$this->dependencytokens = array();

					// end of function found if brace amount = amount before function start
					if ($this->in_function && $this->brace_save_func === $this->braces_open) {
						$ref_name = ($this->in_class ? $this->class_name . '::' : '') . $this->function_obj->name;
						// write ending to user_function list for referencing functions in output
						$this->user_functions_offset[$ref_name][2] = $line_nr;
						// reset vars for next function declaration
						$this->brace_save_func = -1;
						$this->ignore_securing_function = false;
						$this->in_function--;
						$this->function_obj = null;
						$this->var_declares_local = array();
						$this->put_in_global_scope = array();
						// load new found vulnerable user functions to current scanlist
						if (isset($this->user_functions[$this->file_name])) {
							$this->scan_functions = array_merge($this->scan_functions, $this->user_functions[$this->file_name]);
						}
					}

					// end of class found
					if ($this->in_class && $this->brace_save_class === $this->braces_open) {
						$this->brace_save_class = -1;
						$this->in_class = false;
					}
				}
			} // token scanned
			//
            // detect if still in a vardeclare, otherwise delete saved infos
			if (isset($vardeclare) && $vardeclare['end'] === $i) {
				unset($vardeclare);
			}
		} // all tokens scanned.

		return $this->inc_map;
	}

}

class CwisSecSecuring
{

	// securing functions in if-clause
	// list not used, all if clause dependencies detected anyway
	static $F_SECURING_BOOL = array(
		'is_bool',
		'is_double',
		'is_float',
		'is_real',
		'is_long',
		'is_int',
		'is_integer',
		'is_null',
		'is_numeric',
		'is_finite',
		'is_infinite',
		'ctype_alnum',
		'ctype_alpha',
		'ctype_cntrl',
		'ctype_digit',
		'ctype_xdigit',
		'ctype_upper',
		'ctype_lower',
		'ctype_space',
		'in_array',
		'preg_match',
		'preg_match_all',
		'fnmatch',
		'ereg',
		'eregi'
	);
	// securing functions for every vulnerability
	static $F_SECURING_STRING = array(
		'intval',
		'floatval',
		'doubleval',
		'filter_input',
		'urlencode',
		'rawurlencode',
		'round',
		'floor',
		'strlen',
		'strrpos',
		'strpos',
		'strftime',
		'strtotime',
		'md5',
		'md5_file',
		'sha1',
		'sha1_file',
		'crypt',
		'crc32',
		'hash',
		'mhash',
		'hash_hmac',
		'password_hash',
		'mcrypt_encrypt',
		'mcrypt_generic',
		'base64_encode',
		'ord',
		'sizeof',
		'count',
		'bin2hex',
		'levenshtein',
		'abs',
		'bindec',
		'decbin',
		'dechex',
		'decoct',
		'hexdec',
		'rand',
		'max',
		'min',
		'metaphone',
		'tempnam',
		'soundex',
		'money_format',
		'number_format',
		'date_format',
		'filetype',
		'nl_langinfo',
		'bzcompress',
		'convert_uuencode',
		'gzdeflate',
		'gzencode',
		'gzcompress',
		'http_build_query',
		'lzf_compress',
		'zlib_encode',
		'imap_binary',
		'iconv_mime_encode',
		'bson_encode',
		'sqlite_udf_encode_binary',
		'session_name',
		'readlink',
		'getservbyport',
		'getprotobynumber',
		'gethostname',
		'gethostbynamel',
		'gethostbyname',
	);
	// functions that insecures the string again
	static $F_INSECURING_STRING = array(
		'base64_decode',
		'htmlspecialchars_decode',
		'html_entity_decode',
		'bzdecompress',
		'chr',
		'convert_uudecode',
		'gzdecode',
		'gzinflate',
		'gzuncompress',
		'lzf_decompress',
		'rawurldecode',
		'urldecode',
		'zlib_decode',
		'imap_base64',
		'imap_utf7_decode',
		'imap_mime_header_decode',
		'iconv_mime_decode',
		'iconv_mime_decode_headers',
		'hex2bin',
		'quoted_printable_decode',
		'imap_qprint',
		'mb_decode_mimeheader',
		'bson_decode',
		'sqlite_udf_decode_binary',
		'utf8_decode',
		'recode_string',
		'recode'
	);
	// securing functions for XSS
	static $F_SECURING_XSS = array(
		'esc_attr',
		'esc_html',
		'esc_js',
		'esc_textarea',
		'esc_url',
		'esc_url_raw',
		'highlight_string',
		'htmlentities',
		'htmlspecialchars',
		'sanitize_email',
		'sanitize_file_name',
		'sanitize_html_class',
		'sanitize_key',
		'sanitize_meta',
		'sanitize_option',
		'sanitize_text_field',
		'sanitize_textarea_field',
		'sanitize_title',
		'wp_filter_nohtml_kses',
		'wp_filter_post_kses',
		'wp_kses',
		'wp_parse_args'
	);
	// securing functions for SQLi
	static $F_SECURING_SQL = array(
		'addslashes',
		'dbx_escape_string',
		'db2_escape_string',
		'ingres_escape_string',
		'maxdb_escape_string',
		'maxdb_real_escape_string',
		'mysql_escape_string',
		'mysql_real_escape_string',
		'mysqli_escape_string',
		'mysqli_real_escape_string',
		'pg_escape_string',
		'pg_escape_bytea',
		'sqlite_escape_string',
		'sqlite_udf_encode_binary',
		'cubrid_real_escape_string',
	);
	// securing functions for RCE with e-modifier in preg_**
	static $F_SECURING_PREG = array(
		'preg_quote'
	);
	// securing functions for file handling
	static $F_SECURING_FILE = array(
		'basename',
		'dirname',
		'pathinfo'
	);
	// securing functions for OS command execution
	static $F_SECURING_SYSTEM = array(
		'escapeshellarg',
		'escapeshellcmd'
	);
	// securing XPath injection
	static $F_SECURING_XPATH = array(
		'addslashes'
	);
	// securing LDAP injection
	static $F_SECURING_LDAP = array(
	);

	// securing functions that work only when embedded in quotes
	//static $F_QUOTE_ANALYSIS = $F_SECURING_SQL;
	//
    // returns property value by its name
	static function get_prop($property)
	{
		if (is_string($property) && isset(CwisSecSecuring::${$property})) {
			$property = self::${$property};
		}
		return $property;
	}

	// all specific securings (formely $F_SECURES_ALL)
	static function secures_all()
	{
		return array_merge(
				self::$F_SECURING_XSS, self::$F_SECURING_SQL, self::$F_SECURING_PREG, self::$F_SECURING_FILE,
	self::$F_SECURING_SYSTEM, self::$F_SECURING_XPATH
		);
	}

}

class CwisSecSinks
{

	// cross-site scripting affected functions
	// parameter = 0 means, all parameters will be traced
	// securing with CwisSecSecuring::$F_SECURING_XSS
	static $NAME_XSS = 'Cross-Site Scripting';
	static $F_XSS = array(
		'echo'				 => array(array(0), 'F_SECURING_XSS'),
		'print'				 => array(array(1), 'F_SECURING_XSS'),
		'print_r'			 => array(array(1), 'F_SECURING_XSS'),
		'exit'				 => array(array(1), 'F_SECURING_XSS'),
		'die'				 => array(array(1), 'F_SECURING_XSS'),
		'printf'			 => array(array(0), 'F_SECURING_XSS'),
		'vprintf'			 => array(array(0), 'F_SECURING_XSS'),
		'trigger_error'		 => array(array(1), 'F_SECURING_XSS'),
		'user_error'		 => array(array(1), 'F_SECURING_XSS'),
		'odbc_result_all'	 => array(array(2), 'F_SECURING_XSS'),
		'ovrimos_result_all' => array(array(2), 'F_SECURING_XSS'),
		'ifx_htmltbl_result' => array(array(2), 'F_SECURING_XSS'),
	);
	// HTTP header injections
	static $NAME_HTTP_HEADER = 'HTTP Response Splitting';
	static $F_HTTP_HEADER = array(
		'header' => array(array(1), array())
	);
	// session fixation
	static $NAME_SESSION_FIXATION = 'Session Fixation';
	static $F_SESSION_FIXATION = array(
		'setcookie'		 => array(array(2), array()),
		'setrawcookie'	 => array(array(2), array()),
		'session_id'	 => array(array(1), array())
	);
	// code evaluating functions  => (parameters to scan, securing functions)
	// example parameter array(1,3) will trace only first and third parameter
	// securing with CwisSecSecuring::$F_SECURING_PREG
	static $NAME_CODE = 'Code Execution';
	static $F_CODE = array(
		'assert'				 => array(array(1), array()),
		'create_function'		 => array(array(1, 2), array()),
		'eval'					 => array(array(1), array()),
		'mb_ereg_replace'		 => array(array(1, 2), 'F_SECURING_PREG'),
		'mb_eregi_replace'		 => array(array(1, 2), 'F_SECURING_PREG'),
		'preg_filter'			 => array(array(1, 2), 'F_SECURING_PREG'),
		'preg_replace'			 => array(array(1, 2), 'F_SECURING_PREG'),
		'preg_replace_callback'	 => array(array(1), 'F_SECURING_PREG'),
	);
	// reflection injection
	static $NAME_REFLECTION = 'Reflection Injection';
	static $F_REFLECTION = array(
		'event_buffer_new'			 => array(array(2, 3, 4), array()),
		'event_set'					 => array(array(4), array()),
		'iterator_apply'			 => array(array(2), array()),
		'forward_static_call'		 => array(array(1), array()),
		'forward_static_call_array'	 => array(array(1), array()),
		'call_user_func'			 => array(array(1), array()),
		'call_user_func_array'		 => array(array(1), array()),
		'array_diff_uassoc'			 => array(array(3), array()),
		'array_diff_ukey'			 => array(array(3), array()),
		'array_filter'				 => array(array(2), array()),
		'array_intersect_uassoc'	 => array(array(3), array()),
		'array_intersect_ukey'		 => array(array(3), array()),
		'array_map'					 => array(array(1), array()),
		'array_reduce'				 => array(array(2), array()),
		'array_udiff'				 => array(array(3), array()),
		'array_udiff_assoc'			 => array(array(3), array()),
		'array_udiff_uassoc'		 => array(array(3, 4), array()),
		'array_uintersect'			 => array(array(3), array()),
		'array_uintersect_assoc'	 => array(array(3), array()),
		'array_uintersect_uassoc'	 => array(array(3, 4), array()),
		'array_walk'				 => array(array(2), array()),
		'array_walk_recursive'		 => array(array(2), array()),
		'assert_options'			 => array(array(2), array()),
		'ob_start'					 => array(array(1), array()),
		'register_shutdown_function' => array(array(1), array()),
		'register_tick_function'	 => array(array(1), array()),
		'runkit_method_add'			 => array(array(1, 2, 3, 4), array()),
		'runkit_method_copy'		 => array(array(1, 2, 3), array()),
		'runkit_method_redefine'	 => array(array(1, 2, 3, 4), array()),
		'runkit_method_rename'		 => array(array(1, 2, 3), array()),
		'runkit_function_add'		 => array(array(1, 2, 3), array()),
		'runkit_function_copy'		 => array(array(1, 2), array()),
		'runkit_function_redefine'	 => array(array(1, 2, 3), array()),
		'runkit_function_rename'	 => array(array(1, 2), array()),
		'session_set_save_handler'	 => array(array(1, 2, 3, 4, 5), array()),
		'set_error_handler'			 => array(array(1), array()),
		'set_exception_handler'		 => array(array(1), array()),
		'spl_autoload'				 => array(array(1), array()),
		'spl_autoload_register'		 => array(array(1), array()),
		'sqlite_create_aggregate'	 => array(array(2, 3, 4), array()),
		'sqlite_create_function'	 => array(array(2, 3), array()),
		'stream_wrapper_register'	 => array(array(2), array()),
		'uasort'					 => array(array(2), array()),
		'uksort'					 => array(array(2), array()),
		'usort'						 => array(array(2), array()),
		'yaml_parse'				 => array(array(4), array()),
		'yaml_parse_file'			 => array(array(4), array()),
		'yaml_parse_url'			 => array(array(4), array()),
		'eio_busy'					 => array(array(3), array()),
		'eio_chmod'					 => array(array(4), array()),
		'eio_chown'					 => array(array(5), array()),
		'eio_close'					 => array(array(3), array()),
		'eio_custom'				 => array(array(1, 2), array()),
		'eio_dup2'					 => array(array(4), array()),
		'eio_fallocate'				 => array(array(6), array()),
		'eio_fchmod'				 => array(array(4), array()),
		'eio_fchown'				 => array(array(5), array()),
		'eio_fdatasync'				 => array(array(3), array()),
		'eio_fstat'					 => array(array(3), array()),
		'eio_fstatvfs'				 => array(array(3), array()),
		'preg_replace_callback'		 => array(array(2), array()),
		'dotnet_load'				 => array(array(1), array()),
	);
	// file inclusion functions => (parameters to scan, securing functions)
	// securing with CwisSecSecuring::$F_SECURING_FILE
	static $NAME_FILE_INCLUDE = 'File Inclusion';
	static $F_FILE_INCLUDE = array(
		'include'				 => array(array(1), 'F_SECURING_FILE'),
		'include_once'			 => array(array(1), 'F_SECURING_FILE'),
		'parsekit_compile_file'	 => array(array(1), 'F_SECURING_FILE'),
		'php_check_syntax'		 => array(array(1), 'F_SECURING_FILE'),
		'require'				 => array(array(1), 'F_SECURING_FILE'),
		'require_once'			 => array(array(1), 'F_SECURING_FILE'),
		'runkit_import'			 => array(array(1), 'F_SECURING_FILE'),
		'set_include_path'		 => array(array(1), 'F_SECURING_FILE'),
		'virtual'				 => array(array(1), 'F_SECURING_FILE'),
	);
	// file affecting functions  => (parameters to scan, securing functions)
	// file handler functions like fopen() are added as parameter
	// for functions that use them like fread() and fwrite()
	// securing with CwisSecSecuring::$F_SECURING_FILE
	static $NAME_FILE_READ = 'File Disclosure';
	static $F_FILE_READ = array(
		'bzread'					 => array(array(1), 'F_SECURING_FILE'),
		'bzflush'					 => array(array(1), 'F_SECURING_FILE'),
		'dio_read'					 => array(array(1), 'F_SECURING_FILE'),
		'eio_readdir'				 => array(array(1), 'F_SECURING_FILE'),
		'fdf_open'					 => array(array(1), 'F_SECURING_FILE'),
		'file'						 => array(array(1), 'F_SECURING_FILE'),
		'file_get_contents'			 => array(array(1), 'F_SECURING_FILE'),
		'finfo_file'				 => array(array(1, 2), array()),
		'fflush'					 => array(array(1), 'F_SECURING_FILE'),
		'fgetc'						 => array(array(1), 'F_SECURING_FILE'),
		'fgetcsv'					 => array(array(1), 'F_SECURING_FILE'),
		'fgets'						 => array(array(1), 'F_SECURING_FILE'),
		'fgetss'					 => array(array(1), 'F_SECURING_FILE'),
		'fread'						 => array(array(1), 'F_SECURING_FILE'),
		'fpassthru'					 => array(array(1, 2), array()),
		'fscanf'					 => array(array(1), 'F_SECURING_FILE'),
		'ftok'						 => array(array(1), 'F_SECURING_FILE'),
		'get_meta_tags'				 => array(array(1), 'F_SECURING_FILE'),
		'glob'						 => array(array(1), array()),
		'gzfile'					 => array(array(1), 'F_SECURING_FILE'),
		'gzgetc'					 => array(array(1), 'F_SECURING_FILE'),
		'gzgets'					 => array(array(1), 'F_SECURING_FILE'),
		'gzgetss'					 => array(array(1), 'F_SECURING_FILE'),
		'gzread'					 => array(array(1), 'F_SECURING_FILE'),
		'gzpassthru'				 => array(array(1), 'F_SECURING_FILE'),
		'highlight_file'			 => array(array(1), 'F_SECURING_FILE'),
		'imagecreatefrompng'		 => array(array(1), 'F_SECURING_FILE'),
		'imagecreatefromjpg'		 => array(array(1), 'F_SECURING_FILE'),
		'imagecreatefromgif'		 => array(array(1), 'F_SECURING_FILE'),
		'imagecreatefromgd2'		 => array(array(1), 'F_SECURING_FILE'),
		'imagecreatefromgd2part'	 => array(array(1), 'F_SECURING_FILE'),
		'imagecreatefromgd'			 => array(array(1), 'F_SECURING_FILE'),
		'opendir'					 => array(array(1), 'F_SECURING_FILE'),
		'parse_ini_file'			 => array(array(1), 'F_SECURING_FILE'),
		'php_strip_whitespace'		 => array(array(1), 'F_SECURING_FILE'),
		'readfile'					 => array(array(1), 'F_SECURING_FILE'),
		'readgzfile'				 => array(array(1), 'F_SECURING_FILE'),
		'readlink'					 => array(array(1), 'F_SECURING_FILE'),
		//'stat'						=> array(array(1), array()),
		'scandir'					 => array(array(1), 'F_SECURING_FILE'),
		'show_source'				 => array(array(1), 'F_SECURING_FILE'),
		'simplexml_load_file'		 => array(array(1), 'F_SECURING_FILE'),
		'stream_get_contents'		 => array(array(1), 'F_SECURING_FILE'),
		'stream_get_line'			 => array(array(1), 'F_SECURING_FILE'),
		'xdiff_file_bdiff'			 => array(array(1, 2), 'F_SECURING_FILE'),
		'xdiff_file_bpatch'			 => array(array(1, 2), 'F_SECURING_FILE'),
		'xdiff_file_diff_binary'	 => array(array(1, 2), 'F_SECURING_FILE'),
		'xdiff_file_diff'			 => array(array(1, 2), 'F_SECURING_FILE'),
		'xdiff_file_merge3'			 => array(array(1, 2, 3), 'F_SECURING_FILE'),
		'xdiff_file_patch_binary'	 => array(array(1, 2), 'F_SECURING_FILE'),
		'xdiff_file_patch'			 => array(array(1, 2), 'F_SECURING_FILE'),
		'xdiff_file_rabdiff'		 => array(array(1, 2), 'F_SECURING_FILE'),
		'yaml_parse_file'			 => array(array(1), 'F_SECURING_FILE'),
		'zip_open'					 => array(array(1), 'F_SECURING_FILE'),
	);
	// file or file system affecting functions
	static $NAME_FILE_AFFECT = 'File Manipulation';
	static $F_FILE_AFFECT = array(
		'bzwrite'					 => array(array(2), array()),
		'chmod'						 => array(array(1), 'F_SECURING_FILE'),
		'chgrp'						 => array(array(1), 'F_SECURING_FILE'),
		'chown'						 => array(array(1), 'F_SECURING_FILE'),
		'copy'						 => array(array(1), array()),
		'dio_write'					 => array(array(1, 2), array()),
		'eio_chmod'					 => array(array(1), 'F_SECURING_FILE'),
		'eio_chown'					 => array(array(1), 'F_SECURING_FILE'),
		'eio_mkdir'					 => array(array(1), 'F_SECURING_FILE'),
		'eio_mknod'					 => array(array(1), 'F_SECURING_FILE'),
		'eio_rmdir'					 => array(array(1), 'F_SECURING_FILE'),
		'eio_write'					 => array(array(1, 2), array()),
		'eio_unlink'				 => array(array(1), 'F_SECURING_FILE'),
		'error_log'					 => array(array(3), 'F_SECURING_FILE'),
		'event_buffer_write'		 => array(array(2), array()),
		'file_put_contents'			 => array(array(1, 2), 'F_SECURING_FILE'),
		'fputcsv'					 => array(array(1, 2), 'F_SECURING_FILE'),
		'fputs'						 => array(array(1, 2), 'F_SECURING_FILE'),
		'fprintf'					 => array(array(0), array()),
		'ftruncate'					 => array(array(1), 'F_SECURING_FILE'),
		'fwrite'					 => array(array(1, 2), 'F_SECURING_FILE'),
		'gzwrite'					 => array(array(1, 2), array()),
		'gzputs'					 => array(array(1, 2), array()),
		'loadXML'					 => array(array(1), array()),
		'mkdir'						 => array(array(1), array()),
		'move_uploaded_file'		 => array(array(1, 2), 'F_SECURING_FILE'),
		'posix_mknod'				 => array(array(1), 'F_SECURING_FILE'),
		'recode_file'				 => array(array(2, 3), 'F_SECURING_FILE'),
		'rename'					 => array(array(1, 2), 'F_SECURING_FILE'),
		'rmdir'						 => array(array(1), 'F_SECURING_FILE'),
		'shmop_write'				 => array(array(2), array()),
		'touch'						 => array(array(1), 'F_SECURING_FILE'),
		'unlink'					 => array(array(1), 'F_SECURING_FILE'),
		'vfprintf'					 => array(array(0), array()),
		'xdiff_file_bdiff'			 => array(array(3), 'F_SECURING_FILE'),
		'xdiff_file_bpatch'			 => array(array(3), 'F_SECURING_FILE'),
		'xdiff_file_diff_binary'	 => array(array(3), 'F_SECURING_FILE'),
		'xdiff_file_diff'			 => array(array(3), 'F_SECURING_FILE'),
		'xdiff_file_merge3'			 => array(array(4), 'F_SECURING_FILE'),
		'xdiff_file_patch_binary'	 => array(array(3), 'F_SECURING_FILE'),
		'xdiff_file_patch'			 => array(array(3), 'F_SECURING_FILE'),
		'xdiff_file_rabdiff'		 => array(array(3), 'F_SECURING_FILE'),
		'yaml_emit_file'			 => array(array(1, 2), 'F_SECURING_FILE'),
	);
	// OS Command executing functions => (parameters to scan, securing functions)
	// securing with CwisSecSecuring::$F_SECURING_SYSTEM
	static $NAME_EXEC = 'Command Execution';
	static $F_EXEC = array(
		'backticks'					 => array(array(1), 'F_SECURING_SYSTEM'), # transformed during parsing
		'exec'						 => array(array(1), 'F_SECURING_SYSTEM'),
		'expect_popen'				 => array(array(1), 'F_SECURING_SYSTEM'),
		'passthru'					 => array(array(1), 'F_SECURING_SYSTEM'),
		'pcntl_exec'				 => array(array(1), 'F_SECURING_SYSTEM'),
		'popen'						 => array(array(1), 'F_SECURING_SYSTEM'),
		'proc_open'					 => array(array(1), 'F_SECURING_SYSTEM'),
		'shell_exec'				 => array(array(1), 'F_SECURING_SYSTEM'),
		'system'					 => array(array(1), 'F_SECURING_SYSTEM'),
		'mail'						 => array(array(5), array()), // http://esec-pentest.sogeti.com/web/using-mail-remote-code-execution
		'mb_send_mail'				 => array(array(5), array()),
		'w32api_invoke_function'	 => array(array(1), array()),
		'w32api_register_function'	 => array(array(2), array()),
	);
	// SQL executing functions => (parameters to scan, securing functions)
	// securing with CwisSecSecuring::$F_SECURING_SQL
	static $NAME_DATABASE = 'SQL Injection';
	static $F_DATABASE = array(
		// Abstraction Layers
		'dba_open'					 => array(array(1), array()),
		'dba_popen'					 => array(array(1), array()),
		'dba_insert'				 => array(array(1, 2), array()),
		'dba_fetch'					 => array(array(1), array()),
		'dba_delete'				 => array(array(1), array()),
		'dbx_query'					 => array(array(2), 'F_SECURING_SQL'),
		'odbc_do'					 => array(array(2), 'F_SECURING_SQL'),
		'odbc_exec'					 => array(array(2), 'F_SECURING_SQL'),
		'odbc_execute'				 => array(array(2), 'F_SECURING_SQL'),
		// Vendor Specific
		'db2_exec'					 => array(array(2), 'F_SECURING_SQL'),
		'db2_execute'				 => array(array(2), 'F_SECURING_SQL'),
		'fbsql_db_query'			 => array(array(2), 'F_SECURING_SQL'),
		'fbsql_query'				 => array(array(1), 'F_SECURING_SQL'),
		'ibase_query'				 => array(array(2), 'F_SECURING_SQL'),
		'ibase_execute'				 => array(array(1), 'F_SECURING_SQL'),
		'ifx_query'					 => array(array(1), 'F_SECURING_SQL'),
		'ifx_do'					 => array(array(1), 'F_SECURING_SQL'),
		'ingres_query'				 => array(array(2), 'F_SECURING_SQL'),
		'ingres_execute'			 => array(array(2), 'F_SECURING_SQL'),
		'ingres_unbuffered_query'	 => array(array(2), 'F_SECURING_SQL'),
		'msql_db_query'				 => array(array(2), 'F_SECURING_SQL'),
		'msql_query'				 => array(array(1), 'F_SECURING_SQL'),
		'msql'						 => array(array(2), 'F_SECURING_SQL'),
		'mssql_query'				 => array(array(1), 'F_SECURING_SQL'),
		'mssql_execute'				 => array(array(1), 'F_SECURING_SQL'),
		'mysql_db_query'			 => array(array(2), 'F_SECURING_SQL'),
		'mysql_query'				 => array(array(1), 'F_SECURING_SQL'),
		'mysql_unbuffered_query'	 => array(array(1), 'F_SECURING_SQL'),
		'mysqli_stmt_execute'		 => array(array(1), 'F_SECURING_SQL'),
		'mysqli_query'				 => array(array(2), 'F_SECURING_SQL'),
		'mysqli_real_query'			 => array(array(1), 'F_SECURING_SQL'),
		'mysqli_master_query'		 => array(array(2), 'F_SECURING_SQL'),
		'oci_execute'				 => array(array(1), array()),
		'ociexecute'				 => array(array(1), array()),
		'ovrimos_exec'				 => array(array(2), 'F_SECURING_SQL'),
		'ovrimos_execute'			 => array(array(2), 'F_SECURING_SQL'),
		'ora_do'					 => array(array(2), array()),
		'ora_exec'					 => array(array(1), array()),
		'pg_query'					 => array(array(2), 'F_SECURING_SQL'),
		'pg_send_query'				 => array(array(2), 'F_SECURING_SQL'),
		'pg_send_query_params'		 => array(array(2), 'F_SECURING_SQL'),
		'pg_send_prepare'			 => array(array(3), 'F_SECURING_SQL'),
		'pg_prepare'				 => array(array(3), 'F_SECURING_SQL'),
		'sqlite_open'				 => array(array(1), 'F_SECURING_SQL'),
		'sqlite_popen'				 => array(array(1), 'F_SECURING_SQL'),
		'sqlite_array_query'		 => array(array(1, 2), 'F_SECURING_SQL'),
		'arrayQuery'				 => array(array(1, 2), 'F_SECURING_SQL'),
		'singleQuery'				 => array(array(1), 'F_SECURING_SQL'),
		'sqlite_query'				 => array(array(1, 2), 'F_SECURING_SQL'),
		'sqlite_exec'				 => array(array(1, 2), 'F_SECURING_SQL'),
		'sqlite_single_query'		 => array(array(2), 'F_SECURING_SQL'),
		'sqlite_unbuffered_query'	 => array(array(1, 2), 'F_SECURING_SQL'),
		'sybase_query'				 => array(array(1), 'F_SECURING_SQL'),
		'sybase_unbuffered_query'	 => array(array(1), 'F_SECURING_SQL'),
	);
	// XPath injection
	// securing with CwisSecSecuring::$F_SECURING_XPATH
	static $NAME_XPATH = 'XPath Injection';
	static $F_XPATH = array(
		'xpath_eval'			 => array(array(2), 'F_SECURING_XPATH'),
		'xpath_eval_expression'	 => array(array(2), 'F_SECURING_XPATH'),
		'xptr_eval'				 => array(array(2), 'F_SECURING_XPATH'),
	);
	// LDAP injection
	// securing with CwisSecSecuring::$F_SECURING_LDAP
	static $NAME_LDAP = 'LDAP Injection';
	static $F_LDAP = array(
		'ldap_add'		 => array(array(2, 3), 'F_SECURING_LDAP'),
		'ldap_delete'	 => array(array(2), 'F_SECURING_LDAP'),
		'ldap_list'		 => array(array(3), 'F_SECURING_LDAP'),
		'ldap_read'		 => array(array(3), 'F_SECURING_LDAP'),
		'ldap_search'	 => array(array(3), 'F_SECURING_LDAP'),
	);
	// connection handling functions
	static $NAME_CONNECT = 'Protocol Injection';
	static $F_CONNECT = array(
		'curl_setopt'			 => array(array(2, 3), array()),
		'curl_setopt_array'		 => array(array(2), array()),
		'cyrus_query'			 => array(array(2), array()),
		'error_log'				 => array(array(3), array()),
		'fsockopen'				 => array(array(1), array()),
		'ftp_chmod'				 => array(array(2, 3), array()),
		'ftp_exec'				 => array(array(2), array()),
		'ftp_delete'			 => array(array(2), array()),
		'ftp_fget'				 => array(array(3), array()),
		'ftp_get'				 => array(array(2, 3), array()),
		'ftp_nlist'				 => array(array(2), array()),
		'ftp_nb_fget'			 => array(array(3), array()),
		'ftp_nb_get'			 => array(array(2, 3), array()),
		'ftp_nb_put'			 => array(array(2), array()),
		'ftp_put'				 => array(array(2, 3), array()),
		'get_headers'			 => array(array(1), array()),
		'imap_open'				 => array(array(1), array()),
		'imap_mail'				 => array(array(1), array()),
		'mail'					 => array(array(1, 4), array()),
		'mb_send_mail'			 => array(array(1, 4), array()),
		'ldap_connect'			 => array(array(1), array()),
		'msession_connect'		 => array(array(1), array()),
		'pfsockopen'			 => array(array(1), array()),
		'session_register'		 => array(array(0), array()),
		'socket_bind'			 => array(array(2), array()),
		'socket_connect'		 => array(array(2), array()),
		'socket_send'			 => array(array(2), array()),
		'socket_write'			 => array(array(2), array()),
		'stream_socket_client'	 => array(array(1), array()),
		'stream_socket_server'	 => array(array(1), array()),
		'printer_open'			 => array(array(1), array())
	);
	// other critical functions
	static $NAME_OTHER = 'Possible Flow Control'; // :X
	static $F_OTHER = array(
		'dl'						 => array(array(1), array()),
		'ereg'						 => array(array(2), array()), # nullbyte injection affected
		'eregi'						 => array(array(2), array()), # nullbyte injection affected
		'ini_set'					 => array(array(1, 2), array()),
		'ini_restore'				 => array(array(1), array()),
		'runkit_constant_redefine'	 => array(array(1, 2), array()),
		'runkit_method_rename'		 => array(array(1, 2, 3), array()),
		'sleep'						 => array(array(1), array()),
		'usleep'					 => array(array(1), array()),
		'extract'					 => array(array(1), array()),
		'mb_parse_str'				 => array(array(1), array()),
		'parse_str'					 => array(array(1), array()),
		'putenv'					 => array(array(1), array()),
		'set_include_path'			 => array(array(1), array()),
		'apache_setenv'				 => array(array(1, 2), array()),
		'define'					 => array(array(1), array()),
		'is_a'						 => array(array(1), array()) // calls __autoload()
	);
	// property oriented programming with unserialize
	static $NAME_POP = 'PHP Object Injection';
	static $F_POP = array(
		'unserialize'	 => array(array(1), array()), // calls gadgets
		'yaml_parse'	 => array(array(1), array())  // calls unserialize
	);
	// vuln type counters
	static $count_xss = 0;
	static $count_header = 0;
	static $count_sf = 0;
	static $count_sqli = 0;
	static $count_fr = 0;
	static $count_fa = 0;
	static $count_fi = 0;
	static $count_con = 0;
	static $count_exec = 0;
	static $count_code = 0;
	static $count_ri = 0;
	static $count_xpath = 0;
	static $count_ldap = 0;
	static $count_pop = 0;
	static $count_other = 0;

	// detect vulnerability type given by the PVF name
	// note: same names are used in help.php!
	static function increaseVulnCounter($func_name)
	{
		if (isset(self::$F_XSS[$func_name])) {
			self::$count_xss ++;
		} else if (isset(self::$F_HTTP_HEADER[$func_name])) {
			self::$count_header ++;
		} else if (isset(self::$F_SESSION_FIXATION[$func_name])) {
			self::$count_sf ++;
		} else if (isset(self::$F_DATABASE[$func_name])) {
			self::$count_sqli ++;
		} else if (isset(self::$F_FILE_READ[$func_name])) {
			self::$count_fr ++;
		} else if (isset(self::$F_FILE_AFFECT[$func_name])) {
			self::$count_fa ++;
		} else if (isset(self::$F_FILE_INCLUDE[$func_name])) {
			self::$count_fi ++;
		} else if (isset(self::$F_CONNECT[$func_name])) {
			self::$count_con ++;
		} else if (isset(self::$F_EXEC[$func_name])) {
			self::$count_exec ++;
		} else if (isset(self::$F_CODE[$func_name])) {
			self::$count_code ++;
		} else if (isset(self::$F_REFLECTION[$func_name])) {
			self::$count_ri ++;
		} else if (isset(self::$F_XPATH[$func_name])) {
			self::$count_xpath ++;
		} else if (isset(self::$F_LDAP[$func_name])) {
			self::$count_ldap ++;
		} else if (isset(self::$F_POP[$func_name])) {
			self::$count_pop ++;
		} else if (isset(self::$F_OTHER[$func_name])) {
			self::$count_other ++;
		} // :X
	}

	// detect vulnerability type given by the PVF name
	// note: same names are used in help.php!
	static function getVulnNodeTitle($func_name)
	{
		if (isset(self::$F_XSS[$func_name])) {
			$vulnname = self::$NAME_XSS;
		} else if (isset(self::$F_HTTP_HEADER[$func_name])) {
			$vulnname = self::$NAME_HTTP_HEADER;
		} else if (isset(self::$F_SESSION_FIXATION[$func_name])) {
			$vulnname = self::$NAME_SESSION_FIXATION;
		} else if (isset(self::$F_DATABASE[$func_name])) {
			$vulnname = self::$NAME_DATABASE;
		} else if (isset(self::$F_FILE_READ[$func_name])) {
			$vulnname = self::$NAME_FILE_READ;
		} else if (isset(self::$F_FILE_AFFECT[$func_name])) {
			$vulnname = self::$NAME_FILE_AFFECT;
		} else if (isset(self::$F_FILE_INCLUDE[$func_name])) {
			$vulnname = self::$NAME_FILE_INCLUDE;
		} else if (isset(self::$F_CONNECT[$func_name])) {
			$vulnname = self::$NAME_CONNECT;
		} else if (isset(self::$F_EXEC[$func_name])) {
			$vulnname = self::$NAME_EXEC;
		} else if (isset(self::$F_CODE[$func_name])) {
			$vulnname = self::$NAME_CODE;
		} else if (isset(self::$F_REFLECTION[$func_name])) {
			$vulnname = self::$NAME_REFLECTION;
		} else if (isset(self::$F_XPATH[$func_name])) {
			$vulnname = self::$NAME_XPATH;
		} else if (isset(self::$F_LDAP[$func_name])) {
			$vulnname = self::$NAME_LDAP;
		} else if (isset(self::$F_POP[$func_name])) {
			$vulnname = self::$NAME_POP;
		} else if (isset(self::$F_OTHER[$func_name])) {
			$vulnname = self::$NAME_OTHER;
		} // :X
		else {
			$vulnname = "unknown";
		}
		return $vulnname;
	}

}

class CwisSecSources
{

	// userinput variables
	static $V_USERINPUT = array(
		'$_GET',
		'$_POST',
		'$_COOKIE',
		'$_REQUEST',
		'$_FILES',
		'$_SERVER',
		'$HTTP_GET_VARS',
		'$HTTP_POST_VARS',
		'$HTTP_COOKIE_VARS',
		'$HTTP_REQUEST_VARS',
		'$HTTP_POST_FILES',
		'$HTTP_SERVER_VARS',
		'$HTTP_RAW_POST_DATA',
		'$argc',
		'$argv'
	);
	static $V_SERVER_PARAMS = array(
		'HTTP_ACCEPT',
		'HTTP_ACCEPT_LANGUAGE',
		'HTTP_ACCEPT_ENCODING',
		'HTTP_ACCEPT_CHARSET',
		'HTTP_CONNECTION',
		'HTTP_HOST',
		'HTTP_KEEP_ALIVE',
		'HTTP_REFERER',
		'HTTP_USER_AGENT',
		'HTTP_X_FORWARDED_FOR',
		// all HTTP_ headers can be tainted
		'PHP_AUTH_DIGEST',
		'PHP_AUTH_USER',
		'PHP_AUTH_PW',
		'AUTH_TYPE',
		'QUERY_STRING',
		'REQUEST_METHOD',
		'REQUEST_URI', // partly urlencoded
		'PATH_INFO',
		'ORIG_PATH_INFO',
		'PATH_TRANSLATED',
		'REMOTE_HOSTNAME',
		'PHP_SELF'
	);
	// file content as input
	static $F_FILE_INPUT = array(
		'bzread',
		'dio_read',
		'exif_imagetype',
		'exif_read_data',
		'exif_thumbnail',
		'fgets',
		'fgetss',
		'file',
		'file_get_contents',
		'fread',
		'get_meta_tags',
		'glob',
		'gzread',
		'readdir',
		'read_exif_data',
		'scandir',
		'zip_read'
	);
	// database content as input
	static $F_DATABASE_INPUT = array(
		'mysql_fetch_array',
		'mysql_fetch_assoc',
		'mysql_fetch_field',
		'mysql_fetch_object',
		'mysql_fetch_row',
		'pg_fetch_all',
		'pg_fetch_array',
		'pg_fetch_assoc',
		'pg_fetch_object',
		'pg_fetch_result',
		'pg_fetch_row',
		'sqlite_fetch_all',
		'sqlite_fetch_array',
		'sqlite_fetch_object',
		'sqlite_fetch_single',
		'sqlite_fetch_string'
	);
	// other functions as input
	static $F_OTHER_INPUT = array(
		'get_headers',
		'getallheaders',
		'get_browser',
		'getenv',
		'gethostbyaddr',
		'runkit_superglobals',
		'import_request_variables'
	);

	//	'getenv' and 'apache_getenv'
	// will be automatically added if 'putenv' or 'apache_setenv' with userinput is found
}

class CwisSecTokenizer
{

	var $filename;
	var $tokens;

	function __construct($filename)
	{
		$this->filename = $filename;
	}

	// main
	function tokenize($code)
	{
		$this->tokens = token_get_all($code);
		$this->prepare_tokens();
		$this->array_reconstruct_tokens();
		$this->fix_tokens();
		$this->fix_ternary();
		#die(print_r($this->tokens));
		return $this->tokens;
	}

	// adds braces around offsets
	function wrap_braces($start, $between, $end)
	{
		$this->tokens = array_merge(
				array_slice($this->tokens, 0, $start), array('{'), array_slice($this->tokens, $start, $between), array('}'),
																   array_slice($this->tokens, $end)
		);
	}

	// deletes all tokens to ignore while scanning, mostly whitespaces
	function prepare_tokens()
	{
		// delete whitespaces and other unimportant tokens, rewrite some special tokens
		for ($i = 0, $max = count($this->tokens); $i < $max; $i++) {
			if (is_array($this->tokens[$i])) {
				if (in_array($this->tokens[$i][0], CwisSecTokens::$T_IGNORE)) {
					unset($this->tokens[$i]);
				} else if ($this->tokens[$i][0] === T_CLOSE_TAG) {
					$this->tokens[$i] = ';';
				} else if ($this->tokens[$i][0] === T_OPEN_TAG_WITH_ECHO) {
					$this->tokens[$i][1] = 'echo';
				}
			}
			// @ (depress errors) disturbs connected token handling
			else if ($this->tokens[$i] === '@') {
				unset($this->tokens[$i]);
			}
			// rewrite $array{index} to $array[index]
			else if ($this->tokens[$i] === '{' &&
					((is_array($this->tokens[$i - 1]) && $this->tokens[$i - 1][0] === T_VARIABLE) ||
					$this->tokens[$i - 1] === ']')) {
				$this->tokens[$i] = '[';
				$f = 1;
				while ($this->tokens[$i + $f] !== '}') {
					$f++;
					if (!isset($this->tokens[$i + $f])) {
						/* addError('Could not find closing brace of ' . $this->tokens[$i - 1][1] . '{}.',
						  array_slice($this->tokens, $i - 1, 2), $this->tokens[$i - 1][2], $this->filename); */
						break;
					}
				}
				$this->tokens[$i + $f] = ']';
			}
		}

		// rearranged key index of tokens
		$this->tokens = array_values($this->tokens);
	}

	// some tokenchains need to be fixed to scan correctly later
	function fix_tokens()
	{
		$max = count($this->tokens);
		for ($i = 0; $i < $max; $i++) {
			// convert `backticks` to backticks()
			if ($this->tokens[$i] === '`') {
				$f = 1;
				while ($i + $f < $max && $this->tokens[$i + $f] !== '`') {
					// get line_nr of any near token
					if (is_array($this->tokens[$i + $f])) {
						$line_nr = $this->tokens[$i + $f][2];
					}

					$f++;
					if (!isset($this->tokens[$i + $f]) || $this->tokens[$i + $f] === ';') {
						/* addError('Could not find closing backtick `.', array_slice($this->tokens, $i, 5),
						  $this->tokens[$i + 1][2],
						  $this->filename); */
						break;
					}
				}
				if (!empty($line_nr)) {
					$this->tokens[$i + $f] = ')';
					$this->tokens[$i] = array(T_STRING, 'backticks', $line_nr);

					// add element backticks() to array
					$this->tokens = array_merge(
							array_slice($this->tokens, 0, $i + 1), array('('), array_slice($this->tokens, $i + 1)
					);
				}
			}
			// real token
			else if (is_array($this->tokens[$i])) {
				// rebuild if-clauses, for(), foreach(), while() without { }
				if (($this->tokens[$i][0] === T_IF || $this->tokens[$i][0] === T_ELSEIF ||
						$this->tokens[$i][0] === T_FOR || $this->tokens[$i][0] === T_FOREACH ||
						$this->tokens[$i][0] === T_WHILE) && $this->tokens[$i + 1] === '(') {
					// skip condition in ( )
					$f = 2;
					$braceopen = 1;
					while ($i + $f < $max && $braceopen !== 0) {
						if ($this->tokens[$i + $f] === '(') {
							$braceopen++;
						} else if ($this->tokens[$i + $f] === ')') {
							$braceopen--;
						}
						$f++;

						if (!isset($this->tokens[$i + $f])) {
							/* addError('Could not find closing parenthesis of ' . $this->tokens[$i][1] . '-statement.',
							  array_slice($this->tokens, $i, 5), $this->tokens[$i][2], $this->filename); */
							break;
						}
					}

					// alternate syntax while(): endwhile;
					if ($this->tokens[$i + $f] === ':') {
						switch ($this->tokens[$i][0]) {
							case T_IF:
							case T_ELSEIF: $endtoken = T_ENDIF;
								break;
							case T_FOR: $endtoken = T_ENDFOR;
								break;
							case T_FOREACH: $endtoken = T_ENDFOREACH;
								break;
							case T_WHILE: $endtoken = T_ENDWHILE;
								break;
							default: $endtoken = ';';
						}

						$c = 1;
						while ($this->tokens[$i + $f + $c][0] !== $endtoken) {
							$c++;
							if (!isset($this->tokens[$i + $f + $c])) {
								/* addError('Could not find end' . $this->tokens[$i][1] . '; of alternate ' . $this->tokens[$i][1] . '-statement.',
								  array_slice($this->tokens, $i, $f + 1), $this->tokens[$i][2], $this->filename); */
								break;
							}
						}
						$this->wrap_braces($i + $f + 1, $c + 1, $i + $f + $c + 2);
					}
					// if body not in { (and not a do ... while();) wrap next instruction in braces
					else if ($this->tokens[$i + $f] !== '{' && $this->tokens[$i + $f] !== ';') {
						$c = 1;
						while ($this->tokens[$i + $f + $c] !== ';' && $c < $max) {
							$c++;
						}
						$this->wrap_braces($i + $f, $c + 1, $i + $f + $c + 1);
					}
				}
				// rebuild else without { }
				else if ($this->tokens[$i][0] === T_ELSE && $this->tokens[$i + 1][0] !== T_IF && $this->tokens[$i + 1] !== '{') {
					$f = 2;
					while ($f < $max && $this->tokens[$i + $f] !== ';') {
						$f++;
					}
					$this->wrap_braces($i + 1, $f, $i + $f + 1);
				}
				// rebuild switch (): endswitch;
				else if ($this->tokens[$i][0] === T_SWITCH && $this->tokens[$i + 1] === '(') {
					$newbraceopen = 1;
					$c = 2;
					while ($i + $c < $max && $newbraceopen !== 0) {
						// watch function calls in function call
						if ($this->tokens[$i + $c] === '(') {
							$newbraceopen++;
						} else if ($this->tokens[$i + $c] === ')') {
							$newbraceopen--;
						} else if (!isset($this->tokens[$i + $c]) || $this->tokens[$i + $c] === ';') {
							/* addError('Could not find closing parenthesis of switch-statement.',
							  array_slice($this->tokens, $i, 10), $this->tokens[$i][2], $this->filename); */
							break;
						}
						$c++;
					}
					// switch(): ... endswitch;
					if ($this->tokens[$i + $c] === ':') {
						$f = 1;
						while ($this->tokens[$i + $c + $f][0] !== T_ENDSWITCH) {
							$f++;
							if (!isset($this->tokens[$i + $c + $f])) {
								/* addError('Could not find endswitch; of alternate switch-statement.',
								  array_slice($this->tokens, $i, $c + 1), $this->tokens[$i][2], $this->filename); */
								break;
							}
						}
						$this->wrap_braces($i + $c + 1, $f + 1, $i + $c + $f + 2);
					}
				}
				// rebuild switch case: without { }
				else if ($this->tokens[$i][0] === T_CASE) {
					$e = 1;
					while ($i + $e < $max && $this->tokens[$i + $e] !== ':' && $this->tokens[$i + $e] !== ';') {
						$e++;

						if (!isset($this->tokens[$i + $e])) {
							/* addError('Could not find : or ; after ' . $this->tokens[$i][1] . '-statement.',
							  array_slice($this->tokens, $i, 5), $this->tokens[$i][2], $this->filename); */
							break;
						}
					}
					$f = $e + 1;
					if (($this->tokens[$i + $e] === ':' || $this->tokens[$i + $e] === ';') && $this->tokens[$i + $f] !== '{' && $this->tokens[$i + $f][0] !== T_CASE && $this->tokens[$i + $f][0] !== T_DEFAULT) {
						$newbraceopen = 0;
						while ($newbraceopen || (isset($this->tokens[$i + $f]) && $this->tokens[$i + $f] !== '}' && !(is_array($this->tokens[$i + $f]) && ($this->tokens[$i + $f][0] === T_BREAK || $this->tokens[$i + $f][0] === T_CASE || $this->tokens[$i + $f][0] === T_DEFAULT || $this->tokens[$i + $f][0] === T_ENDSWITCH) ) )) {
							if ($this->tokens[$i + $f] === '{') {
								$newbraceopen++;
							} else if ($this->tokens[$i + $f] === '}') {
								$newbraceopen--;
							}
							$f++;

							if (!isset($this->tokens[$i + $f])) {
								/* addError('Could not find ending of ' . $this->tokens[$i][1] . '-statement.',
								  array_slice($this->tokens, $i, $e + 5), $this->tokens[$i][2], $this->filename); */
								break;
							}
						}
						if ($this->tokens[$i + $f][0] === T_BREAK) {
							if ($this->tokens[$i + $f + 1] === ';') {
								$this->wrap_braces($i + $e + 1, $f - $e + 1, $i + $f + 2);
							}
							// break 3;
							else {
								$this->wrap_braces($i + $e + 1, $f - $e + 2, $i + $f + 3);
							}
						} else {
							$this->wrap_braces($i + $e + 1, $f - $e - 1, $i + $f);
						}
						$i++;
					}
				}
				// rebuild switch default: without { }
				else if ($this->tokens[$i][0] === T_DEFAULT && $this->tokens[$i + 2] !== '{') {
					$f = 2;
					$newbraceopen = 0;
					while ($i + $f < $max && ($this->tokens[$i + $f] !== ';' && $this->tokens[$i + $f] !== '}' || $newbraceopen)) {
						if ($this->tokens[$i + $f] === '{') {
							$newbraceopen++;
						} else if ($this->tokens[$i + $f] === '}') {
							$newbraceopen--;
						}
						$f++;

						if (!isset($this->tokens[$i + $f])) {
							/* addError('Could not find ending of ' . $this->tokens[$i][1] . '-statement.',
							  array_slice($this->tokens, $i, 5), $this->tokens[$i][2], $this->filename); */
							break;
						}
					}
					$this->wrap_braces($i + 2, $f - 1, $i + $f + 1);
				}
				// lowercase all function names because PHP doesn't care
				else if ($this->tokens[$i][0] === T_FUNCTION) {
					if (isset($this->tokens[$i + 1][1])) {
						$this->tokens[$i + 1][1] = strtolower($this->tokens[$i + 1][1]);
					}
				} else if ($this->tokens[$i][0] === T_STRING && isset($this->tokens[$i + 1]) && $this->tokens[$i + 1] === '(') {
					if (isset($this->tokens[$i][1])) {
						$this->tokens[$i][1] = strtolower($this->tokens[$i][1]);
					}
				}
				// switch a do while with a while (the difference in loop rounds doesnt matter
				// and we need the condition to be parsed before the loop tokens)
				else if ($this->tokens[$i][0] === T_DO) {
					$f = 2;
					$otherDOs = 0;
					// f = T_WHILE token position relative to i
					while ($i + $f < $max && ($this->tokens[$i + $f][0] !== T_WHILE || $otherDOs)) {
						if ($this->tokens[$i + $f][0] === T_DO) {
							$otherDOs++;
						} else if ($this->tokens[$i + $f][0] === T_WHILE) {
							$otherDOs--;
						}
						$f++;

						if (!isset($this->tokens[$i + $f])) {
							/* addError('Could not find WHILE of DO-WHILE-statement.', array_slice($this->tokens, $i, 5),
							  $this->tokens[$i][2],
							  $this->filename); */
							break;
						}
					}

					// rebuild do while without {} (should never happen but we want to be sure)
					if ($this->tokens[$i + 1] !== '{') {
						$this->wrap_braces($i + 1, $f - 1, $i + $f);
						// by adding braces we added two new tokens
						$f += 2;
					}

					$d = 1;
					// d = END of T_WHILE condition relative to i
					while ($d < $max && isset($this->tokens[$i + $f + $d]) && $this->tokens[$i + $f + $d] !== ';') {
						$d++;
					}

					// reorder tokens and replace DO WHILE with WHILE
					$this->tokens = array_merge(
							array_slice($this->tokens, 0, $i), // before DO
				   array_slice($this->tokens, $i + $f, $d), // WHILE condition
				   array_slice($this->tokens, $i + 1, $f - 1), // DO WHILE loop tokens
				   array_slice($this->tokens, $i + $f + $d + 1, count($this->tokens)) // rest of tokens without while condition
					);
				}
			}
		}
		// return tokens with rearranged key index
		$this->tokens = array_values($this->tokens);
	}

	// rewrites $arrays[] to	$variables and save keys in $tokens[$i][3]
	function array_reconstruct_tokens()
	{
		for ($i = 0, $max = count($this->tokens); $i < $max; $i++) {
			// check for arrays
			if (is_array($this->tokens[$i]) && $this->tokens[$i][0] === T_VARIABLE && $this->tokens[$i + 1] === '[') {
				$this->tokens[$i][3] = array();
				$has_more_keys = true;
				$index = -1;
				$c = 2;

				// loop until no more index found: array[1][2][3]
				while ($has_more_keys && $index < MAX_ARRAY_KEYS) {
					$index++;
					// save constant index as constant
					if (($this->tokens[$i + $c][0] === T_CONSTANT_ENCAPSED_STRING || $this->tokens[$i + $c][0] === T_LNUMBER || $this->tokens[$i + $c][0] === T_NUM_STRING || $this->tokens[$i + $c][0] === T_STRING) && $this->tokens[$i + $c + 1] === ']') {
						unset($this->tokens[$i + $c - 1]);
						$this->tokens[$i][3][$index] = str_replace(array('"', "'"), '', $this->tokens[$i + $c][1]);
						unset($this->tokens[$i + $c]);
						unset($this->tokens[$i + $c + 1]);
						$c += 2;
						// save tokens of non-constant index as token-array for backtrace later
					} else {
						$this->tokens[$i][3][$index] = array();
						$newbraceopen = 1;
						unset($this->tokens[$i + $c - 1]);
						while ($newbraceopen !== 0) {
							if ($this->tokens[$i + $c] === '[') {
								$newbraceopen++;
							} else if ($this->tokens[$i + $c] === ']') {
								$newbraceopen--;
							} else {
								$this->tokens[$i][3][$index][] = $this->tokens[$i + $c];
							}
							unset($this->tokens[$i + $c]);
							$c++;

							if (!isset($this->tokens[$i + $c])) {
								/* addError('Could not find closing bracket of ' . $this->tokens[$i][1] . '[].',
								  array_slice($this->tokens, $i, 5), $this->tokens[$i][2], $this->filename); */
								break;
							}
						}
						unset($this->tokens[$i + $c - 1]);
					}
					if ($this->tokens[$i + $c] !== '[') {
						$has_more_keys = false;
					}
					$c++;
				}

				$i += $c - 1;
			}
		}

		// return tokens with rearranged key index
		$this->tokens = array_values($this->tokens);
	}

	// handles ternary operator (remove condition, only values should be handled during trace)
	// problem: tainting in the condition is not actual tainting the line -> remove condition
	function fix_ternary()
	{
		for ($i = 0, $max = count($this->tokens); $i < $max; $i++) {
			if ($this->tokens[$i] === '?') {
				unset($this->tokens[$i]);
				// condition in brackets: fine, delete condition
				if ($this->tokens[$i - 1] === ')') {
					unset($this->tokens[$i - 1]);
					// delete tokens till (
					$newbraceopen = 1;
					$f = 2;
					while ($newbraceopen !== 0 && $this->tokens[$i - $f] !== ';') {
						if ($this->tokens[$i - $f] === '(') {
							$newbraceopen--;
						} else if ($this->tokens[$i - $f] === ')') {
							$newbraceopen++;
						}
						unset($this->tokens[$i - $f]);
						$f++;

						if (($i - $f) < 0) {
							/* addError('Could not find opening parenthesis in ternary operator (1).',
							  array_slice($this->tokens, $i - 5, 10), $this->tokens[$i + 1][2], $this->filename); */
							break;
						}
					}

					//delete token before, if T_STRING
					if ($this->tokens[$i - $f] === '!' || (is_array($this->tokens[$i - $f]) && ($this->tokens[$i - $f][0] === T_STRING || $this->tokens[$i - $f][0] === T_EMPTY || $this->tokens[$i - $f][0] === T_ISSET))) {
						unset($this->tokens[$i - $f]);
					}
				}
				// condition is a check or assignment
				else if (in_array($this->tokens[$i - 2][0], CwisSecTokens::$T_ASSIGNMENT) || in_array($this->tokens[$i - 2][0],
																						  CwisSecTokens::$T_OPERATOR)) {
					// remove both operands
					unset($this->tokens[$i - 1]);
					unset($this->tokens[$i - 2]);
					// if operand is in braces
					if ($this->tokens[$i - 3] === ')') {
						// delete tokens till (
						$newbraceopen = 1;
						$f = 4;
						while ($newbraceopen !== 0) {
							if ($this->tokens[$i - $f] === '(') {
								$newbraceopen--;
							} else if ($this->tokens[$i - $f] === ')') {
								$newbraceopen++;
							}
							unset($this->tokens[$i - $f]);
							$f++;

							if (($i - $f) < 0 || $this->tokens[$i - $f] === ';') {
								/* addError('Could not find opening parenthesis in ternary operator (2).',
								  array_slice($this->tokens, $i - 8, 6), $this->tokens[$i + 1][2],
								  $this->filename); */
								break;
							}
						}

						//delete token before, if T_STRING
						if (is_array($this->tokens[$i - $f]) && ($this->tokens[$i - $f][0] === T_STRING || $this->tokens[$i - $f][0] === T_EMPTY || $this->tokens[$i - $f][0] === T_ISSET)) {
							unset($this->tokens[$i - $f]);
						}
					}

					unset($this->tokens[$i - 3]);
				}
				// condition is a single variable, delete
				else if (is_array($this->tokens[$i - 1]) && $this->tokens[$i - 1][0] === T_VARIABLE) {
					unset($this->tokens[$i - 1]);
				}
			}
		}
		// return tokens with rearranged key index
		$this->tokens = array_values($this->tokens);
	}

}

class CwisSecTokens
{

	// tokens to ignore while scanning
	static $T_IGNORE = array(
		//T_BAD_CHARACTER,
		T_DOC_COMMENT,
		T_COMMENT,
		//T_ML_COMMENT,
		T_INLINE_HTML,
		T_WHITESPACE,
		T_OPEN_TAG,
			//T_CLOSE_TAG
	);
	// code blocks that should be ignored as requirement
	static $T_LOOP_CONTROL = array(
		//T_DO, // removed, because DO..WHILE is rewritten to WHILE
		T_WHILE,
		T_FOR,
		T_FOREACH
	);
	// control structures
	static $T_FLOW_CONTROL = array(
		T_IF,
		T_SWITCH,
		T_CASE,
		T_ELSE,
		T_ELSEIF
	);
	// variable assignment tokens
	static $T_ASSIGNMENT = array(
		T_AND_EQUAL,
		T_CONCAT_EQUAL,
		T_DIV_EQUAL,
		T_MINUS_EQUAL,
		T_MOD_EQUAL,
		T_MUL_EQUAL,
		T_OR_EQUAL,
		T_PLUS_EQUAL,
		T_SL_EQUAL,
		T_SR_EQUAL,
		T_XOR_EQUAL
	);
	// variable assignment tokens that prevent tainting
	static $T_ASSIGNMENT_SECURE = array(
		T_DIV_EQUAL,
		T_MINUS_EQUAL,
		T_MOD_EQUAL,
		T_MUL_EQUAL,
		T_OR_EQUAL,
		T_PLUS_EQUAL,
		T_SL_EQUAL,
		T_SR_EQUAL,
		T_XOR_EQUAL
	);
	// condition operators
	static $T_OPERATOR = array(
		T_IS_EQUAL,
		T_IS_GREATER_OR_EQUAL,
		T_IS_IDENTICAL,
		T_IS_NOT_EQUAL,
		T_IS_NOT_IDENTICAL,
		T_IS_SMALLER_OR_EQUAL
	);
	// all function call tokens
	static $T_FUNCTIONS = array(
		T_STRING, // all functions
		T_EVAL,
		T_INCLUDE,
		T_INCLUDE_ONCE,
		T_REQUIRE,
		T_REQUIRE_ONCE
	);
	// including operation tokens
	static $T_INCLUDES = array(
		T_INCLUDE,
		T_INCLUDE_ONCE,
		T_REQUIRE,
		T_REQUIRE_ONCE
	);
	// XSS affected operation tokens
	static $T_XSS = array(
		T_PRINT,
		T_ECHO,
		T_OPEN_TAG_WITH_ECHO,
		T_EXIT
	);
	// securing operation tokens
	static $T_CASTS = array(
		T_BOOL_CAST,
		T_DOUBLE_CAST,
		T_INT_CAST,
		T_UNSET_CAST,
		T_UNSET
	);
	// tokens that will have a space before and after in the output, besides $T_OPERATOR and $T_ASSIGNMENT
	static $T_SPACE_WRAP = array(
		T_AS,
		T_BOOLEAN_AND,
		T_BOOLEAN_OR,
		T_LOGICAL_AND,
		T_LOGICAL_OR,
		T_LOGICAL_XOR,
		T_SL,
		T_SR,
		T_CASE,
		T_ELSE,
		T_GLOBAL,
		T_NEW
	);
	// arithmetical operators to detect automatic typecasts
	static $T_ARITHMETIC = array(
		T_INC,
		T_DEC
	);
	// arithmetical operators to detect automatic typecasts
	static $S_ARITHMETIC = array(
		'+',
		'-',
		'*',
		'/',
		'%'
	);
	// strings that will have a space before and after in the output besides $S_ARITHMETIC
	static $S_SPACE_WRAP = array(
		'.',
		'=',
		'>',
		'<',
		':',
		'?'
	);

}

// define own token for include ending
define('T_INCLUDE_END', 380);

// --- CONSTRUCTORS ---
// 
// variable declarations = childs
class CwisSecVarDeclare
{

	var $id;
	var $tokens;
	var $tokenscanstart;
	var $tokenscanstop;
	var $value;
	var $comment;
	var $line;
	var $marker;
	var $dependencies;
	var $stopvar;
	var $array_keys;
	var $parsedtokens;

	function __construct($tokens = array(), $comment = '')
	{
		$this->id = 0;
		$this->tokens = $tokens;
		$this->tokenscanstart = 0;
		$this->tokenscanstop = count($tokens);
		$this->value = '';
		$this->comment = $comment;
		$this->line = '';
		$this->marker = 0;
		$this->dependencies = array();
		$this->stopvar = false;
		$this->array_keys = array();
	}

}

// group vulnerable parts to one vulnerability trace
class CwisSecVulnBlock
{

	var $uid;
	var $vuln;
	var $category;
	var $treenodes;
	var $sink;
	var $dataleakvar;
	var $alternates;

	function __construct($uid = '', $category = 'match', $sink = '')
	{
		$this->uid = $uid;
		$this->vuln = false;
		$this->category = $category;
		$this->treenodes = array();
		$this->sink = $sink;
		$this->dataleakvar = array();
		$this->alternates = array();
	}

}

// used to store new finds
class CwisSecVulnTreeNode
{

	var $id;
	var $value;
	var $dependencies;
	var $title;
	var $name;
	var $marker;
	var $lines;
	var $filename;
	var $children;
	var $funcdepend;
	var $funcparamdepend;
	var $foundcallee;
	var $get;
	var $post;
	var $cookie;
	var $files;
	var $server;

	function __construct($value = null)
	{
		$this->id = 0;
		$this->value = $value;
		$this->title = '';
		$this->dependencies = array();
		$this->name = '';
		$this->marker = 0;
		$this->lines = array();
		$this->filename = '';
		$this->children = array();
		$this->funcdepend = '';
		$this->funcparamdepend = null;
		$this->foundcallee = false;
	}

}

// information gathering finds
class CwisSecInfoTreeNode
{

	var $value;
	var $dependencies;
	var $name;
	var $lines;
	var $title;
	var $filename;

	function __construct($value = null)
	{
		$this->title = 'File Inclusion';
		$this->value = $value;
		$this->dependencies = array();
		$this->name = '';
		$this->lines = array();
		$this->filename = '';
	}

}

// function declaration
class CwisSecFunctionDeclare
{

	var $value;
	var $tokens;
	var $name;
	var $line;
	var $marker;
	var $parameters;

	function __construct($tokens)
	{
		$this->value = '';
		$this->tokens = $tokens;
		$this->name = '';
		$this->line = 0;
		$this->marker = 0;
		$this->parameters = array();
	}

}
