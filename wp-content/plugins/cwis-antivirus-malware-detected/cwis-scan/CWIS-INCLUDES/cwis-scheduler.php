<?php

// ezscan7objrldgpfvmqkdthyuwi4x2x5
if (!defined('CWIS_SIGNATURE')) {
	header('HTTP/1.0 403 Forbidden');
	die('-1');
}

class CwisScheduler
{

	// Possible states of task record and status
	var $task_states = array(
		'disabled', 'inactive', 'active', // task record is...
		'dropped', 'paused', 'completed' // status is...
	);
	//
	// Tasks extension
	var $task_ext = '.ini.php';

	// --- DIRECTORIES ---

	/**
	 * Converts an array of subdirectories to array of scan paths. 
	 * @param array $subdirectories
	 * @return array
	 */
	function convertSubdirectoriesToScanPaths($subdirectories = array())
	{
		$scan_paths = array();
		foreach ($subdirectories as $group => $directories) {
			foreach ($directories as $directory) {
				$scan_paths[] = trim($group) . $directory;
			}
		}

		return $scan_paths;
	}

	/**
	 * Parses schedule task's INI file and returns scan directory option value.
	 * Returns default path(s) to user accounts if INI file or option is empty.
	 * @param array $default
	 * @return array
	 */
	function getScanDirectories($default = array('/home/', '/srv/', '/var/www/'))
	{
		$scan_directories = array();

		// Parse schedule task's INI file
		$parsed = (object) $this->parsedTaskNameToJsObject('schedule');
		if (!$parsed->errmsg && isset($parsed->config['scan_directory'])) {
			$scan_directories_trimmed = array_map('trim', explode(',', $parsed->config['scan_directory']));
			$scan_directories = array_filter($scan_directories_trimmed, 'strlen');
		}

		// Default path(s) to user accounts
		if (empty($scan_directories) && is_array($default)) {
			$scan_directories = $default;
		}

		// Add a trailing slash if needed
		foreach ($scan_directories as $i => $directory) {
			if (is_empty($directory)) {
				unset($scan_directories[$i]);
			} elseif (substr($directory, -1) !== '/' && substr($directory, -1) !== '\\') {
				$scan_directories[$i] .= DIRECTORY_SEPARATOR;
			}
		}

		return $scan_directories;
	}

	/**
	 * Resturs all subdirectories of the directories.
	 * @param array $directories
	 * @param array $exclude
	 * @return array
	 */
	function getSubdirectories($directories = array(), $exclude = array('.', '..'))
	{
		$subdirectories = array();
		if (!is_array($directories)) {
			$directories = array($directories);
		}

		// Get all subdirectories of a given directory
		foreach ($directories as $directory) {
			if (!$directory || !is_string($directory)) {
				continue;
			}

			// Check for duplicate paths
			foreach ($subdirectories as $parent => $children) {
				if (false === strpos($directory, $parent)) {
					continue;
				}

				// Filter duplicate child subdirectories
				foreach ($children as $index => $child) {
					if ($directory === $parent . $child . DIRECTORY_SEPARATOR) {
						unset($subdirectories[$parent][$index]);
						break;
					}
				}
			}

			// Directory length and results placeholder
			$dir_len = strlen($directory . DIRECTORY_SEPARATOR);
			$subdirectories[$directory] = array();

			// Scan a directory
			$filenames = scan_dir($directory, $exclude);
			foreach ($filenames as $filename) {
				if (is_dir($filename)) {
					$subdirectories[$directory][] = substr($filename, $dir_len);
				}
			}

			// Equivalent to SCANDIR_SORT_ASCENDING
			sort($subdirectories[$directory]);
		}

		return $subdirectories;
	}

	/**
	 * Returns directory's contents.
	 * @param string $directory
	 * @param array $exclude
	 * @return array
	 */
	function getDirectoryContents($directory = '', $exclude = array('.', '..'))
	{
		$directorylist = array();

		// Scan the given directory
		if (is_string($directory)) {

			// Directory length and results placeholder
			$dir_len = strlen($directory . DIRECTORY_SEPARATOR);
			$directorylist['directories'] = array();
			$directorylist['files'] = array();

			// Scan a directory
			$filenames = scan_dir($directory, $exclude);
			foreach ($filenames as $filename) {
				if (is_dir($filename)) {
					$directorylist['directories'][] = substr($filename, $dir_len);
				} elseif (is_file($filename)) {
					// Files in root directory
					$directorylist['files'][] = substr($filename, $dir_len);
				}
			}

			// Equivalent to SCANDIR_SORT_ASCENDING
			sort($directorylist['directories']);
			sort($directorylist['files']);
		}

		return $directorylist;
	}

	// --- TASK STATES ---

	/**
	 * Returns task ID (task name before dot, without state).
	 * @param string $task_name
	 * @return bool|string
	 */
	function getTaskId($task_name = '')
	{
		$dot_pos = strrpos($task_name, '.');
		if (false === $dot_pos) {
			return $task_name;
		}

		return substr($task_name, 0, $dot_pos);
	}

	/**
	 * Returns task state by task name.
	 * @param string $task_name
	 * @return bool|string
	 */
	function getTaskState($task_name = '')
	{
		$dot_pos = strrpos($task_name, '.');
		if (false === $dot_pos) {
			return false;
		}

		return substr($task_name, $dot_pos + 1);
	}

	/**
	 * Sets task state to a new state (for example "completed").
	 * @param string $task_name
	 * @param string $new_state
	 * @return bool
	 */
	function setTaskState($task_name = '', $new_state = 'completed')
	{
		// Check if a new state is valid
		if (!in_array($new_state, $this->task_states)) {
			return false;
		}

		// Get the task ID and append a new state
		return $this->getTaskId($task_name) . '.' . $new_state;
	}

	/**
	 * Changes task filename according to a new task state.
	 * @param string $task_name
	 * @param string $new_state
	 * @return bool
	 */
	function changeTaskNameState($task_name = '', $new_state = 'completed')
	{
		// Schedule task don't have status
		if ($task_name === 'schedule') {
			return false;
		}

		$task_id = $this->getTaskId($task_name);
		$new_task_name = $this->setTaskState($task_id, $new_state);
		if (false === $new_task_name) {
			return false;
		}

		// Get current task name by its task ID
		$current_task_name = $this->convertTaskIdToTaskName($task_id);
		if (false === $current_task_name) {
			return false;
		}

		// Convert task names to INI-filenames
		$current_ini_file = $this->convertTaskNameToIniFile($current_task_name);
		$new_ini_file = $this->convertTaskNameToIniFile($new_task_name);

		return $current_ini_file !== $new_ini_file ?
				@rename($current_ini_file, $new_ini_file) : 1;
	}

	/**
	 * Changes task filename according to a new task state.
	 * @param string $task_name
	 * @param string $new_state
	 * @return bool
	 */
	function removeTaskName($task_name = '')
	{
		$task_id = $this->getTaskId($task_name);

		// Get current task name by its task ID
		$current_task_name = $this->convertTaskIdToTaskName($task_id);
		if (false === $current_task_name) {
			return false;
		}

		// Convert task name to INI-filename
		$ini_file = $this->convertTaskNameToIniFile($current_task_name);

		return @unlink($ini_file);
	}

	// --- CONVERTORS ---

	/**
	 * Converts INI filename to the task name.
	 * @param array $ini_file
	 * @return array
	 */
	function convertIniFileToTaskName($ini_file = '')
	{
		// Length of path to task directory
		$task_path_len = strlen(CWIS_TASKS_PATH . DIRECTORY_SEPARATOR);

		// Length of task extension (".ini.php" by default)
		$task_ext_len = strlen($this->task_ext);

		// Convert "/absolute/path/task-name.state.ini.php" to "task-name.state"
		return substr($ini_file, $task_path_len, -$task_ext_len);
	}

	/**
	 * Converts INI filenames to task names, optionally filters by task state(s).
	 * @param array $ini_files
	 * @return array
	 */
	function convertIniFilesToTaskNames($ini_files = array(), $task_filter = array())
	{
		$task_names = array();

		// Length of path to task directory
		$task_path_len = strlen(CWIS_TASKS_PATH . DIRECTORY_SEPARATOR);

		// Length of task extension (".ini.php" by default)
		$task_ext_len = strlen($this->task_ext);

		// Is task filtering enabled?
		$filtering_is_enabled = !empty($task_filter) && is_array($task_filter);

		// Process INI files
		foreach ($ini_files as $ini_file) {
			if ($this->task_ext !== substr($ini_file, -$task_ext_len)) {
				continue; // filter task extensions
			}

			// Convert "/absolute/path/task-name.state.ini.php" to "task-name.state"
			$task_name = substr($ini_file, $task_path_len, -$task_ext_len);

			// Find the position of the task state in a filename
			$task_state_pos = strrpos($task_name, '.');
			$task_state = substr($task_name, $task_state_pos + 1);

			// Filter files by task state, accept task "schedule"
			if ($filtering_is_enabled && !in_array($task_state, $task_filter)) {
				continue;
			}

			// Task names
			$task_names[] = $task_name;
		}

		return $task_names;
	}

	/**
	 * Converts task ID to the INI filename.
	 * @param string $task_id
	 * @return string
	 */
	function convertTaskIdToTaskName($task_id = '', $task_state = '')
	{
		// Convert "task-id.state" to "/absolute/path/task-name.ini.php"
		if (in_array($task_state, $this->task_states)) {
			return $task_id . '.' . $task_state;
		}

		foreach ($this->task_states as $task_state) {
			$task_name = $task_id . '.' . $task_state;
			if (is_file($this->convertTaskNameToIniFile($task_name))) {
				return $task_name;
			}
		}

		return false;
	}

	/**
	 * Converts task name to the INI filename.
	 * @param string $task_name
	 * @return string
	 */
	function convertTaskNameToIniFile($task_name = '')
	{
		// Convert "task-name.state" to "/absolute/path/task-name.state.ini.php"
		return CWIS_TASKS_PATH . DIRECTORY_SEPARATOR . $task_name . $this->task_ext;
	}

	/**
	 * Converts task names to INI filenames.
	 * @param array $task_names
	 * @return array
	 */
	function convertTaskNamesToIniFiles($task_names = array())
	{
		$ini_files = array();

		// Process task names
		foreach ($task_names as $task_name) {
			// Convert "task-name.state" to "/absolute/path/task-name.state.ini.php"
			$ini_files[] = $this->convertTaskNameToIniFile($task_name);
		}

		return $ini_files;
	}

	// --- PHP INI PARSER ---

	/**
	 * Returns unfiltered list of INI-files.
	 * @param array $task_filter
	 * @return array
	 */
	function getIniFilesList()
	{
		return scan_dir(CWIS_TASKS_PATH, array('.', '..', 'index.html'));
	}

	/**
	 * Parses configuration INI-file (returns FALSE on fail).
	 * @param string $ini_file
	 * @param bool $process_sections
	 * @return array|bool
	 */
	function parseIniFile($ini_file = '', $process_sections = false)
	{
		if (!$ini_file || !is_file($ini_file)) {
			return false;
		}

		// Parse INI-file (without sections)
		$ini_array = read_php_ini_file($ini_file, $process_sections);
		if (!is_array($ini_array)) {
			return false;
		}

		return $ini_array;
	}

	/**
	 * Parses task configuration by task name.
	 * @param string $task_name
	 * @param bool $process_sections
	 * @return array|bool
	 */
	function parseTaskName($task_name = '', $process_sections = false)
	{
		$ini_file = $this->convertTaskNameToIniFile($task_name);
		return $this->parseIniFile($ini_file, $process_sections);
	}

	// --- BULK INI PARSERS ---

	/**
	 * Converts a parsed task data to JS-ready object.
	 * @param string $task_name
	 * @param bool $process_sections
	 * @return array
	 */
	function parsedTaskNameToJsObject($task_name = '', $process_sections = false)
	{
		$config = $this->parseTaskName($task_name, $process_sections);
		if (!$config) {
			$errmsg = 'Cannot parse the task "' . $task_name . '"';
		} else {
			$errmsg = '';

			// Check a scan path, use global constants if empty
			if (!isset($config['scan_path'])) {
				$config['scan_path'] = '';
			}

			// Check a scan frequency, set to empty if undefined
			if (!isset($config['scan_frequency'])) {
				$config['scan_frequency'] = '';
			}
		}

		// Define scan start timestamp
		if (isset($config['scan_start']) && $config['scan_start']) {
			$scan_start = strtotime($config['scan_start']);
		} else {
			// Use filemtime or today midnight time if not defined
			$ini_file = $this->convertTaskNameToIniFile($task_name);
			$scan_start = is_file($ini_file) ?
					@filemtime($ini_file) : time() - time() % 86400;
		}

		// Scan end timestamp
		$scan_end = isset($config['scan_end']) && $config['scan_end'] ?
				strtotime($config['scan_end']) : null;

		// Last scan timestamp
		$scan_last = isset($config['scan_last']) && $config['scan_last'] ?
				strtotime($config['scan_last']) : null;

		// Scan repeat timestamp
		$scan_repeat = $scan_last && $config['scan_frequency'] ?
				$this->getScheduledTaskScanStartTime($scan_last, $config['scan_frequency']) : null;

		return array(
			'config'		 => $config,
			'errmsg'		 => $errmsg,
			'scan_start'	 => $scan_start,
			'scan_end'		 => $scan_end,
			'scan_last'		 => $scan_last,
			'scan_repeat'	 => $scan_repeat,
			'state'			 => $this->getTaskState($task_name)
		);
	}

	/**
	 * Parses tasks configuration by INI-files.
	 * @param array $ini_files
	 * @param bool $process_sections
	 * @return array
	 */
	function parseIniFiles($ini_files = array(), $process_sections = false)
	{
		$parsed = array();

		// Parse INI-files (without sections)
		foreach ($ini_files as $ini_file) {
			if (!$ini_file) {
				continue;
			}

			$task_name = $this->convertIniFileToTaskName($ini_file);
			$parsed[$task_name] = $this->parsedTaskNameToJsObject($task_name, $process_sections);
		}

		return $parsed;
	}

	/**
	 * Parses tasks configuration by task names.
	 * @param array $task_names
	 * @param bool $process_sections
	 * @return array
	 */
	function parseTaskNames($task_names = array(), $process_sections = false)
	{
		$parsed = array();

		// Parse INI-files (without sections)
		foreach ($task_names as $task_name) {
			if (!$task_name) {
				continue;
			}

			$task_id = $this->getTaskId($task_name);
			$parsed_task = $this->parsedTaskNameToJsObject($task_name, $process_sections);
			if ($parsed_task['config']) { // validate
				$parsed[$task_id] = $parsed_task;
			}
		}

		return $parsed;
	}

	// --- PHP INI WRITER ---

	/**
	 * Creates configuration file content with the same structure as the php.ini's.
	 * @param array $ini_array
	 * @param bool $has_sections
	 * @return string
	 */
	function createPhpIniContent($ini_array = array(), $has_sections = false)
	{
		$content = '';

		foreach ($ini_array as $array_key => $array_val) {
			if (is_array($array_val)) {
				if ($has_sections) {
					$content .= '[' . $array_key . ']'
							. "\n"
							. $this->createPhpIniContent($array_val, false)
							. "\n";
				} else {
					foreach ($array_val as $section_key => $section_val) {
						$content .= $array_key . "[" . (!is_int($section_key) ? $section_key : '') . "] = "
								. (is_numeric($section_val) ? $section_val : '"' . $section_val . '"')
								. "\n";
					}
				}
			} else {
				$content .= $array_key . " = "
						. (is_numeric($array_val) ? $array_val : '"' . $array_val . '"')
						. "\n";
			}
		}

		return $content;
	}

	/**
	 * Writes a configuration file with the same structure as the php.ini's.
	 * @param array $ini_array
	 * @param string $filename
	 * @param bool $has_sections
	 * @return bool|int
	 */
	function writeIniFile($ini_array = array(), $filename = '', $has_sections = false)
	{
		// Secure INI-file with opening comment
		// http://php.net/manual/en/function.parse-ini-file.php#99474
		$ini_content = ';<?php die() /*' . "\n"
				. "\n"
				. $this->createPhpIniContent($ini_array, $has_sections)
				. "\n"
				. ';*/';

		return file_put_contents_safe($filename, $ini_content);
	}

	// --- TASK TIMES CHECKERS ---

	function convertScheduledTaskFrequency($timestamp = 0, $frequency = '')
	{
		if ($timestamp && $frequency) {
			switch ($frequency) {
				case 'twice-a-day':
					$time = '+12 hours';
					break;

				case 'daily':
					$time = '+1 day';
					break;

				case 'weekly':
					$time = '+1 week';
					break;

				case 'bi-weekly':
					$time = '+2 weeks';
					break;

				case 'monthly':
					$time = '+1 month';
					break;

				default:
					// Treat as hours, minimal is 6
					$time = '+' . round($frequency > 6 ? $frequency : 6) . ' hours';
			}

			return strtotime($time, $timestamp);
		}

		return $timestamp;
	}

	/**
	 * Checks if scheduled task time has come.
	 * @param int|string $scan_start
	 * @param string $frequency
	 * @return bool
	 */
	function checkScheduledTaskTimeHasCome($scan_start = '', $frequency = '')
	{
		// Convert scan start (accept epoch) with task frequency into a Unix timestamp
		$timestamp_start = $this->getScheduledTaskScanStartTime($scan_start, $frequency);
		return (bool) (time() >= $timestamp_start);
	}

	/**
	 * Checks if scheduled task time is over.
	 * @param int|string $scan_end
	 * @return bool
	 */
	function checkScheduledTaskTimeIsOver($scan_end = '')
	{
		// Scan end timestamp, accept epoch
		$timestamp_end = $scan_end ?
				(is_integer($scan_end) ? $scan_end : strtotime($scan_end)) : 2147483647;

		return (bool) (time() >= $timestamp_end);
	}

	/**
	 * Checks if scheduled task time has come.
	 * @param int|string $scan_start
	 * @param string $frequency
	 * @return bool
	 */
	function getScheduledTaskScanStartTime($scan_start = '', $frequency = '')
	{
		// Scan start timestamp, accept epoch
		$timestamp_start = $scan_start ?
				(is_integer($scan_start) ? $scan_start : strtotime($scan_start)) : 0;

		if ($frequency) {
			// Convert textual frequency description into a Unix timestamp
			$timestamp_start = $this->convertScheduledTaskFrequency($timestamp_start, $frequency);
		}

		return $timestamp_start;
	}

	// --- HELPER METHODS ---

	/**
	 * Runs a set of cron job schedule's checks.
	 * @param string $task_name
	 * @return stdClass $parsed
	 */
	function runCronJobChecks($task_name = 'schedule')
	{
		// #1. Parse schedule task's INI file
		$parsed = (object) $this->parsedTaskNameToJsObject($task_name);
		if ($parsed->errmsg) {
			return $parsed;
		}

		// #2. Check if "One Time" scan selected or scheduled task time is over
		if (($parsed->scan_last && !$parsed->scan_repeat) || $this->checkScheduledTaskTimeIsOver($parsed->scan_end)) {
			$parsed->errmsg = 'Job execution end time has come.';
			return $parsed;
		}

		// Init utilities methods
		$utilities = new CwisUtilities();

		// #3. Check if scheduled task time has come
		$time_prior_start = $this->getScheduledTaskScanStartTime($parsed->scan_start) - time();
		if ($time_prior_start > 0) {
			$parsed->errmsg = 'Job start time will come in ' . $utilities->formatSeconds($time_prior_start);
			return $parsed;
		}

		// #4. Check a cron job scan frequency
		$time_prior_rescan = $parsed->scan_repeat - time();
		if ($time_prior_rescan >= 0) {
			$parsed->errmsg = 'Job repeat time will come in ' . $utilities->formatSeconds($time_prior_rescan);
			return $parsed;
		}

		return $parsed;
	}

	/**
	 * Stops a cron job task immediately.
	 * @param string $task_name
	 * @return stdClass $parsed
	 */
	function stopCronJobTask($task_name = 'schedule')
	{
		$parsed = (object) $this->parsedTaskNameToJsObject($task_name);
		if ($parsed->errmsg) {
			// Default scan settings
			$parsed->config = array(
				'scan_database'	 => 1,
				'scan_level'	 => 2
			);

			// Force settings saving
			$parsed->scan_repeat = 1;
		}

		// Update INI-file
		if ($parsed->scan_repeat) {
			$parsed->config['scan_frequency'] = '';
			$parsed->config['scan_last'] = date('Y-m-d H:i', time());

			$ini_file = $this->convertTaskNameToIniFile($task_name);
			$this->writeIniFile($parsed->config, $ini_file, true);
		}

		return $parsed;
	}

	/**
	 * Updates the scan repeat time according to frequency, writes data to INI-file.
	 * @param string $task_name
	 * @param bool $scan_now
	 * @return stdClass $parsed
	 */
	function updateCronJobTime($task_name = 'schedule', $scan_now = false)
	{
		$parsed = (object) $this->parsedTaskNameToJsObject($task_name);
		if ($parsed->errmsg) {
			return $parsed;
		}

		// Define the last time the scan has been finished
		$scan_last = $parsed->scan_last ? $parsed->scan_last : $parsed->scan_start;

		// Re-define using scan repeat date
		if ($scan_now || $scan_last < time()) {
			$scan_frequency = $parsed->scan_last ? $parsed->config['scan_frequency'] : 0;

			if ($scan_now) {
				// Force quick rescan
				$parsed->scan_last = null;
				$parsed->scan_repeat = null;
				$parsed->config['scan_last'] = null;
			} else {
				// Set the last scan time (as a next repeat time according to frequency)
				$parsed->scan_last = $this->getScheduledTaskScanStartTime($scan_last, $scan_frequency);
				$parsed->config['scan_last'] = date('Y-m-d H:i', $parsed->scan_last);
			}

			// Update INI-file
			$ini_file = $this->convertTaskNameToIniFile($task_name);
			$this->writeIniFile($parsed->config, $ini_file, true);
		}

		return $parsed;
	}

	function displayErrorMessage($message = '')
	{
		if (!defined('CWIS_IS_CLI') || !CWIS_IS_CLI) {
			echo '<div style="color:ButtonHighlight;font:caption;text-align:center;background:ButtonShadow;border-radius:.3em;padding:.7em">';
			echo '<b>' . $message . '</b>' . PHP_EOL . '<hr /><small>' . round((microtime_float() - CWIS_START_TIME) * 1000) . 'ms</small>';
			echo '</div>';
		} else {
			echo $message . PHP_EOL;
		}
	}

}
