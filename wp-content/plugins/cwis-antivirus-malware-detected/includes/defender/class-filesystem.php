<?php

/**
 * The file that defines the filesystem class.
 *
 * @link       https://cobweb-security.com
 * @since      1.4.0
 *
 * @package    Cwsd
 * @subpackage Cwsd/includes/defender
 * @author     Cobweb Security <cwis@cobweb-security.com>
 */
class Cwis_Defender_Filesystem
{

    // Suffix for temporal filenames.
    private $file_suffix = '.cwsd.tmp';
    //
    // List of REGEX patterns matching the paths where we should not put 
    // directory indexes (because of compatibility issues).
    private $incompatible_paths = array(
        'wp-content\/themes\/(.*)-child$'
    );
    //
    // List of sensitive files.
    private $sensitive_files = array(
        'changelog', 'changelog.txt', 'changes.txt',
        'contributing.md',
        'history.rst', 'history.txt',
        'install.txt',
        'manifest.in',
        'readme', 'readme.1st', 'readme.html', 'readme.md', 'readme.rst', 'readme.txt',
        'license', 'license.html', 'license.md', 'license.txt',
        'update.txt', 'update_notes.txt',
    );
    //
    // Instance of WP_Filesystem.
    private $wp_filesystem = null;

    /**
     * Creates the temporary files directory with subdirectory CWIS-GUARDER.
     * 
     * @since   4.0.5
     * @access  public
     * 
     * @param   string $plugin_dir_path
     * @return  string
     */
    public function create_temp_files_directory($plugin_dir_path = '')
    {
        // Get current upload directoryâ€™s path
        if (function_exists('wp_upload_dir')) {
            $upload_dir = wp_upload_dir();
            $upload_path = $upload_dir['basedir'] . '/cwis';
        } else {
            // Fallback for direct calls
            $upload_path = dirname(dirname($plugin_dir_path)) . '/uploads/cwis';
        }

        // Create temporary files directory
        if (!$this->path_is_dir($upload_path)) {
            if ($this->path_mkdir($upload_path)) {
                $this->put_directory_indexes($upload_path);
            } else {
                trigger_error('Cannot create temporary files directory.');
            }
        }

        // Create temporary files subdirectory
        $temp_dir_path = $upload_path . '/CWIS-GUARDER';
        if (!$this->path_is_dir($temp_dir_path)) {
            if ($this->path_mkdir($temp_dir_path)) {
                $this->put_directory_indexes($temp_dir_path);
                @copy($plugin_dir_path . '/tmp/cwsd-traffic.db', $temp_dir_path . '/cwsd-traffic.db'); // TODO: remove in next versions
            } else {
                trigger_error('Cannot create temporary files subdirectory.');
            }
        }

        return $temp_dir_path;
    }

    /**
     * Installs the plugin loader file to the root directory.
     * 
     * @since   1.0.7
     * @access  public
     * 
     * @return bool
     */
    public function plugin_loader_install()
    {
        // Customize the loader file contents
        $path_to_plugin = dirname(dirname(dirname(__FILE__))) . '/';
        $path_to_router = substr($path_to_plugin, strlen(ABSPATH)) . 'cwsd-router.php';
        $loader_contents = <<<HTML
<?php

/**
 * The plugin loader file
 *
 * @link              https://cobweb-security.com
 * @since             1.0.1
 * @package           Cwsd
 */

/** Absolute path to the WordPress directory. */
if ( !defined('ABSPATH') )
	define('ABSPATH', dirname(__FILE__) . '/');

/** Include the plugin router file. */
@require_once(ABSPATH . '{$path_to_router}');
HTML;

        // Put the loader file in the root directory
        return $this->file_write(ABSPATH . 'cwsd.php', $loader_contents);
    }

    /**
     * Uninstalls the plugin loader file from the root directory.
     * 
     * @since   1.0.7
     * @access  public
     * 
     * @return  bool
     */
    public function plugin_loader_uninstall()
    {
        // Remove the loader file from the root directory
        return $this->file_delete(ABSPATH . 'cwsd.php');
    }

    // --- CACHE FILE ---

    /**
     * Loads cache file contents with optional checksum validation.
     * 
     * @since   4.0.5
     * @access  public
     * 
     * @param   string $filename
     * @return  bool
     */
    public function delete_cache_file_contents($filename = '')
    {
        if (is_readable($filename)) {
            return $this->file_delete($filename);
        }

        return false;
    }

    /**
     * Loads cache file contents with optional checksum validation.
     * 
     * @since   1.4.0
     * @access  public
     * 
     * @param   string $filename
     * @param   bool $checksum_validation
     * @param   int $cache_expiration
     * @return  null|array
     */
    public function load_cache_file_contents($filename = '', $checksum_validation = false, $cache_expiration = 0)
    {
        // Optional, check the cache expiry time
        if ($cache_expiration && is_readable($filename) && time() - filemtime($filename) > $cache_expiration) {
            return null;
        }

        $packed_entries = is_readable($filename) ? array_map('trim', file($filename)) : array();
        $cache_checksum = array_shift($packed_entries);

        // Optional, checksum validation
        if ($checksum_validation && null !== $cache_checksum &&
                $cache_checksum !== sha1(implode(PHP_EOL, $packed_entries))) {
            return null;
        }

        // Pop the EOF char off the end of array
        array_pop($packed_entries);
        return $packed_entries;
    }

    /**
     * Saves content with its SHA1-checksum to the cache file.
     * 
     * @since   1.4.0
     * @access  public
     * 
     * @param   string $filename
     * @param   array $packed_entries
     * @return  mixed
     */
    public function save_cache_file_contents($filename = '', $packed_entries = array())
    {
        if (!is_array($packed_entries)) {
            $packed_entries = (array) $packed_entries;
        }

        $packed_entries[] = chr(26); //used as EOF char
        $file_contents = implode(PHP_EOL, $packed_entries);
        $cache_checksum = sha1($file_contents);

        // Store calculated SHA1-checksum with a following packed entries
        return $this->file_write($filename, $cache_checksum . PHP_EOL . $file_contents);
    }

    /**
     * Protects content directories.
     * 
     * @since   1.5.0
     * @access  public
     * 
     * @return  bool
     */
    public function protect_content_dirs()
    {
        // Get list of files in root
        $root_path = rtrim(ABSPATH, '\/');
        $root_files = $this->scandir_recursively($root_path, false);

        // Get list of files in wp-content recursively
        $content_path = $root_path . DIRECTORY_SEPARATOR . 'wp-content';
        $content_files = $this->scandir_recursively($content_path, false, 3);

        // Merge lists of files
        if (!empty($root_files)) {
            $content_files = array_merge($root_files, $content_files);
        }
        sort($content_files);

        // Index file contents
        $index_contents = <<<HTML
<?php
// Silence is golden
HTML;

        // Protect directories and files
        $sensitive_files = array_flip($this->sensitive_files);
        foreach ($content_files as $file_path) {
            $basename = strtolower(basename($file_path));

            // Put directory indexes
            if ($basename === 'index.php' && !is_file($file_path)) {
                $this->file_write($file_path, $index_contents);
            }
            // Rename sensitive files
            elseif (isset($sensitive_files[$basename]) && is_file($file_path)) {
                $random_prefix = '.' . wp_generate_password(9, false) . '~';
                $protected_file_path = substr_replace($file_path, $random_prefix, -strlen($basename), 0);
                $this->file_move($file_path, $protected_file_path);
            }
        }
    }

    /**
     * Puts directory indexes (prevents directory listing).
     * 
     * @since   1.2.0
     * @access  public
     *
     * @param   array $index_dirs
     * @return  bool
     */
    public function put_directory_indexes($index_dirs = array())
    {
        // Scan directories recursively
        if (empty($index_dirs)) {
            $root_path = rtrim(ABSPATH, '\/');
            $index_dirs = $this->scandir_recursively($root_path, true, 3);
        } elseif (!is_array($index_dirs)) {
            $index_dirs = array($index_dirs);
        }

        // Index file contents
        $index_contents = <<<HTML
<?php
// Silence is golden
HTML;

        // Put directory indexes
        foreach ($index_dirs as $dir) {
            if ($this->is_incompatible_path($dir)) {
                continue;
            }

            $index_file = $dir . DIRECTORY_SEPARATOR . 'index.php';
            if (!is_file($index_file)) {
                $this->file_write($index_file, $index_contents);
            }
        }
    }

    /**
     * Updates file contents with new directives, for example:
     * # BEGIN CWSD
     *   RewriteEngine On
     *   RewriteRule ^index\.php$ - [L]
     * # END CWSD
     * 
     * @since   1.4.0
     * @access  public
     *
     * @param string $path_to_file
     * @param string $directives
     * @param string $opening_tag
     * @param string $closing_tag
     * @param bool $force_update
     * @return null|bool
     */
    public function update_file_directives($path_to_file, $directives = '', $opening_tag = '# BEGIN CWSD', $closing_tag = '# END CWSD', $force_update = false)
    {
        $matches = array();
        $directives_tagged = !empty($directives) ? # surround directives with tags (if non-empty)
                $opening_tag . PHP_EOL . trim($directives, "\n\r\0") . PHP_EOL . $closing_tag : '';

        // Read file and match exists directives (if any)
        $file_contents = is_file($path_to_file) ? file_get_contents($path_to_file) : '';
        $directives_regex = preg_quote($opening_tag, '~') . '(.+?)' . preg_quote($closing_tag, '~') . '\s+';
        if (preg_match('~' . $directives_regex . '~si', $file_contents, $matches)) {
            $directives_matched = reset($matches);
        } else {
            $directives_matched = '';
        }

        // Update file contents only when forced or directives changed
        if ($force_update || $directives_tagged !== trim($directives_matched)) {
            $file_contents_cleaned = $directives_matched ? # remove directives from contents
                    str_replace($directives_matched, '', $file_contents) : $file_contents;

            $file_contents_updated = $directives_tagged ? # insert EOLs between directives and contents
                    $directives_tagged . PHP_EOL . PHP_EOL . $file_contents_cleaned : $file_contents_cleaned;

            $path_to_temporal_file = $path_to_file . $this->file_suffix;
            if ($this->file_write($path_to_temporal_file, $file_contents_updated)) {
                return $this->file_move($path_to_temporal_file, $path_to_file);
            } else {
                $this->file_delete($path_to_temporal_file);
                return false;
            }
        }
    }

    // --- PRIVATE ---

    /**
     * Wrapper method, deletes a local file.
     * 
     * @since   1.5.9
     * @access  private
     * 
     * @param   string $filename
     * @return  bool
     */
    private function file_delete($filename)
    {
        // Initialize the WP API
        if (false !== $this->init_wp_filesystem()) {
            return $this->wp_filesystem->delete($filename);
        }

        // Fallback to built-in function
        return @unlink($filename);
    }

    /**
     * Wrapper method, moves a local file.
     * 
     * @since   1.5.9
     * @access  private
     * 
     * @param   string $oldname
     * @param   string $newname
     * @return  bool
     */
    private function file_move($oldname, $newname)
    {
        return @rename($oldname, $newname);
    }

    /**
     * Wrapper method, writes data to a local file.
     * 
     * @since   1.5.9
     * @access  private
     * 
     * @param   string $filename
     * @param   mixed $data
     * @return  bool|int
     */
    private function file_write($filename, $data)
    {
        // Initialize the WP API
        if (false !== $this->init_wp_filesystem()) {
            return $this->wp_filesystem->put_contents($filename, $data);
        }

        // Fallback to built-in function
        return @file_put_contents($filename, $data, LOCK_EX);
    }

    /**
     * Safely requests filesystem credentials without any issues.
     * 
     * @since   1.0.7
     * @access  private
     * 
     * @global  object $wp_filesystem
     * @return  mixed
     */
    private function init_wp_filesystem()
    {
        // Initialize the filesystem API
        if (null === $this->wp_filesystem) {

            // Check if running under WordPress
            if (!function_exists('wp_mail')) {
                $this->wp_filesystem = false;
                return false;
            } elseif (!class_exists('WP_Filesystem_Base')) {
                include_once ABSPATH . 'wp-admin/includes/file.php';
            }

            // Prevent an issue with function request_filesystem_credentials()
            $creds = function_exists('request_filesystem_credentials') ?
                    request_filesystem_credentials(site_url() . '/wp-admin/', '', false, false, array()) : false;

            // Get instance of WP_Filesystem
            if ($creds && WP_Filesystem($creds) && isset($GLOBALS['wp_filesystem'])) {
                $this->wp_filesystem = $GLOBALS['wp_filesystem'];
            } else {
                $this->wp_filesystem = false;
            }
        }

        return $this->wp_filesystem;
    }

    /**
     * Checks the path against the list of paths where we shouldn't put directory indexes.
     * 
     * @since   4.0.5
     * @access  private
     * 
     * @param   string $path
     * @return  bool
     */
    private function is_incompatible_path($path = '')
    {
        foreach ($this->incompatible_paths as $incompatible_path) {
            if (preg_match('~' . $incompatible_path . '~si', $path)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Wrapper method, checks whether the pathname is a directory.
     *
     * @since   4.1.8
     * @access  private
     *
     * @param   string $pathname
     * @return  bool
     */
    private function path_is_dir($pathname)
    {
        // Initialize the WP API
        if (false !== $this->init_wp_filesystem()) {
            return $this->wp_filesystem->is_dir($pathname);
        }

        // Fallback to built-in function
        return @is_dir($pathname);
    }

    /**
     * Wrapper method, creates the directory specified by pathname.
     *
     * @since   4.1.8
     * @access  private
     *
     * @param   string $pathname
     * @return  bool
     */
    private function path_mkdir($pathname)
    {
        $chmod = defined('FS_CHMOD_DIR') ? FS_CHMOD_DIR : fileperms(WP_CONTENT_DIR) & 0777 | 0755;

        // Initialize the WP API
        if (false !== $this->init_wp_filesystem()) {
            return $this->wp_filesystem->mkdir($pathname, $chmod);
        }

        // Fallback to built-in function
        return @mkdir($pathname, $chmod);
    }

    /**
     * List files (or directories only) inside the specified path, recursively 
     * or non-recursively, with specified depth limit.
     * 
     * @since   1.2.0
     * @access  private
     * 
     * @param   string $directory
     * @param   bool $dirs_only
     * @param   int $depth_limit
     * @param   int $depth
     * @return  array
     */
    private function scandir_recursively($directory, $dirs_only = true, $depth_limit = 3, $depth = 1)
    {
        $dirs = array();
        $files = array();

        // Read files list
        if (function_exists('glob')) { //PHP 4 >= 4.3.0
            $files = glob($directory . DIRECTORY_SEPARATOR . '{,.}*', GLOB_BRACE | GLOB_NOSORT);
        } else {
            if (($handle = opendir($directory))) {
                while (false !== ($filename = readdir($handle))) {
                    $files[] = $directory . DIRECTORY_SEPARATOR . $filename;
                }

                closedir($handle);
            }
        }

        // Recursive directory listing
        if (is_array($files)) {
            foreach ($files as $i => $file) {
                $filename = substr($file, strlen($directory) + 1);
                if ($filename === '.' || $filename === '..') {
                    unset($files[$i]);
                } elseif (is_dir($file)) {
                    if ($depth_limit <= 0 || $depth < $depth_limit) { // Limit max scan depth
                        $dirs = array_merge($dirs,
                                            $this->scandir_recursively($file, $dirs_only, $depth_limit, $depth + 1));
                    }
                } elseif ($dirs_only) {
                    unset($files[$i]);
                }
            }
        }

        return array_merge($files, $dirs);
    }

}
