<?php

/**
 * The file that defines the converter class.
 *
 * @link       https://cobweb-security.com
 * @since      1.0.1
 *
 * @package    Cwsd
 * @subpackage Cwsd/includes/defender
 * @author     Cobweb Security <cwis@cobweb-security.com>
 */
class Cwis_Defender_Converter
{

    // Classes instances
    private $cwis_defender_config;
    //
    // Parsed URL replacements
    private $url_replacement, $url_replacement_dirname, $url_replacement_list = array();
    //
    // Used in router requests
    private $router_file_extension, $router_file_path, $router_replacement_key, $router_replacement_url;
    private $router_prefix = '/cwsd.php?';
    // Modified Base64 variant, for more details https://en.wikipedia.org/wiki/Base64#URL_applications
    private $router_base64_replace = array(
        '+' => '-',
        '/' => '_',
        '=' => ''
    );
    //
    // CSS and JS extensions
    private $css_js_extensions = array(
        'css', 'css3', 'js', 'json'
    );
    //
    // Executable files extensions
    private $executable_extensions = array(
        'asm', 'asp', 'aspx', 'bat', 'bin', 'c', 'cfm', 'cgi', 'csh', 'cpp', 'deb', 'dll', 'exe',
        'java', 'jsp', 'inc', 'o', 'out', 'php', 'php3', 'php4', 'php5', 'php7', 'pht', 'phtm', 'phtml',
        'pl', 'py', 'rb', 'rpm', 'run', 'sh', 'so', 'sql', 'shtml', 'tpl', 'vmx'
    );
    //
    // File fallbacks if not found
    private $file_path_fallbacks = array(
        '@2x.jpg'  => '.jpg',
        '@2x.jpeg' => '.jpeg',
        '@3x.jpg'  => '.jpg',
        '@3x.jpeg' => '.jpeg',
        '@2x.png'  => '.png',
        '@3x.png'  => '.png',
        '.min.css' => '.css',
        '.min.js'  => '.js'
    );
    //
    // Home URL host parsed
    private $home_url, $home_url_host, $home_url_path = '';
    //
    // URL encoder pattern based on router prefix
    private $preg_url_encoder = array(
        'pattern' => '',
        'prefix'  => '(?<=[\s\=\(\'\"])([^\s\'\"]*?)',
        'suffix'  => '(\w{2}\=[^\s\'\"\)\<\>]+)'
    );

    /**
     * Initializes converter and parses URL replacements.
     *
     * @since   1.0.1
     * @access  public
     */
    public function __construct()
    {
        // Require and init the config class
        require_once dirname(__FILE__) . '/class-config.php';
        $this->cwis_defender_config = new Cwis_Defender_Config();

        // Require and init the guarder class
        require_once dirname(__FILE__) . '/class-guarder.php';
        $this->cwis_defender_guarder = new Cwis_Defender_Guarder();

        // Parse URL replacements
        foreach ($this->cwis_defender_config->url_replacement_list as $url => $key) {
            $this->url_replacement_list[$url] = $this->router_prefix . $key . '=';
        }

        // Compose preg_url_encoder['pattern']
        $this->preg_url_encoder['pattern'] = '~' . $this->preg_url_encoder['prefix']
                . preg_quote($this->router_prefix) . $this->preg_url_encoder['suffix'] . '~s';

        // Parse website home URL
        $this->home_url = function_exists('home_url') ? home_url() : $_SERVER['REQUEST_URI'];
        $parsed_url = parse_url($this->home_url);
        $this->home_url_host = '//' . $parsed_url['host'];
        if (isset($parsed_url['path']) && false !== ($dspos = strrpos($parsed_url['path'], '/'))) {
            $this->home_url_path = substr($parsed_url['path'], 0, $dspos);
        }
    }

    /**
     * Filters and sanitizes query, sets router parameters on success (returns FALSE on fail).
     * 
     * @since   1.0.1
     * @access  public
     * 
     * @return  bool
     */
    public function process_router_request()
    {
        $http_get_vars = (array) $_GET;

        // Decode query string if need
        if (isset($_SERVER['QUERY_STRING'])) {
            $query_string = rawurldecode($_SERVER['QUERY_STRING']);

            // Handle JS-modified and concatenated paths
            if (false !== ($prefix_pos = strpos($query_string, $this->router_prefix))) {
                $query_string = substr($query_string, $prefix_pos + strlen($this->router_prefix));
            } elseif (($url_pos = strpos($query_string, '/http:/')) || ($url_pos = strpos($query_string, '/https:/'))) {
                $location = substr($query_string, $url_pos + 1);
                $this->redirect_browser($location);
            }

            // Drop query parameters and decrypt path
            $query_tokenized = strtok($query_string, '?');
            if (strpos($query_tokenized, '=') !== 2 && false !== ($dotpos = strpos($query_tokenized, '.'))) {
                // Safe replacements for base64-encoded string, quote section 2.3 of RFC 3986:
                // "...letters, decimal digits, hyphen, period, underscore, and tilde."
                $base64_search = array_values($this->router_base64_replace);
                $base64_replace = array_keys($this->router_base64_replace);

                // Get rid of file extension
                $this->router_file_extension = substr($query_tokenized, $dotpos + 1);
                $query_tokenized = substr($query_tokenized, 0, $dotpos);

                // Decrypt path segments
                $segments = explode('/', $query_tokenized);
                foreach ($segments as $i => $segment) {
                    $segment_crypted = base64_decode(str_replace($base64_search, $base64_replace, $segment));
                    $segments[$i] = $this->bitwise_crypt($segment_crypted, __FILE__);
                }
                parse_str(implode('/', $segments), $http_get_vars);
            }
        }

        // Filter and sanitize params
        // Pair example: '/wp-content/uploads/' => '/cwsd.php?cu='
        foreach ($this->cwis_defender_config->url_replacement_list as $url => $key) {
            $file_path = (2 === strlen($key) && isset($http_get_vars[$key])) ?
                    filter_var($http_get_vars[$key], FILTER_SANITIZE_STRING) : '';

            // Check if valid URL and file path
            if ($url && $file_path && false === strpos($file_path, '../')) {
                $this->router_file_path = str_replace('\\', '/', $file_path);
                $this->router_replacement_key = $key;
                $this->router_replacement_url = $url;
                return true;
            }
        }

        return false;
    }

    /**
     * Otputs file contents to browser.
     * 
     * @since   1.0.1
     * @access  public
     * 
     * @param   int $cache_max_age
     * @return  bool
     */
    public function output_file_contents($cache_max_age = 604800)
    {
        // Support for JCH Optimize Pro
        if (0 === strpos($this->router_file_path, 'jch-optimize')) {
            $URI = isset($_SERVER['REQUEST_URI']) ? $_SERVER['REQUEST_URI'] : null;
            if ($URI && false !== ($prefix_pos = strpos($URI, $this->router_prefix))) {
                $base_path = substr($URI, 0, $prefix_pos);
                $location = $base_path . $this->router_replacement_url . $this->router_file_path;
                $this->redirect_browser($location);
            }
        }

        // Handle JS-modified paths, like /wp-content/themes/theme-child/https://fast.fonts.net/t/1.css
        if (($url_pos = strpos($this->router_file_path, '/http:/')) ||
                ($url_pos = strpos($this->router_file_path, '/https:/'))) {
            $location = substr($this->router_file_path, $url_pos + 1);
            $this->redirect_browser($location);
        }

        // Prepend root directory and replacement to the file path (discard file version using strtok)
        $abs_file_path = ABSPATH . ltrim($this->router_replacement_url, '\/') . strtok($this->router_file_path, '?');

        // Check if file exists and readable
        if (!is_readable($abs_file_path)) {
            // Debug
            //print_r($abs_file_path);
            //exit;
            if (is_readable($abs_file_path . $this->router_file_extension)) { // check if JS-modified
                $abs_file_path .= $this->router_file_extension;
            } else {
                $abs_file_path = strtr($abs_file_path, $this->file_path_fallbacks);
                if (!is_readable($abs_file_path)) { // checking fallback
                    return false;
                }
            }
        }

        // Get file extension
        $extension = $this->get_file_extension(strtolower($abs_file_path));

        // Support for executable plugins/themes files
        if (in_array($extension, $this->executable_extensions)) {
            $location = $this->home_url_path . $this->router_replacement_url . $this->router_file_path;
            $this->redirect_browser($location);
        }

        // Track the file load
        $this->cwis_defender_guarder->track_pageview('.' . $extension);

        // Detect MIME content-type
        $mime_type = 'text/html';
        if (null !== $extension && isset($this->cwis_defender_config->mime_types_map[$extension])) {
            $mime_type = $this->cwis_defender_config->mime_types_map[$extension];
        } elseif (function_exists('mime_content_type')) {
            $mime_type = mime_content_type($abs_file_path);
        }

        // Detect if CSS or JS file
        $is_css_js_file = in_array($extension, $this->css_js_extensions);

        // Output headers
        header('Content-Type: ' . $mime_type . ($is_css_js_file ? '; charset=UTF-8' : ''));
        header('Expires: ' . gmdate("D, d M Y H:i:s", time() + $cache_max_age) . ' GMT');
        header("Cache-Control: public, max-age=$cache_max_age");
        header('Last-Modified: ' . gmdate('D, d M Y H:i:s', filemtime($abs_file_path)) . ' GMT', true);

        // Enable gzip compression
        if (isset($_SERVER['HTTP_ACCEPT_ENCODING']) && false !== strpos($_SERVER['HTTP_ACCEPT_ENCODING'], 'gzip')) {
            ob_start('ob_gzhandler') OR ob_start();
        } else {
            ob_start();
        }

        // Open file contents
        if (($handle = fopen($abs_file_path, "r"))) {
            $file_data = fread($handle, filesize($abs_file_path));
            fclose($handle);
        }

        // Process CSS and JS
        if ($is_css_js_file) {
            $file_data = $this->remove_css_js_comments($file_data);
            $file_data = $this->remove_html_indentation($file_data);

            // Ignore JS-files
            if ($extension !== 'js') {
                $file_path = pathinfo(strtok($this->router_file_path, '?'), PATHINFO_DIRNAME); //discard file version
                $file_path_segments = explode('/', $file_path);
                $file_path_depth = count($file_path_segments);
                $url_replacement = $this->home_url_path . $this->url_replacement_list[$this->router_replacement_url];

                // Replace relative paths:
                // 1) processing CSS file /cwsd.php?in=css/dashicons.min.css
                //  url(../fonts/dashicons.ttf) => url(/cwsd.php?in=fonts/dashicons.ttf)
                // 2) processing CSS file /cwsd.php?in=theme/css/dashicons.min.css
                //  url(../fonts/dashicons.ttf) => url(/cwsd.php?in=theme/fonts/dashicons.ttf)
                // 3) processing CSS file /cwsd.php?in=theme/css/dashicons.min.css
                //  url(../../fonts/dashicons.ttf) => url(/cwsd.php?in=fonts/dashicons.ttf)
                for ($depth = $file_path_depth; $depth > 0; $depth--) {
                    $file_path = implode('/', array_slice($file_path_segments, 0, $file_path_depth - $depth));
                    $search = str_repeat('../', $depth);
                    $replace = $url_replacement;
                    for ($shift = 0; $shift < $file_path_depth - $depth; $shift++) {
                        $replace .= $file_path_segments[$shift] . '/';
                    }
                    $file_data = str_ireplace('url(\'' . $search, 'url(\'' . $replace, $file_data);
                    $file_data = str_ireplace('url("' . $search, 'url("' . $replace, $file_data);
                    $file_data = str_ireplace('url(' . $search, 'url(' . $replace, $file_data);
                }

                // Replace relative paths:
                // 4) processing CSS file /cwsd.php?ct=multihost/style.css
                //  url("css/reset.css") => url("/cwsd.php?ct=multihost/css/reset.css")
                //  @import 'stylesheets/main.css' => @import '/cwsd.php?ct=multihost/stylesheets/main.css';
                //  @import "reset.css" => @import "/cwsd.php?ct=multihost/reset.css";
                $file_path = implode('/', $file_path_segments) . '/';
                $this->url_replacement = $url_replacement . $file_path;
                $this->url_replacement_dirname = $this->router_replacement_url . $file_path;
                $file_data = preg_replace_callback("~\b(url\(\s*\')([^\']+\'\s*\))~i",
                                                   array($this, 'preg_url_replacer_callback'), $file_data);
                $file_data = preg_replace_callback("~\b(url\(\s*\")([^\"]+\"\s*\))~i",
                                                   array($this, 'preg_url_replacer_callback'), $file_data);
                $file_data = preg_replace_callback("~\b(url\()([^\s\'\"\)]+\))~i",
                                                   array($this, 'preg_url_replacer_callback'), $file_data); //be careful with matching!
                $file_data = preg_replace_callback("~(\@import\s*\')([^\']+[\'])~i",
                                                   array($this, 'preg_url_replacer_callback'), $file_data);
                $file_data = preg_replace_callback("~(\@import\s*\")([^\"]+[\"])~i",
                                                   array($this, 'preg_url_replacer_callback'), $file_data);

                // Encode URLs, stop on close parenthesis, CSS syntax: url(path/to/image.jpg);
                $file_data = preg_replace_callback($this->preg_url_encoder['pattern'],
                                                   array($this, 'preg_url_encoder_callback'), $file_data);
            }
        }

        echo $file_data;

        // Check nesting level
        if (ob_get_level() > 0) {
            $ob_contents = ob_get_contents();
            ob_end_clean();

            echo $ob_contents;
        }

        return true;
    }

    /**
     * Returns response headers using apache_response_headers()
     * or an alternative when function is not available.
     * 
     * @since   1.0.7
     * @access  public
     * 
     * @return  array
     */
    public function apache_response_headers()
    {
        if (function_exists('apache_response_headers')) {
            $headers = apache_response_headers();
        } else {
            $headers = array();
            foreach ($_SERVER as $key => $value) {
                if (substr($key, 0, 5) !== 'HTTP_') {
                    continue;
                }

                $header = str_replace(' ', '-', ucwords(str_replace('_', ' ', strtolower(substr($key, 5)))));
                $headers[$header] = $value;
            }
        }

        return $headers;
    }

    /**
     * Removes CSS/JS comments from the source code.
     * 
     * @since   1.0.7
     * @access  public
     * 
     * @param   string $source
     * @return  string
     */
    public function remove_css_js_comments($source = '')
    {
        // To prevent JS-errors, the block comment must be replaced with a newline character
        return preg_replace("~(?:^|\s)\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/(?:\s|$)~s", "\n", $source);
    }

    /**
     * Removes multiple empty lines from the source code.
     * 
     * @since   1.0.7
     * @access  public
     * 
     * @param   string $source
     * @return  string
     */
    public function remove_empty_lines($source = '')
    {
        return preg_replace("/[\n\r]{2,}/", "\n", $source);
    }

    /**
     * Removes comment tags and conditional comments from the source code.
     * 
     * @since   1.0.7
     * @access  public
     * 
     * @param   string $source
     * @return  string
     */
    public function remove_html_comments($source = '')
    {
        return preg_replace("/<!--(?!\s*(?:\[if [^\]]+]|<!|>))(?:(?!-->)(.|\n))*-->/sm", "", $source);
    }

    /**
     * Removes markup indentation (formatting) from the source code.
     *
     * @since   1.0.7
     * @access  public
     * 
     * @param   string $source
     * @return  string
     */
    public function remove_html_indentation($source = '')
    {
        return preg_replace("/(^[\r\n]*|[\r\n]+)[\s\t]*[\r\n]+/", "\n", $source);
    }

    /**
     * Replace the urls within given content.
     * 
     * @since   1.0.7
     * @access  public
     * 
     * @param   mixed $text
     * @param   bool $url_encoder
     * @param   bool $js_packer
     * @return  string
     */
    public function replace_html_content_urls($text, $url_encoder = true, $js_packer = true)
    {
        if (count($this->url_replacement_list) < 1) {
            return $text;
        }

        // Exclude scheme to match urls without it
        $_replacements = array();
        $_replacements_np = array(); //no protocol
        //
        // Relative URL replacements
        $_relative_url_replacements = array();
        //
        // Domain URL replacements
        $_relative_domain_url_replacements = array();

        // Build list of domain URLs
        $host_without_www = str_ireplace('//www.', '//', $this->home_url_host);
        $host_with_www = substr_replace($host_without_www, 'www.', 2, 0);
        $domain_urls = array(
            'http:' . $host_with_www,
            'http:' . $host_without_www,
            'https:' . $host_with_www,
            'https:' . $host_without_www,
        );

        // Process URL replacement list
        foreach ($this->url_replacement_list as $old_url => $new_url) {
            // Add quote to make sure it's actualy a link value and is right at the start of text
            $old_url_relative = str_ireplace($this->home_url, "", $old_url);
            $new_url_relative = str_ireplace($this->home_url, "", $new_url);
            $_relative_url_replacements['"' . $old_url_relative] = '"' . $new_url_relative;
            $_relative_url_replacements["'" . $old_url_relative] = "'" . $new_url_relative;

            // Replace domain URLs
            foreach ($domain_urls as $domain_url) {
                $old_url_no_domain = str_ireplace($domain_url, "", $old_url);
                $new_url_no_domain = str_ireplace($domain_url, "", $new_url);
                $_relative_domain_url_replacements['"' . $old_url_no_domain] = '"' . $new_url_no_domain;
                $_relative_domain_url_replacements["'" . $old_url_no_domain] = "'" . $new_url_no_domain;
            }

            // Match URLs without protocol
            $old_url_np = str_ireplace(array('http:', 'https:'), "", $old_url);
            $new_url_np = str_ireplace(array('http:', 'https:'), "", $new_url);
            $_replacements_np[$old_url_np] = $new_url_np;

            $old_url_np2 = str_ireplace(array('http://', 'https://'), "", $old_url);
            $new_url_np2 = str_ireplace(array('http://', 'https://'), "", $new_url);
            $_replacements[$old_url_np2] = $new_url_np2;
        }

        // Replace URLs without protocol
        $text = str_ireplace(array_keys($_replacements_np), array_values($_replacements_np), $text);
        $text = str_ireplace(array_keys($_replacements), array_values($_replacements), $text);


        // Relative tp domain urls replacements; using subfolder e.g. 127.0.0.1/foo/wordpress_site, this will be /foo/wordpress_site
        $text = str_ireplace(array_keys($_relative_domain_url_replacements),
                                        array_values($_relative_domain_url_replacements), $text);

        // Relative URLs replacements
        $text = str_ireplace(array_keys($_relative_url_replacements), array_values($_relative_url_replacements), $text);

        // Check for JSON encoded urls
        foreach ($_replacements_np as $old_url => $new_url) {
            $old_url = trim(json_encode($old_url), '"');
            $new_url = trim(json_encode($new_url), '"');

            $text = str_ireplace($old_url, $new_url, $text);
        }

        // Check for URL encoded urls
        foreach ($_replacements_np as $old_url => $new_url) {
            $old_url = trim(urlencode($old_url), '"');
            $new_url = trim(urlencode($new_url), '"');

            $text = str_ireplace($old_url, $new_url, $text);
        }

        // Check for JSON encoded urls
        foreach ($_replacements as $old_url => $new_url) {
            $old_url = trim(json_encode($old_url), '"');
            $new_url = trim(json_encode($new_url), '"');

            $text = str_ireplace($old_url, $new_url, $text);
        }

        // Check for URL encoded urls
        foreach ($_replacements as $old_url => $new_url) {
            $old_url = trim(urlencode($old_url), '"');
            $new_url = trim(urlencode($new_url), '"');

            $text = str_ireplace($old_url, $new_url, $text);
        }

        // Encode URLs
        if ($url_encoder) {
            // Stop on close parenthesis, CSS syntax: url(path/to/image.jpg);
            $text = preg_replace_callback($this->preg_url_encoder['pattern'], array($this, 'preg_url_encoder_callback'),
                                          $text);
        }

        // Pack the JS code
        if ($js_packer) {
            $preg_js_packer_pattern = '~(<script\s+type=[\"\']text/javascript[\"\']>)(.+?)(</script>)~si';
            $text = preg_replace_callback($preg_js_packer_pattern, array($this, 'preg_js_packer_callback'), $text);
        }

        return $text;
    }

    // --- CALLBACKS ---

    /**
     * JS packer callback for preg_replace_callback.
     * 
     * @since   1.1.0
     * @access  public
     * 
     * @param   array $matches
     * @return  string
     */
    public function preg_js_packer_callback($matches)
    {
        // Skip if script is packed already
        $embedded_script = $matches[2];
        if (strlen($embedded_script) > 12 && false !== strpos($embedded_script, 'wp-')) {
            // TODO: fix packer's JS-error "Uncaught SyntaxError: Unexpected token { at (index):.."
            require_once dirname(__FILE__) . '/class-packer.php';

            // Pack embeded script
            $jsPacker = new Cwis_Defender_Packer($embedded_script);
            $matches[2] = $jsPacker->pack();
        }

        return $matches[1] . $matches[2] . $matches[3];
    }

    /**
     * URL encoder callback for preg_replace_callback. The method is canonicalizes
     * the pathname like realpath() and encrypts the path segments.
     * 
     * @since   1.1.0
     * @access  public
     * 
     * @param   array $matches
     * @param   bool $encrypt
     * @return  string
     */
    public function preg_url_encoder_callback($matches, $encrypt = true)
    {
        // Skip if trailing slash (directory) 
        if ('/' === substr($matches[2], -1)) {
            return $matches[0];
        }

        // Skip the encoded quotation marks
        if (false !== strpos($matches[0], '&quot;')) {
            return $matches[0];
        }

        // Get an original image from the "timthumb"-ed path
        // URL example: https://example.com/timthumb.php?src=https://example.com/wp-content/uploads/2018/05/photo.jpg&w=128&h=96&q=100
        if (false !== ($imgpos = strpos($matches[1], '/timthumb.php?'))) {
            $matches[1] = substr($matches[1], 0, $imgpos);
            if (false !== ($amppos = strpos($matches[2], '&'))) {
                $matches[2] = substr($matches[2], 0, $amppos);
            }
            //$matches[0] = $matches[1] . $this->router_prefix . $matches[2];
        }

        // Get an original image from the "timthumb"-ed path
        // URL example: /wp-content/themes/theme/scripts/timthumb.php?src=/wp-content/uploads/2018/01/photo.jpg&w=128&h=96
        if (false !== ($imgpos = strpos($matches[2], '/timthumb.php?'))) {
            $result = array();
            parse_str(substr($matches[2], $imgpos + 14), $result);
            if (isset($result['src'])) { //$path_to_file
                return $matches[1] . $result['src'];
            }
        }

        // Compare domain with the home URL
        if (($domain = stripslashes($matches[1])) && false === stripos($domain, $this->home_url_host)) {
            $this->restore_broken_paths($matches[0]);
            return $matches[0];
        }

        // Prevent recursive encoding (fixes issues with cache plugins)
        $this->restore_broken_paths($matches[2]);

        // Drop version URL parameter (clean extension)
        $path_to_file = strtok($matches[2], '?');

        // Get file extension and actual path delimiter
        $extension = $this->get_file_extension($path_to_file);
        $delimiter = (false !== strpos($path_to_file, '\/')) ? '\/' : '/';

        // Ignore empty extensions
        if (!strlen($extension)) {
            return $matches[1] . $this->home_url_path . $this->router_prefix . $matches[2];
        }
        // Do not encode executable files pathnames
        // Encode URLs like "/wp-content/themes/theme/compressed_css.php?colorscheme=gray&isrtl=ltr"
        elseif (in_array($extension, $this->executable_extensions)) {
            $urlencoded_path = $path_to_file . urlencode(substr($matches[2], strlen($path_to_file)));
            return $matches[1] . $this->home_url_path . $this->router_prefix . $urlencoded_path;
        }

        // Extract replacement key from the file path
        if (false !== ($eqpos = strpos($path_to_file, '='))) {
            $path_key = substr($path_to_file, 0, $eqpos + 1);
            $path_to_file = substr($path_to_file, $eqpos + 1);
        } else {
            $path_key = '';
        }

        // Process /. and /.. like the realpath()
        // Example: skins/../img/blank.gif => img/blank.gif
        $parts = explode($delimiter, $path_to_file);
        $segments = array();
        foreach ($parts as $i => $part) {
            if ('.' === $part) {
                continue;
            }

            if ('..' === $part) {
                if ($i > 1) {
                    array_pop($segments);
                } elseif ($path_key) {
                    $path_key[1] = '_'; //upper path keys ('c_' and 'i_')
                }
            } else {
                $segments[] = $part;
            }
        }

        // Return non-encrypted path
        if (!$encrypt) {
            return $matches[1] . $this->home_url_path . $this->router_prefix . $path_key . implode($delimiter, $segments);
        }

        // URL-safe replacements for base64-encoded string
        $base64_search = array_keys($this->router_base64_replace);
        $base64_replace = array_values($this->router_base64_replace);

        // Encrypt path segments (restore the 1st segment)
        foreach ($segments as $i => $segment) {
            $segment_crypted = $this->bitwise_crypt($i === 0 ? ($path_key . $segment) : $segment, __FILE__);
            $segments[$i] = str_replace($base64_search, $base64_replace, base64_encode($segment_crypted));
        }

        // Create the encrypted path (support for JS-escaped paths)
        return $matches[1] . $this->home_url_path . $this->router_prefix . implode($delimiter, $segments) . '.' . $extension;
    }

    /**
     * URL replacer callback for preg_replace_callback.
     * 
     * @since   4.1.5
     * @access  public
     * 
     * @param   array $matches
     * @return  string
     */
    public function preg_url_replacer_callback($matches)
    {
        $path_to_file = trim($matches[2]);
        if (strlen($path_to_file) > 2) {
            $first_char = $path_to_file[0];
            if ('+' !== $first_char && '+' !== substr($path_to_file, -1)) { //is not a JS-expression
                if (0 !== strpos($path_to_file, 'data:') && //is not base64-encoded data
                        0 !== strpos($path_to_file, 'blob:') && //is not JavaScript Blob URL
                        false === strpos($path_to_file, $this->router_prefix) && //is not replaced already path
                        !preg_match("~^(ht|f)tps?://~i", $path_to_file)) { //is not an absolute path
                    // Remove the dirname from the absolute path
                    if ('/' === $first_char && 0 === strpos($path_to_file, $this->url_replacement_dirname)) {
                        $path_to_file = substr($path_to_file, strlen($this->url_replacement_dirname));
                    }

                    return $matches[1] . $this->url_replacement . $path_to_file;
                }
            }
        }

        return $matches[0];
    }

    // --- PRIVATE ---

    /**
     * String EnCrypt + DeCrypt function.
     *
     * @author: halojoy
     * @author: laserlight
     * @since   1.2.0
     * @access  private

     * @param   string $string
     * @param   string $key
     * @return  string
     */
    private function bitwise_crypt($string, $key = '')
    {
        // Remove the spaces in the key 
        $key = str_replace(' ', '', $key);

        // Return text rotated if the key is blank or short
        if ('' === $key || strlen($key) < 8) {
            return str_rot13($string);
        }

        // Set key length to be no more than 32 characters 
        if (strlen($key) > 32) {
            $key = substr($key, -32);
        }

        // We use this a couple of times or so 
        $string_len = strlen($string);

        // Fill key with the bitwise AND of the ith key character and 0x1F, padded to length of text. 
        $lomask = str_repeat("\x1f", $string_len); // Probably better than str_pad 
        $himask = str_repeat("\xe0", $string_len);
        $k = str_pad("", $string_len, $key); // this one _does_ need to be str_pad
        // 
        // {en|de}cryption algorithm. The whole thing. Right here. 
        return (($string ^ $k) & $lomask) | ($string & $himask);
    }

    /**
     * Returns the filename's string extension, else if no extension found returns NULL.
     * If the filename has more than one extension, returns only the last one.
     * 
     * @since   4.1.3
     * @access  private
     * 
     * @param   string $filename
     * @return  null|string
     */
    private function get_file_extension($filename = '')
    {
        if (false !== ($dspos = strrpos($filename, '/')) ||
                false !== ($dspos = strrpos($filename, '\\')) ||
                false !== ($dspos = strrpos($filename, ':'))) {
            $filename = substr($filename, $dspos + 1);
        }

        if (false !== ($dotpos = strrpos($filename, '.'))) {
            return substr($filename, $dotpos + 1);
        }

        return null;
    }

    /**
     * Redirects browser to a new location.
     * 
     * @since   4.1.8
     * @access  private
     * 
     * @param   string $location
     */
    private function redirect_browser($location)
    {
        // Fix broken protocol, e.g convert "http:/example.com" to "http://example.com"
        if (false !== ($ppos = strpos($location, ':/')) && isset($location[$ppos + 2]) && $location[$ppos + 2] !== '/') {
            $location = substr_replace($location, '/', $ppos + 2, 0);
        }
        header('Location: ' . $location);
        exit;
    }

    /**
     * Tries to restore the broken paths (replaced multiple times). Returns TRUE on success.
     * Path example: /wp-content/plugins/jch-optimize/assets/wp-content/plugins/gz/ 
     *            => /cwsd.php?cp=jch-optimize/assets/cwsd.php?cp=gz/
     * 
     * @since   4.0.3
     * @access  private
     * 
     * @param   string $string
     * @param   int $offset
     * @return  bool
     */
    private function restore_broken_paths(&$string, $offset = 0)
    {
        if (false !== ($prefix_pos = strpos($string, $this->router_prefix, $offset))) {
            $key_length = strlen($this->router_prefix) + 3;
            $key = substr($string, $prefix_pos, $key_length);
            if (($replacement_path = array_search($key, $this->url_replacement_list))) {
                $string = substr_replace($string, $replacement_path, $prefix_pos, $key_length);
                return true;
            }
        }

        return false;
    }

}
