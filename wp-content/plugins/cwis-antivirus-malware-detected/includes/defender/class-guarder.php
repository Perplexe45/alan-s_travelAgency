<?php

/**
 * The file that defines the guarder class.
 *
 * @link       https://cobweb-security.com
 * @since      1.4.0
 *
 * @package    Cwsd
 * @subpackage Cwsd/includes/defender
 * @author     Cobweb Security <cwis@cobweb-security.com>
 */
class Cwis_Defender_Guarder
{

    // Classes instances
    private $cwis_defender_filesystem;
    //
    // Paths to plugin and temp-files directories
    private $plugin_dir_path, $temp_dir_path;
    //
    // List of (relative) paths to "hunting traps"
    private $paths_to_traps = array(
        'searchreplacedb2.php',
        'wp-content/index.php',
        'wp-content/cache/index.php',
        'wp-content/languages/index.php',
        'wp-content/logs/index.php',
        'wp-content/plugins/index.php',
        'wp-content/themes/index.php',
        'wp-content/upgrade/index.php',
        'wp-content/uploads/index.php',
        'wp-includes/index.php',
        'wp-includes/css/index.php',
        'wp-includes/fonts/index.php',
        'wp-includes/images/index.php',
        'wp-includes/js/index.php',
    );
    //
    // RegEx patterns to block unwanted users
    private $unwanted_user_agents = array(
        'AntiBot'    => null, // Anti Bot Protection
        'BadBot'     => '\?{3,}|80legs|Acunetix|admedia|BlackWidow|CCBot|crawler4j|DragonBot|EnigmaBot|Ezooms|Findxbot|InfoSeek|Ichiro|libwww-perl|MegaIndex|ScoutJet|Seznam|SlowBot|SMTBot|TalkTalk|Valkyrie|Voltron|webalta',
        'BruteForce' => null, // Brute Force Attack
        'Copier'     => 'duggmirror|(Email|WWW)(Collector|Siphon)|Extractor|Go!Zilla|GetRight|Harvest|HTTP\s*Weazel|HTTrack|IDentity|Leech|Offline\s*(Commander|Explorer)|Teleport|Web\s*(Bandit|Copier|Downloader|Ferret|Fetcher|Layers|Linker|Moose|Reaper|Snake|Stripper|Vac|Walk|ZIP)',
        //'SEOBot'     => 'Ahrefs|BLEXBot|linkdexbot|LinkWalker|MJ12bot|SEMrush|SISTRIX',
        'Trap'       => null, // Guarder Traps
        'WPScan'     => '^WPScan\s+v[0-9.]+\s+\(http:\/\/wpscan\.org\)$'
    );
    //
    // Antibot database settings
    private $antibot_expiry = 1814400; // 21 day in seconds
    private $antibot_filename = 'cwsd-antibot.db';
    // 
    // Guarder database settings
    private $guarder_block = 86400; // 1 day in seconds
    private $guarder_expiry = 1814400; // 21 day in seconds
    private $guarder_filename = 'cwsd-guarder.db';
    //
    // Defender IP filter cache file
    private $ipfilter_filename = 'cwsd-ipfilter.db';
    //
    // Path to guarder log file (UA of blocked users)
    private $log_filename = 'cwsd-guarder.log';

    /**
     * Traffic statistics (website pageviews).
     * 
     * There are three types of Web site statistics, a hit, a page view (or pages) and a visitor (or visits). Each of these measures something different:
     *  Hits – A single file request in the access log of a Web server. For example, a request for an HTML page with three graphic images will result in four hits in the log: one for the HTML text file and one for each of the graphic image files. While a hit is a meaningful measure of how much traffic a server handles, it can be a misleading indicator of how many pages are being viewed. Instead, advertising agencies and their clients look at the number of pages delivered and ad impressions or views.
     *  Page Views / Pages – This measures how many times someone has viewed an entire page including all text, images, etc.
     *  Visitors / Visits – This is defined as a series of hits from any particular IP address. If any two hits are separated by 30 minutes or more, two visitors are counted. "Visitors" represent an extrapolated number.
     *
     * @var string 
     */
    private $traffic_filename = 'cwsd-traffic.db';

    /**
     * Initializes class.
     *
     * @since    1.0.1
     */
    public function __construct()
    {
        // Require the plugin filesystem class
        require_once dirname(__FILE__) . '/class-filesystem.php';

        // Init the filesystem methods
        $this->cwis_defender_filesystem = new Cwis_Defender_Filesystem();

        // Get path to plugin directory
        $this->plugin_dir_path = dirname(dirname(dirname(__FILE__))) . '/';

        // Create temporary files directory
        $this->temp_dir_path = $this->cwis_defender_filesystem->create_temp_files_directory($this->plugin_dir_path);
    }

    // --- ANTIBOT ---

    /**
     * Checks for user data in antibot database.
     * 
     * @since   4.1.0.5
     * @access  public
     * 
     * @param   string $uid
     * @param   string $description
     * @return  bool
     */
    public function check_antibot_activity($uid = '', $description = '')
    {
        $ip_array = $this->get_client_ips();
        $ip_array[] = $uid;
        $the_packed_ip = implode('|', $ip_array);

        // Check if user data is matched in current hour's logs
        $antibot_entries_60 = $this->fetch_packed_entries($this->antibot_filename, 3600);
        $antibot_matches_60 = $this->match_packet_entries($antibot_entries_60, $the_packed_ip, $description);

        // Check if user data is matched in 15 min period's logs
        $antibot_entries_15 = $this->filter_packed_entries($antibot_entries_60, 900);
        $antibot_matches_15 = $this->match_packet_entries($antibot_entries_15, $the_packed_ip, $description);

        return array(
            15 => array(
                'bot'   => array_sum($antibot_matches_15),
                'human' => count($antibot_matches_15),
            ),
            60 => array(
                'bot'   => array_sum($antibot_matches_60),
                'human' => count($antibot_matches_60),
            ),
        );
    }

    /**
     * Checks if user is a search engine bot.
     * 
     * @since   4.1.0.5
     * @access  public
     * 
     * @param   string $uid
     * @param   string $description
     * @return  bool
     */
    public function is_search_engine_bot()
    {
        // Bing, Google and Yahoo Bot IP Addresses sorted by shares
        // https://myip.ms/info/bots/Google_Bing_Yahoo_Facebook_etc_Bot_IP_Addresses.html
        $crawlers = array(
            'google' => '203.208.60.0/24, 66.249.64.0/20, 72.14.199.0/24, 209.85.238.0/24, 66.249.90.0/24, 66.249.91.0/24, 66.249.92.0/24',
            'bing'   => '65.52.104.0/24, 65.52.108.0/22, 65.55.24.0/24, 65.55.52.0/24, 65.55.55.0/24, 65.55.213.0/24, 65.55.217.0/24, 131.253.24.0/22, 131.253.46.0/23, 40.77.167.0/24, 199.30.27.0/24, 157.55.16.0/23, 157.55.18.0/24, 157.55.32.0/22, 157.55.36.0/24, 157.55.48.0/24, 157.55.109.0/24, 157.55.110.40/29, 157.55.110.48/28, 157.56.92.0/24, 157.56.93.0/24, 157.56.94.0/23, 157.56.229.0/24, 199.30.16.0/24, 207.46.12.0/23, 207.46.192.0/24, 207.46.195.0/24, 207.46.199.0/24, 207.46.204.0/24, 157.55.39.0/24',
            'yahoo'  => '67.195.37.0/24, 67.195.50.0/24, 67.195.110.0/24, 67.195.111.0/24, 67.195.112.0/23, 67.195.114.0/24, 67.195.115.0/24, 68.180.224.0/21, 72.30.132.0/24, 72.30.142.0/24, 72.30.161.0/24, 72.30.196.0/24, 72.30.198.0/24, 74.6.254.0/24, 74.6.8.0/24, 74.6.13.0/24, 74.6.17.0/24, 74.6.18.0/24, 74.6.22.0/24, 74.6.27.0/24, 98.137.72.0/24, 98.137.206.0/24, 98.137.207.0/24, 98.139.168.0/24, 114.111.95.0/24, 124.83.159.0/24, 124.83.179.0/24, 124.83.223.0/24, 183.79.63.0/24, 183.79.92.0/24, 203.216.255.0/24, 211.14.11.0/24'
        );

        // Compare IP with a CIDR address or range
        $ip_array = $this->get_client_ips();
        $client_ip = reset($ip_array);
        foreach ($crawlers as $ip_address_list) {
            $ip_addresses = array_map('trim', explode(',', $ip_address_list));
            if ($this->match_client_ip($ip_addresses, $client_ip)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Logs the user activity in antibot database.
     * 
     * @since   4.1.0.5
     * @access  public
     * 
     * @param   string $uid
     * @param   string $description
     * @return  array
     */
    public function log_antibot_activity($uid = '', $description = '')
    {
        $ip_array = $this->get_client_ips();
        $ip_array[] = $uid;

        // Insert a new entry
        $packed_entry = $this->insert_packed_entry($this->antibot_filename, $this->antibot_expiry, $ip_array,
                                                   $description);
        return $packed_entry;
    }

    // --- IP FILTER ---

    /**
     * Checks whether the user's IP is blacklisted.
     * 
     * @since   4.2.1.5
     * @access  public
     * 
     * @return  bool
     */
    public function is_client_blacklisted()
    {
        return $this->is_client_ipfiltered($rule = 1); //block
    }

    /**
     * Checks whether the user's IP is whitelisted.
     * 
     * @since   4.2.1.5
     * @access  public
     * 
     * @return  bool
     */
    public function is_client_whitelisted()
    {
        return $this->is_client_ipfiltered($rule = 0); //allow
    }

    /**
     * Checks whether the user's IP is whitelisted or blacklisted.
     * 
     * @since   4.2.1.5
     * @access  public
     * 
     * @param   int $rule   Set this to "0" for allow and to "1" for block rules.
     * @return  bool
     */
    public function is_client_ipfiltered($rule = 0)
    {
        $ip_array = $this->get_client_ips();
        $client_ip = reset($ip_array);

        // Load IP filter entries
        $path_to_ipfilter_file = $this->temp_dir_path . '/' . $this->ipfilter_filename;
        $ipfilter_entries = $this->cwis_defender_filesystem->load_cache_file_contents($path_to_ipfilter_file, true);
        if (null !== $ipfilter_entries && isset($ipfilter_entries[$rule])) {
            $ipfilter_block_list = $ipfilter_entries[$rule];

            // Compare IP with a CIDR address or range
            $ip_addresses = array_map('trim', explode(',', $ipfilter_block_list));
            if ($this->match_client_ip($ip_addresses, $client_ip)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Saves IP-filter entries to the cache file.
     * 
     * @since   4.2.1.5
     * @access  public
     * 
     * @param   array $ipfilter_entries
     * @return  mixed
     */
    public function save_ipfilter_entries($ipfilter_entries = array())
    {
        $path_to_guarder_file = $this->temp_dir_path . '/' . $this->ipfilter_filename;
        return $this->cwis_defender_filesystem->save_cache_file_contents($path_to_guarder_file, $ipfilter_entries);
    }

    // --- USER ACCESS ---

    /**
     * Blocks user access immediately.
     * 
     * @since   1.4.0
     * @access  public
     * 
     * @return void
     */
    public function block_user_access($packed_entry = '')
    {
        if (!empty($packed_entry)) {
            $this->log_user_block($packed_entry);
        }

        header('Status: 503 Service Unavailable');
        die('You have been blocked.');
    }

    /**
     * Inserts IP(s) into database and blocks user immediately.
     * 
     * @since   1.4.0
     * @access  public
     * 
     * @param   string $description
     * @return  void
     */
    public function block_user_ip($description = '')
    {
        $ip_array = $this->get_client_ips();

        // Insert a new entry and block user
        $packed_entry = $this->insert_packed_entry($this->guarder_filename, $this->guarder_expiry, $ip_array,
                                                   $description);
        $this->block_user_access($packed_entry);
    }

    /**
     * Inserts IP(s) into database at once and blocks user immediately.
     * 
     * @since   4.0.2
     * @access  public
     * 
     * @param   string $description
     * @return  void
     */
    public function block_user_ip_once($description = '')
    {
        // Block the user if his IP-address has been blocked previously
        if (false !== ($packed_entry = $this->check_user_ip())) {
            $this->block_user_access($packed_entry);
        }

        // Insert IP and block the user
        $this->block_user_ip($description);
    }

    /**
     * Checks for user IP in database and returns a record if matched.
     * 
     * @since   1.4.0
     * @access  public
     * 
     * @return bool|string
     */
    public function check_user_ip()
    {
        $ip_array = $this->get_client_ips();
        $the_packed_ip = implode('|', $ip_array);

        // Block user IP if matched (in current day's logs)
        $packed_entries = $this->fetch_packed_entries($this->guarder_filename, $this->guarder_block);
        if (is_array($packed_entries)) {
            foreach ($packed_entries as $packed_entry) {
                if (false !== strpos($packed_entry, $the_packed_ip)) {
                    return $packed_entry;
                }
            }
        }

        return false;
    }

    /**
     * Identifies bad bots by user agent and blocks them.
     * 
     * @since   1.5.0
     * @access  public
     * 
     * @return  void
     */
    public function check_user_agent()
    {
        // Check if the user does not already blocked by user agent
        if (false !== ($packed_entry = $this->check_user_ip())) {
            foreach ($this->unwanted_user_agents as $description => $regex_pattern) {
                if (false !== strpos($packed_entry, "\t" . $description)) {
                    $this->block_user_access();
                }
            }
        }

        // Block bad bots and spiders by user agent match
        $user_agent = $this->get_user_agent();
        foreach ($this->unwanted_user_agents as $description => $regex_pattern) {
            if ($regex_pattern && preg_match('~' . $regex_pattern . '~si', $user_agent)) {
                $this->block_user_ip($description);
            }
        }
    }

    /**
     * Returns the user agent string for the current browser.
     * 
     * @since   4.1.0
     * @access  public
     * 
     * @return  string
     */
    public function get_user_agent()
    {
        // Used for debugging: /?UA=1
        if (isset($_GET['UA']) && $_GET['UA']) {
            $http_user_agents = array(
                'Mozilla/5.0 (compatible; SMTBot/1.0; +http://www.similartech.com/smtbot)',
                'GetRight/6.0',
                'Mozilla/5.0 (compatible; MJ12bot/v1.2.4; http://www.majestic12.co.uk/bot.php?+)',
                'WPScan v1.2 (http://wpscan.org)'
            );

            $_SERVER['HTTP_USER_AGENT'] = $http_user_agents[rand(0, count($http_user_agents) - 1)];
        }

        return isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '';
    }

    // --- DEFENDER ---

    /**
     * Checks for user data in traffic database.
     * 
     * @since   4.1.2.5
     * @access  public
     * 
     * @return  array
     */
    public function check_pageviews_activity()
    {
        $ip_array = $this->get_client_ips();
        $client_ip = reset($ip_array);

        // Check if user data is matched in current hour's logs
        $traffic_entries_60 = $this->fetch_packed_entries($this->traffic_filename, 3600);
        $traffic_matches_60 = $this->match_packet_entries($traffic_entries_60, $client_ip, null, 'compact');
        $combined_entries_60 = $this->combine_entries_by_time_intervals($traffic_matches_60);
        $combined_entries_60['total'] = count($traffic_entries_60);

        // Check if user data is matched in 15 min period's logs
        $traffic_entries_15 = $this->filter_packed_entries($traffic_entries_60, 900);
        $traffic_matches_15 = $this->match_packet_entries($traffic_entries_15, $client_ip, null, 'compact');
        $combined_entries_15 = $this->combine_entries_by_time_intervals($traffic_matches_15);
        $combined_entries_15['total'] = count($traffic_entries_15);

        return array(
            15 => $combined_entries_15,
            60 => $combined_entries_60
        );
    }

    /**
     * Returns the WAF statistics in AmCharts-compatible format.
     * 
     * @since   4.0.0
     * @access  public
     * 
     * @return  array
     */
    public function get_defender_pageview_stats()
    {
        $stats = array();

        // Get blocked entries
        $blocked_entries = array_values((array) $this->fetch_packed_entries($this->guarder_filename,
                                                                            $this->guarder_expiry));
        $combined_badbots = $this->combine_packed_entries($blocked_entries, "\tBadBot");
        //$combined_bruteforce = $this->combine_packed_entries($blocked_entries, "\tBruteForce");
        $combined_blocked = $this->combine_packed_entries($blocked_entries);

        // Get traffic entries
        $traffic_entries = array_values((array) $this->fetch_packed_entries($this->traffic_filename,
                                                                            $this->guarder_expiry));
        $combined_traffic = $this->combine_packed_entries($traffic_entries);

        // Collect WAF statistics
        $days = floor(time() / 86400);
        for ($day = $days - 21; $day <= $days; $day++) {
            $date = $day * 86400; //midnight time in sec
            $badbots = $blocked = $visits = $pageviews = 0;
            if (isset($combined_badbots[$date])) {
                $badbots = count(array_unique($combined_badbots[$date]));
            }
            //if (isset($combined_bruteforce[$date])) {
            //$bruteforce = count(array_unique($combined_bruteforce[$date]));
            //}
            if (isset($combined_blocked[$date])) {
                $blocked = count(array_unique($combined_blocked[$date]));
            }
            if (isset($combined_traffic[$date])) {
                $pageviews = count($combined_traffic[$date]);
                $visits = count(array_unique($combined_traffic[$date]));
            }
            $stats[] = array(
                'date'      => $date * 1000,
                'badbots'   => $badbots,
                //'bruteforce' => $bruteforce,
                'blocked'   => $blocked,
                'pageviews' => $pageviews,
                'visits'    => $visits
            );
        }

        return $stats;
    }

    /**
     * Manages "hunting traps", sets or removes guarder from paths.
     * 
     * @since   1.4.0
     * @access  public
     * 
     * @param   bool $enable
     * @return  void
     */
    public function manage_traps($enable = false)
    {
        $opening_tag = '<?php /* CWSD Guarder */';
        $closing_tag = '?>';

        $path_to_guarder = $this->plugin_dir_path . 'cwsd-block.php';
        foreach ($this->paths_to_traps as $path_to_trap) {
            $path_to_file = ABSPATH . $path_to_trap;
            $directives = 'is_file("' . $path_to_guarder . '") AND include_once "' . $path_to_guarder . '";';
            $this->cwis_defender_filesystem->update_file_directives($path_to_file, $enable ? $directives : '',
                                                                    $opening_tag, $closing_tag);
        }
    }

    /**
     * Tracks the page views.
     * 
     * @since   4.0.2
     * @access  public
     * 
     * @return  void
     */
    public function track_pageview($description = '')
    {
        $ip_array = $this->get_client_ips();
        $the_packed_ip = implode('|', $ip_array);
        $the_keyword = $the_packed_ip . ($description ? "\t" . $description : '');

        // Get the packed entries from the cache
        $packed_entries = array_values((array) $this->fetch_packed_entries($this->traffic_filename,
                                                                           $this->guarder_expiry));

        // Check the latest entry's IP
        $last_entry = end($packed_entries);
        if (false !== strpos($last_entry, $the_keyword)) {
            return null; //skip the hit
        }

        // Create a packed entry and update packed entries
        $milli_seconds = $this->get_fractional_seconds($digits = 3);
        $the_packed_entry = $this->create_packed_entry($ip_array, $description, $date_format = 'U.' . $milli_seconds);
        $updated_packed_entries = array_merge($packed_entries, array($the_packed_entry));

        // Save updated packed entries (insert a new page view entry)
        $path_to_guarder_file = $this->temp_dir_path . '/' . $this->traffic_filename;
        $this->cwis_defender_filesystem->save_cache_file_contents($path_to_guarder_file, $updated_packed_entries);
    }

    // --- UNIQUE ID ---

    /**
     * Creates a unique ID, containing a 6-digit salt.
     * 
     * @since   4.0.2
     * @access  public
     * 
     * @param   string $nonce
     * @param   int $length
     * @param   int $salt
     * @return  string
     */
    public function create_cwsd_uid($nonce = '', $length = 9, $salt = null)
    {
        $cwsd_salt = (null == $salt) ? substr(strrev(substr(microtime(), -6) + rand(0, 999999)), -5) : $salt;
        $cwsd_uniqid = $this->genetate_uniqid($cwsd_salt . $nonce, $this->guarder_expiry);
        return substr($cwsd_uniqid, (32 - $length) >> 1, $length) . '_' . $cwsd_salt;
    }

    /**
     * Validates a unique ID, containing a 6-digit salt.
     * 
     * @since   4.0.2
     * @access  public
     * 
     * @param   string $uid
     * @param   string $nonce
     * @param   int $length
     * @return  bool
     */
    public function is_valid_cwsd_uid($uid = '', $nonce = '', $length = 9)
    {
        list($cwsd_uid, $cwsd_salt) = array_pad(explode('_', $uid), 2, null);
        $_cwsd_uid = $this->create_cwsd_uid($nonce, $length, $cwsd_salt);
        return ($uid === $_cwsd_uid);
    }

    /**
     * Generates a "uniqid" value, used internally by Guarder.
     * 
     * @since   4.0.2
     * @access  private
     *
     * @param   string $salt
     * @param   int $expiry Expiry time in seconds (disabled by default).
     * @return  string
     */
    private function genetate_uniqid($salt = '', $expiry = 0)
    {
        $expiry_time_factor = $expiry > 0 ? round(time() / $expiry / 2) : 0;
        $script_filename = isset($_SERVER['DOCUMENT_ROOT']) ? dirname($_SERVER['DOCUMENT_ROOT']) : '';
        $server_admin = isset($_SERVER['SERVER_ADMIN']) ? $_SERVER['SERVER_ADMIN'] : '';
        return md5('UID:' . $salt . $expiry_time_factor . $script_filename . $server_admin);
    }

    // --- FILESYSTEM ---

    /**
     * Returns an array of packed entries from a database, filtered by expiry time.
     *
     * @since   1.4.0
     * @access  private
     * 
     * @param   string $filename
     * @param   int $expiry_time
     * @return  array
     */
    private function fetch_packed_entries($filename, $expiry_time = 86400)
    {
        $path_to_guarder_file = $this->temp_dir_path . '/' . $filename;
        $packed_entries = $this->cwis_defender_filesystem->load_cache_file_contents($path_to_guarder_file, true);

        return $this->filter_packed_entries($packed_entries, $expiry_time);
    }

    /**
     * Inserts packed entry into database.
     * 
     * @since   1.4.0
     * @access  private
     * 
     * @param   string $filename
     * @param   int $expiry_time
     * @param   array $ip_array
     * @param   string $description
     */
    private function insert_packed_entry($filename, $expiry_time = 86400, $ip_array = array(), $description = '')
    {
        // Get the packed entries from the cache
        $packed_entries = array_values((array) $this->fetch_packed_entries($filename, $expiry_time));

        // Create a packed entry and update cache
        $the_packed_entry = $this->create_packed_entry($ip_array, $description);
        $updated_packed_entries = array_merge($packed_entries, array($the_packed_entry));

        // Save updated packed entries
        $path_to_guarder_file = $this->temp_dir_path . '/' . $filename;
        $this->cwis_defender_filesystem->save_cache_file_contents($path_to_guarder_file, $updated_packed_entries);

        return $the_packed_entry;
    }

    // --- PACKED ENTRIES ---

    /**
     * Combines entries by time intervals, rounded in step of 1/{$steps} sec
     * 
     * @since   4.1.2.5
     * @access  private
     * 
     * @param   array $packed_entries
     * @param   int $steps
     * @return  array
     */
    private function combine_entries_by_time_intervals($packed_entries = array(), $steps = 10)
    {
        $entries = 0;
        $combined = array(
            'all'    => array(),
            'assets' => array(),
            'pages'  => array()
        );
        $factor = 0;

        // Combine entries by intervals
        $packed_entry_prev = null;
        foreach ($packed_entries as $packed_entry) {
            if ($packed_entry_prev) {
                $entry_interval = is_array($packed_entry) ? $packed_entry['entry_interval'] : ($packed_entry - $packed_entry_prev);
                $interval_rounded = round($steps * $entry_interval);
                if (is_array($packed_entry)) {
                    if ('.' === $packed_entry['entry_description'][0]) {
                        if (!isset($combined['assets'][$interval_rounded])) {
                            $combined['assets'][$interval_rounded] = 0;
                        }
                        $combined['assets'][$interval_rounded] ++;
                    } else {
                        if (!isset($combined['pages'][$interval_rounded])) {
                            $combined['pages'][$interval_rounded] = 0;
                        }
                        $combined['pages'][$interval_rounded] ++;
                    }
                }
                if (!isset($combined['all'][$interval_rounded])) {
                    $combined['all'][$interval_rounded] = 0;
                }
                $combined['all'][$interval_rounded] ++;
                $entries++;
            }
            $packed_entry_prev = $packed_entry;
        }

        // Calculate the "bot-factor"
        $combined_intervals = !empty($combined['pages']) ? $combined['pages'] : $combined['all'];
        foreach ($combined_intervals as $interval_rounded => $interval_count) {
            $factor += round(($interval_count - 1) / sqrt($interval_rounded + 1), 3);
        }

        return compact('combined', 'entries', 'factor');
    }

    /**
     * Combines packed entries.
     * 
     * @since   1.4.0
     * @access  private
     * 
     * @param   array $packed_entries
     * @param   null|string $match_subject
     * @return  array
     */
    private function combine_packed_entries($packed_entries = array(), $match_subject = null)
    {
        $result = array();
        if (is_array($packed_entries)) {
            foreach ($packed_entries as $packed_entry) {
                if ($match_subject && false === strpos($packed_entry, $match_subject)) {
                    continue;
                }

                $entry_elements = explode("\t", $packed_entry);
                if (($entry_timestamp = $entry_elements[0]) && !is_numeric($entry_timestamp)) {
                    $entry_timestamp = strtotime($entry_elements[0]);
                }

                $date = $entry_timestamp - $entry_timestamp % 86400;
                $result[$date][] = $entry_elements[1]; //the packed IP
            }
        }

        return $result;
    }

    /**
     * Creates a packed entry.
     * 
     * @since   1.4.0
     * @access  private
     * 
     * @param   array $ip_array
     * @param   string $description
     * @param   string $date_format
     * @return  array
     */
    private function create_packed_entry($ip_array = array(), $description = '', $date_format = 'Y-m-d H:i:s')
    {
        if (!is_array($ip_array)) {
            $ip_array = array($ip_array);
        }

        // Create a packed entry and update cache
        $the_packed_ip = implode('|', $ip_array);
        $the_packed_entry = date($date_format) . "\t" . $the_packed_ip . ($description ? "\t" . $description : '');

        return $the_packed_entry;
    }

    /**
     * Returns packed entries filtered by expiry time (one day by default).
     *
     * @since   4.0.2
     * @access  private
     * 
     * @param   array $packed_entries
     * @param   int $expiry_time
     * @return  array
     */
    private function filter_packed_entries($packed_entries = array(), $expiry_time = 86400)
    {
        // Ignore expired entries
        if (is_array($packed_entries)) {
            $guarder_expiry_time = time() - $expiry_time;
            foreach ($packed_entries as $i => $packed_entry) {
                $entry_elements = explode("\t", $packed_entry);
                if (($entry_timestamp = $entry_elements[0]) && !is_numeric($entry_timestamp)) {
                    $entry_timestamp = strtotime($entry_elements[0]);
                }
                if ($entry_timestamp && $entry_timestamp < $guarder_expiry_time) {
                    unset($packed_entries[$i]);
                }
            }
        }

        return $packed_entries;
    }

    /**
     * Searches for user data and description matches.
     * 
     * @since   4.1.1
     * @access  private
     * 
     * @param   array $packed_entries
     * @param   array $the_packed_ip
     * @param   array|string $description
     * @param   string $return
     * @return  array
     */
    private function match_packet_entries($packed_entries = array(), $the_packed_ip = '', $description = null, $return = null)
    {
        $matches = array();
        if (is_array($packed_entries)) {
            $entry_timestamp_prev = 0;
            foreach ($packed_entries as $packed_entry) {
                // Check if both the user data and description are matched
                if (false !== strpos($packed_entry, $the_packed_ip)) {
                    $entry_elements = explode("\t", $packed_entry);
                    if (($entry_timestamp = $entry_elements[0]) && !is_numeric($entry_timestamp)) {
                        $entry_timestamp = strtotime($entry_elements[0]);
                    }
                    $entry_interval = $entry_timestamp_prev ? round($entry_timestamp - $entry_timestamp_prev, 6) : 0;
                    $entry_description = end($entry_elements);
                    $is_matched_exactly = empty($description) ? true : (is_array($description) ?
                                    in_array($entry_description, $description) :
                                    (bool) ($entry_description == $description));

                    // Collect matches, optionally filter results by description
                    switch ($return) {
                        case 'compact':
                            $matches[] = compact('entry_description', 'entry_interval', 'entry_timestamp',
                                                 'is_matched_exactly');
                            break;

                        case 'description':
                            if ($is_matched_exactly) {
                                $matches[] = $entry_description;
                            }
                            break;

                        case 'interval':
                            if ($is_matched_exactly) {
                                $matches[] = $entry_interval;
                            }
                            break;

                        case 'timestamp':
                            if ($is_matched_exactly) {
                                $matches[] = $entry_timestamp;
                            }
                            break;

                        default;
                            $matches[] = $is_matched_exactly;
                    }

                    $entry_timestamp_prev = $entry_timestamp;
                }
            }
        }

        return $matches;
    }

    // --- UTILITIES ---

    /**
     * Retrieves the list of the client's IP addresses.
     * Takes into account numerous HTTP proxy headers due to variations
     * in how different ISPs handle IP addresses in headers between hops.
     *
     * @since   1.4.0
     * @access  private
     * 
     * @param   bool $ip2long
     * @return  array
     */
    private function get_client_ips($ip2long = false)
    {
        $result = array();
        $server_keys = array(
            'HTTP_CLIENT_IP',
            'HTTP_X_FORWARDED_FOR',
            'HTTP_X_FORWARDED',
            'HTTP_X_CLUSTER_CLIENT_IP',
            'HTTP_FORWARDED_FOR',
            'HTTP_FORWARDED',
            'REMOTE_ADDR'
        );

        // Process server environment
        foreach ($server_keys as $key) {
            if (!isset($_SERVER[$key])) {
                continue;
            }

            // Check for multiple IP addresses
            $ips = array_map('trim', explode(',', $_SERVER[$key]));
            foreach ($ips as $ip) {
                if (false !== filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) {
                    if ($ip2long) {
                        $ip = sprintf('%u', ip2long($ip));
                    }

                    // Unique IPs
                    if (!in_array($ip, $result)) {
                        array_push($result, $ip);
                    }
                }
            }
        }

        return $result;
    }

    private function get_fractional_seconds($digits = 6)
    {
        $microtime = microtime(true);
        return sprintf("%0" . $digits . "d", ($microtime - floor($microtime)) * pow(10, $digits));
    }

    /**
     * Logs user block event.
     * 
     * @since   1.4.0
     * @access  private
     * 
     * @param string $packed_entry
     * @return mixed
     */
    private function log_user_block($packed_entry = '')
    {
        $entry_elements = explode("\t", $packed_entry);
        $description = count($entry_elements) > 1 ?
                (isset($entry_elements[2]) ? $entry_elements[2] : '') : $packed_entry;
        $message = $description ? //log message
                'blocked with entry ' . $description : //non-Trap type of block
                'blocked by Trap ' . str_replace('/index.php', '/', $_SERVER['SCRIPT_NAME']);

        // Compose a log record
        $ip_array = $this->get_client_ips();
        $client_ip = reset($ip_array);
        $user_agent = $this->get_user_agent();
        $log_entry = date("Y-m-d H:i:s") . "\t" . ('IP ' . $client_ip . ' ' . $message) . "\t" . $user_agent;

        // Save trimmed content
        $path_to_log_file = $this->temp_dir_path . '/' . $this->log_filename;
        $log_entry_trimmed = strlen($log_entry) > 192 ? substr($log_entry, 0, 192) . '...' : $log_entry;
        return @file_put_contents($path_to_log_file, $log_entry_trimmed . PHP_EOL, FILE_APPEND | LOCK_EX);
    }

    /**
     * Compares the IP address of the client with the address or range of CIDR.
     * 
     * @since   3.2.1
     * @access  private
     * 
     * @param   array $ip_addresses
     * @param   string $client_ip
     * @return  bool
     */
    private function match_client_ip($ip_addresses = array(), $client_ip = '')
    {
        // Require and init the guarder class
        require_once dirname(__FILE__) . '/class-cidr.php';
        $cwis_defender_cidr = new Cwis_Defender_Cidr();

        // Compare client IP with a CIDR address or range
        foreach ($ip_addresses as $ip_address) {
            if (strlen($ip_address) > 2 && //check minimum length of an IP address in string
                    (substr_count($ip_address, '.') === 3 || substr_count($ip_address, '::') >= 2)) {
                if ($cwis_defender_cidr->match($client_ip, $ip_address)) { //compare addresses
                    return true;
                }
            }
        }

        return false;
    }

}
